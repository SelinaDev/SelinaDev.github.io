<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="generator" content="Hugo 0.118.2">
  <link rel="canonical" href="https://selinadev.github.io/11-rogueliketutorial-07/">

  
    
    <meta name="description" content="Part 7: Creating the Interface Welcome back to the roguelike tutorial series. This tutorial will continue from where the last one left off. You can find the previous tutorial here: https://selinadev.github.io/10-rogueliketutorial-06/
A note beforehand: I noticed that in the current version the parser wonâ€™t properly reparse the project, or at least some changes are not registered from other scripts. Sometimes throughout writing this code that has caused issues for me, when something would report an error, or a new option was not shown in an exported variable.">
  

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#000000">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" type="text/css" href="/css/paper.css">

  
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css">
  
  
    
  

  
  
  <title>Yet Another Roguelike Tutorial, Part 7 | SelinaDev</title>
</head>

  <body>
    <div class="container paper">
      <nav class="border split-nav">
  <div class="nav-brand">
    <h3><a href="/">SelinaDev</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
    <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
      
        <li><a href="/">Blog</a></li>
      
        <li><a href="/tags/">Tags</a></li>
      
        <li><a href="/about/">About</a></li>
      
      </ul>
    </div>
  </div>
</nav>
      <main>
        

<h1 class="post-title">Yet Another Roguelike Tutorial, Part 7</h1>


<strong>Publish date: </strong>Jul 31, 2023
<br>

  <strong>Tags: </strong>
  
    <a href="/tags/godot4">godot4</a>
  
    <a href="/tags/tutorial">tutorial</a>
  
    <a href="/tags/roguelike">roguelike</a>
  



  



<h1 id="part-7-creating-the-interface">Part 7: Creating the Interface</h1>
<p>Welcome back to the roguelike tutorial series. This tutorial will continue from where the last one left off. You can find the previous tutorial here: <a href="https://selinadev.github.io/10-rogueliketutorial-06/">https://selinadev.github.io/10-rogueliketutorial-06/</a></p>
<p>A note beforehand: I noticed that in the current version the parser won&rsquo;t properly reparse the project, or at least some changes are not registered from other scripts. Sometimes throughout writing this code that has caused issues for me, when something would report an error, or a new option was not shown in an exported variable. Should you encounter such issues, the best way I have found to deal with that problem is to reload the project. You can do so under <em>Project</em> &gt; <em>Reload Current Project</em>.</p>
<p>This part will deal with displayed text for the first time. So we need some fonts. I used Kenney&rsquo;s font pack, which you can find here: <a href="https://kenney.nl/assets/kenney-fonts">https://kenney.nl/assets/kenney-fonts</a>, or included in the project files for this part in the GitHub repository: <a href="https://github.com/SelinaDev/Godot-Roguelike-Tutorial">https://github.com/SelinaDev/Godot-Roguelike-Tutorial</a>. I have placed them under <em>res://assets/fonts</em>.</p>
<p>We will now start with our interface. This is the part where we will probably diverge from the original python tutorial the most, to do things the Godot way. We did a bit of that in the last tutorial, with the state machine and the signal that triggered its transition, but this time we will go all out. Right away we will see a huge refactor of our scene tree. We will use that to create a panel at the bottom of the screen, where we show the player&rsquo;s health bar, as well as a log for the messages we have only printed to the console so far. These messages will have a few different colors to differentiate the message type, so let&rsquo;s start out with a file to hold some color definitions. For that create a new script extending <code>RefCounted</code> at <em>res://src/Utils/colors.gd</em>, and fill it with the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span>class_name GameColors
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> RefCounted
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> PLAYER_ATTACK <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span>(<span style="color:#e6db74">&#34;e0e0e0&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> ENEMY_ATTACK <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span>(<span style="color:#e6db74">&#34;ffc0c0&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> PLAYER_DIE <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span>(<span style="color:#e6db74">&#34;ff3030&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> ENEMY_DIE <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span>(<span style="color:#e6db74">&#34;ffa030&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> WELCOME_TEXT <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span>(<span style="color:#e6db74">&#34;20a0ff&#34;</span>)
</span></span></code></pre></div><p>Here we define a few constant color values for different kind of messages. As they are constants and this script has a <code>class_name</code> we will be able to easily access these values in code later.</p>
<p>Now for the big remodel. What we want is a bar across the bottom of the screen. That bar should be segmented into two panels, one of which showing the player&rsquo;s health bar, the other showing the message log. We could simply overlay these on top of what we already have. However, we show the player centered on the screen, if we simply overlayed the GUI on one side of the screen we would introduce some asymmetry. By blocking of a bar on the bottom of the screen the center of the screen, where the player is drawn, is now closer to the edge of that bar than it is to the top of the screen. This could seem weird. To circumvent that, we have to tell Godot that info bar is one area, and that it should use the rest for drawing from the camera, so the camera centers in that remaining part of the screen. Fortunately, Godot&rsquo;s UI system makes this relatively easy, if you know what you have to do. The interface we will build might seem overwhelming, because it will consist of quite a few nodes, but each of those nodes has a specific purpose, so I do hope that it will make sense in the end.</p>
<p>To start of, go into the scene tree of the <strong>Game</strong> scene and add another <code>Control</code> node as a child. Call it <strong>InterfaceRoot</strong>. Right-click it and select <em>Make Scene Root</em>. Now it should be at the top of the tree, with <strong>Game</strong> being a child of it. First things first, click the <strong>InterfaceRoot</strong> and make sure you are in the <em>2D</em> editing workspace. In the main window select the <em>Anchor presets</em> (the icon that looks like a little plus in a circle, left of the anchor icon), and select the bottom right option <em>Full Rect</em>.</p>
<p>Now, we said we wanted to have the game world and the info panel one on top of the other, so in order to split things vertically, we need a new <code>VBoxContainer</code> as a child of <strong>InterfaceRoot</strong>. Set this to <em>Full Rect</em> as well. Create a new <code>SubViewportContainer</code> as a child of that <strong>VBoxContainer</strong>. It will hold the viewport our camera will draw to. Check the <em>Stretch</em> property, and under <em>Layout</em> &gt; <em>Container Sizing</em> &gt; <em>Vertical</em> check the <em>Expand</em> property. Now create a <code>SubViewport</code> as a child of <strong>SubViewportContainer</strong>. On that check <em>Viewport</em> &gt; <em>Disable 3D</em> Also scroll down to <em>Viewport</em> &gt; <em>Canvas Items</em> &gt; <em>Default Texture Filter</em> and set it to <em>Nearest</em> (otherwise our pixel art would be blurry).</p>
<p>The last part of this refactor is to take the <strong>Game</strong> node and drag it into the <strong>SubViewport</strong>. With that the game will be rendered right inside our defined little window, which incidentally is the whole screen right now. You should be able to run the project at this point, and everything should look just like it did before.</p>
<p>Let&rsquo;s start assembling the bottom panel now. We want two panels side by side, horizontally, so we add a <code>HBoxContainer</code> as a child of the <strong>VBoxContainer</strong> and call it <strong>InfoBar</strong>. In <em>Layout</em> &gt; <em>Container Sizing</em> check the <em>Vertical Expand</em>. This would cause the bottom panel to take up half of the vertical space, which is a bit much. We could also set a fixed height, but instead let&rsquo;s go back into <strong>SubViewportContainer</strong> and into <em>Layout</em> &gt; <em>Container Sizing</em>. There, set the <em>Stretch Ratio</em> to 5. As <strong>SubViewportContainer</strong> and <strong>InfoBar</strong> are the two children of <strong>VBoxContainer</strong>, and both are set to expand vertically, they will share the available vertical space. However, now that <strong>SubViewportContainer</strong> has a stretch ratio of 5, it will take up five parts of that space, while <strong>InfoBar</strong> will only take up 1. This results in the <strong>InfoBar</strong> (and thereby also our panels) only taking up a sixth of the vertical space (1 part of a total of 5 + 1 = 6 parts). Lastly, to make sure there is no gap between the two panels we will create as the part of the <strong>InfoBar</strong>, we set <em>Theme Overrides</em> &gt; <em>Constants</em> &gt; <em>Separation</em> to 0.</p>
<p>Now we start filling the <strong>InfoBar</strong>. Create two <code>PanelContainer</code>s as children of <strong>InfoBar</strong>. Name one <strong>StatsPanel</strong> and the other <strong>MessagesPanel</strong>. In the <strong>StatsPanel</strong> we set the <em>Layout</em> &gt; <em>Container Sizing</em> &gt; <em>Horizontal</em> <em>Expand</em> to true. We do the same for the <strong>MessagesPanel</strong>, but we want that to take up more of the horizontal space, so we set the <em>Stretch Ratio</em> to 2. This means the <strong>MessagesPanel</strong> will be double as wide as the <strong>StatsPanel</strong>.</p>
<p>We still need to style these panels. To do that, we use another trick involving our sprite sheet. In the <strong>StatsPanel</strong> under <em>ThemeOverrides</em> &gt; <em>Styles</em> click into the slot for <em>Panel</em> and create a new <code>StyleBoxTexture</code>. For the texture create a new <code>AtlasTexture</code>, and set our familiar sprite sheet as texture. Then edit the region and select the last tile at the bottom right. You should see a little rectangle. Back in the <code>StyleBoxTexture</code> set all the <em>Texture Margins</em> to 5 px, and all the <em>Content Margins</em> to 8 px. Now this rectangle should stretch properly. Click on the downwards arrow next to the <code>StyleBoxTexture</code> in the <em>Panel</em> slot, and select <em>Copy</em> at the bottom of the list. Now go into the <strong>MessagesPanel</strong>, and under <em>ThemeOverrides</em> &gt; <em>Styles</em> click into the slot next to <em>Panel</em> and select <em>Paste</em>. Now both our containers are styled.</p>
<p>First, let&rsquo;s put our attention towards creating the health bar. We don&rsquo;t want the health bar to take up the whole left panel, but instead to sit at the top of it. That basically means aligning it vertically, so we create a new <code>VBoxContainer</code> as child of <strong>StatsPanel</strong>. The health bar itself will consist of the bar and a label sitting on top of it. The best way to align multiple elements on top of each other and stretch them to the available space is to use a <code>MarginContainer</code>, so create a new one as a child of the <strong>VBoxContainer</strong> we just created. Call that <code>MarginContainer</code> <strong>HpDisplay</strong>. We&rsquo;ll create two children for it, first a <code>ProgressBar</code> which we call <strong>HpBar</strong> and then a <code>Label</code> which we call <strong>HpLabel</strong>.</p>
<p>On the <strong>HpBar</strong> untick <em>Show Percentage</em> and set the <em>Step</em> to 1. Then, under <em>Theme Overrides</em> &gt; <em>Styles</em> create a new <code>StyleBoxFlat</code> in both the <em>Back</em> and the <em>Fill</em> slot. I set the <em>Color</em> in the <em>Back</em> style box to <em>#7f0000</em>, and the <em>Color</em> in the <em>Front</em> one to <em>#007f00</em>. On the <strong>HpLabel</strong> set both <em>Horizontal Alignment</em> and <em>Vertical Alignment</em> to <em>Center</em>. Then create a new <em>Label Settings</em> resource. I will use &ldquo;<em>Kenney Pixel.ttf</em>&rdquo; as the <em>Font</em> and set the <em>Size</em> of the <em>Outline</em> to 4 and its <em>Color</em> to black. Let&rsquo;s also make these two nodes uniquely accessible. I doubt we will change the node structure of the health bar much, but it&rsquo;s good practice anyway. So right click <strong>HpBar</strong> and select <em>Access as Unique Name</em>, then do the same for <strong>HpLabel</strong>. You should see percentage signs next to their names in the scene tree now.</p>
<p>Now, to make this do something we create a script on <strong>HpDisplay</strong>, and save it at <em>res://src/GUI/hp_display.gd</em>. Here&rsquo;s the top of the script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">MarginContainer</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> hp_bar: <span style="color:#a6e22e">ProgressBar</span> <span style="color:#f92672">=</span> <span style="color:#f92672">$</span><span style="color:#e6db74">&#34;%HpBar&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> hp_label: <span style="color:#a6e22e">Label</span> <span style="color:#f92672">=</span> <span style="color:#f92672">$</span><span style="color:#e6db74">&#34;%HpLabel&#34;</span>
</span></span></code></pre></div><p>Here we get the two children with their scene unique names. If you are unfamiliar with that feature, the nice thing about this is that you could now change the scene tree around, create intermediate nodes, etc., but this script still won&rsquo;t need to change, as it will still find those nodes. Next, we need a function to actually change the values here.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> player_hp_changed(hp: <span style="color:#a6e22e">int</span>, max_hp: <span style="color:#a6e22e">int</span>) <span style="color:#f92672">-&gt;</span> void:
</span></span><span style="display:flex;"><span>	hp_bar<span style="color:#f92672">.</span>max_value <span style="color:#f92672">=</span> max_hp
</span></span><span style="display:flex;"><span>	hp_bar<span style="color:#f92672">.</span>value <span style="color:#f92672">=</span> hp
</span></span><span style="display:flex;"><span>	hp_label<span style="color:#f92672">.</span>text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;HP: </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">/</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> [hp, max_hp]
</span></span></code></pre></div><p>We have a function that takes in the hp and the max hp of the player. This is a bit lazy, as we could also store those values and only handle max hp when that value actually changes. But we expect the player&rsquo;s hp to change infrequently enough that this small overhead should not matter that much, so we prefer the easy solution. We change the value and max value of the <strong>HpBar</strong>, then construct a string showing the hp and set that as the text of the <strong>HpLabel</strong>. We need to set up a way to call that, so we will create a function to initialize the label:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> initialize(player: Entity) <span style="color:#f92672">-&gt;</span> void:
</span></span><span style="display:flex;"><span>	await ready
</span></span><span style="display:flex;"><span>	player<span style="color:#f92672">.</span>fighter_component<span style="color:#f92672">.</span>hp_changed<span style="color:#f92672">.</span>connect(player_hp_changed)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> player_hp: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> player<span style="color:#f92672">.</span>fighter_component<span style="color:#f92672">.</span>hp
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> player_max_hp: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> player<span style="color:#f92672">.</span>fighter_component<span style="color:#f92672">.</span>max_hp
</span></span><span style="display:flex;"><span>	player_hp_changed(player_hp, player_max_hp)
</span></span></code></pre></div><p>Here, we get the player. The problem here is that the way the scene tree is structured this function will be called before this node is ready, i.e., before it has references to its children, which would cause an error when we want to set those variables. We could ensure that this function is called with <code>call_deferred()</code>, but the other option is to have this function wait until it is ready by calling <code>await ready</code>. Next we see a signal on the fighter component, which we will shortly create, and which will inform us about changes to an entities hp. We connect that signal from the player&rsquo;s fighter component to our <code>player_hp_changed</code> function. That now handles most of the work. However, this will only fire once the player&rsquo;s hp changes, but starting out the state of the bar is still undefined. That&rsquo;s why we get the player&rsquo;s current hp and max hp and call <code>player_hp_changed()</code> manually right now, which will set the state of the bar to the starting hp and max hp of the player.</p>
<p>Let&rsquo;s handle the signal we mentioned real quick. In <em>fighter_component.gd</em> modify the top as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">signal</span> hp_changed(hp, max_hp)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> max_hp: <span style="color:#a6e22e">int</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> hp: <span style="color:#a6e22e">int</span>:
</span></span><span style="display:flex;"><span>	set(value):
</span></span><span style="display:flex;"><span>		hp <span style="color:#f92672">=</span> clampi(value, <span style="color:#ae81ff">0</span>, max_hp)
</span></span><span style="display:flex;"><span>		hp_changed<span style="color:#f92672">.</span>emit(hp, max_hp)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> hp <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>			die()
</span></span></code></pre></div><p>We add that signal, and then, in the setter we emit it after the hp have been changed. Right now we don&rsquo;t change the max hp in any way, so we don&rsquo;t need to handle that at the moment. Now that we have that in place, it&rsquo;s time to call the initialize function we created. We could pass around references to <strong>HpDisplay</strong> and call it directly somehow, but all the initialize function really needs is a reference to the player. So to get the player from the <strong>Game</strong> node to the <strong>HpDisplay</strong> node we use a signal. In <em>game.gd</em> add a signal at the top:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span>class_name Game
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Node2D</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">signal</span> player_created(player)
</span></span></code></pre></div><p>Then, at the top of the ready function, once we created the player, emit that signal:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> _ready() <span style="color:#f92672">-&gt;</span> void:
</span></span><span style="display:flex;"><span>	player <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(null, Vector2i<span style="color:#f92672">.</span>ZERO, player_definition)
</span></span><span style="display:flex;"><span>	player_created<span style="color:#f92672">.</span>emit(player)
</span></span></code></pre></div><p>The <strong>Game</strong> node will now emit a signal containing a reference to the player as soon as the player is created. However, at the moment no one is listening to that signal. So in the scene tree select <strong>Game</strong>, and switch the <em>Inspector</em> tab to the <em>Node</em> tab. In the <em>Signals</em> sub-tab you should now see the <code>player_created</code> signal. Double click that and select the <strong>HpDisplay</strong> as the target node. Under <em>Receiver Method</em> click the <em>Pick</em> button, and select <code>initialize()</code> in the window that appears. Click <em>Ok</em> on that window and <em>Connect</em> in the other window. Now you should be able to run the project and see a health bar. If you find an enemy and let them hit you you should see the health bar change according to the damage the player receives.</p>
<p>The next challenge is to get the messages on the screen. First, we create a class for messages. Create a new script extending <code>Label</code> at <em>res://src/GUI/message.gd</em>. Here is the script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span>class_name Message
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Label</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> plain_text: <span style="color:#a6e22e">String</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> count: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>	set(value):
</span></span><span style="display:flex;"><span>		count <span style="color:#f92672">=</span> value
</span></span><span style="display:flex;"><span>		text <span style="color:#f92672">=</span> full_text()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> _init(msg_text: <span style="color:#a6e22e">String</span>, foreground_color: <span style="color:#a6e22e">Color</span>) <span style="color:#f92672">-&gt;</span> void:
</span></span><span style="display:flex;"><span>	plain_text <span style="color:#f92672">=</span> msg_text
</span></span><span style="display:flex;"><span>	text <span style="color:#f92672">=</span> plain_text
</span></span><span style="display:flex;"><span>	autowrap_mode <span style="color:#f92672">=</span> TextServer<span style="color:#f92672">.</span>AUTOWRAP_WORD_SMART
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> full_text() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">String</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> (x</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">)&#34;</span> <span style="color:#f92672">%</span> [plain_text, count]
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> plain_text
</span></span></code></pre></div><p>We store the <code>plain_text</code> and a <code>count</code> variable. This is to group messages in case we send the same messages multiple times in a row. We discuss the setter of <code>count</code> in a moment. In <code>_init()</code> we simply set the plain text, then set the actual <code>text</code> of the label to the plain text. We also set the autowrap mode to smart autowrapping, in case we have long messages that need to take up multiple lines. The <code>full_text()</code> function assembles the message together with the count. In case we have a count larger than 1, this function appends that count. E.g., if the message is <em>&ldquo;You hit the Orc.&rdquo;</em> and the count is as 3, then this returns <em>&ldquo;You hit the Orc. (x3)&rdquo;</em>. That&rsquo;s why in the setter, when the count is changed we also set the text of the label to <code>full_text()</code>.</p>
<p>You notice that wi did not handle the color so far, and if you know Godot well enough you might also have caught that we didn&rsquo;t set a font so far, and would use the not so fitting default font. So create a new <code>LabelSettings</code> resource under <em>res://assets/resources/message_label_settings.tres</em>, and change the font to the font you want (I used &ldquo;<em>Kenney Pixel.ttf</em>&rdquo; again). Then, let&rsquo;s modify the script again:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span>class_name Message
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Label</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> base_label_settings: LabelSettings <span style="color:#f92672">=</span> preload(<span style="color:#e6db74">&#34;res://assets/resources/message_label_settings.tres&#34;</span>)
</span></span></code></pre></div><p>At the top we load that resource, so we can access it in the <code>_init()</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> _init(msg_text: <span style="color:#a6e22e">String</span>, foreground_color: <span style="color:#a6e22e">Color</span>) <span style="color:#f92672">-&gt;</span> void:
</span></span><span style="display:flex;"><span>	plain_text <span style="color:#f92672">=</span> msg_text
</span></span><span style="display:flex;"><span>	label_settings <span style="color:#f92672">=</span> base_label_settings<span style="color:#f92672">.</span>duplicate()
</span></span><span style="display:flex;"><span>	label_settings<span style="color:#f92672">.</span>font_color <span style="color:#f92672">=</span> foreground_color
</span></span><span style="display:flex;"><span>	text <span style="color:#f92672">=</span> plain_text
</span></span><span style="display:flex;"><span>	autowrap_mode <span style="color:#f92672">=</span> TextServer<span style="color:#f92672">.</span>AUTOWRAP_WORD_SMART
</span></span></code></pre></div><p>Here we set the <code>label_settings</code> of our label to a duplicate of the resource we just created. Then we set <code>label_settings.font_color</code> to the color we gave to the <code>_init()</code> function. That&rsquo;s also re reason we need to duplicate our label settings. If we just assigned them, then all the message labels would share the same label settings, and each time we set the color on one message labels all other message labels would change color as well.</p>
<p>The Messages are ready now, so we need a place to put them, meaning we will expand our node tree again. <strong>MessagesPanel</strong> still empty, so we add a new <code>ScrollContainer</code> as a child and call it <strong>MessageLog</strong>. Then, as we want to list the messages, we add a new <code>VBoxContainer</code> as a child of that and call it <strong>MessageList</strong>. For the <strong>MessageLog</strong> set <em>Horizontal Scroll</em> to <em>Disabled</em>, as we want messages that are too long to wrap instead of extending to the right. Set <em>Vertical Scroll</em> to <em>Never Show</em>, which will allow scrolling, and even controlling that UI element with the mouse wheel, but won&rsquo;t show the scroll bar, which would not really fit the rest of our aesthetic. For <strong>MessageList</strong> check <em>Layout</em> &gt; _ Container Sizing_ &gt; <em>Horizontal Expand</em>. We don&rsquo;t need vertical expand, as the messages will stretch the container. Also set the <strong>MessageList</strong> to be accessible via a unique name.</p>
<p>Now we can create the code for that. We want to be able to send a message from anywhere, without knowing too much about the message log system or where it is. To do that, we need the signal bus again. So open up <em>signal_bus.gd</em> and change id to the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Node</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">signal</span> player_died
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">signal</span> message_sent(text, color)
</span></span></code></pre></div><p>Now we have a <code>message_sent</code> signal which we will use in the code for the message log. So create a new script on the <strong>MessageLog</strong> node and save it at <em>res://src/GUI/message_log.gd</em>. Here is the top of the script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span>class_name MessageLog
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">ScrollContainer</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> last_message: Message <span style="color:#f92672">=</span> null
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> message_list: <span style="color:#a6e22e">VBoxContainer</span> <span style="color:#f92672">=</span> <span style="color:#f92672">$</span><span style="color:#e6db74">&#34;%MessageList&#34;</span>
</span></span></code></pre></div><p>Most messages can just be children, but for the count thing we established earlier to work we need a reference to the last message. Of course we also need one to the <strong>MessageList</strong> node.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> add_message(text: <span style="color:#a6e22e">String</span>, color: <span style="color:#a6e22e">Color</span>) <span style="color:#f92672">-&gt;</span> void:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (
</span></span><span style="display:flex;"><span>		last_message <span style="color:#f92672">!=</span> null <span style="color:#f92672">and</span>
</span></span><span style="display:flex;"><span>		last_message<span style="color:#f92672">.</span>plain_text <span style="color:#f92672">==</span> text
</span></span><span style="display:flex;"><span>	):
</span></span><span style="display:flex;"><span>		last_message<span style="color:#f92672">.</span>count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> message :<span style="color:#f92672">=</span> Message<span style="color:#f92672">.</span>new(text, color)
</span></span><span style="display:flex;"><span>		last_message <span style="color:#f92672">=</span> message
</span></span><span style="display:flex;"><span>		message_list<span style="color:#f92672">.</span>add_child(message)
</span></span><span style="display:flex;"><span>		await get_tree()<span style="color:#f92672">.</span>process_frame
</span></span><span style="display:flex;"><span>		ensure_control_visible(message)
</span></span></code></pre></div><p>This ist the function to add a message to our log. It first checks if, in case we do have a last message, that messages <code>plain_text</code> is identical to the text we want to log right now. If so, we simply increment the last message&rsquo;s count by one. Otherwise we create a new message, set that as the new last message and then add it to our list. If we would leave it at that you would only see the first few messages appear, but the scroll system would not follow the action as new messages appear. We can do that with <code>ensure_control_visible()</code>. However, that function needs to know the sizing of all the involved UI elements, which is only updated once per frame. So we have to use <code>await get_tree().process_frame</code> to wait a frame, and only call it after that.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> _ready() <span style="color:#f92672">-&gt;</span> void:
</span></span><span style="display:flex;"><span>	SignalBus<span style="color:#f92672">.</span>message_sent<span style="color:#f92672">.</span>connect(add_message)
</span></span></code></pre></div><p>Here in the <code>_ready()</code> function we connect that <code>message_sent</code> signal from the signal bus we created a moment ago to the <code>add_message()</code> function. The only thing that&rsquo;s left now is to emit that signal somewhere:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> send_message(text: <span style="color:#a6e22e">String</span>, color: <span style="color:#a6e22e">Color</span>) <span style="color:#f92672">-&gt;</span> void:
</span></span><span style="display:flex;"><span>	SignalBus<span style="color:#f92672">.</span>message_sent<span style="color:#f92672">.</span>emit(text, color)
</span></span></code></pre></div><p>Here we use a static function that wraps the emitting of the signal. You see how we will use this in a bit, and it is just more intuitive that way than to directly emit the signal from everywhere we want to create a message. Speaking of which, let&rsquo;s create a little welcome message. In <em>game.gd</em> add the following to the end of <code>_ready()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> _ready() <span style="color:#f92672">-&gt;</span> void:
</span></span><span style="display:flex;"><span>	player <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(null, Vector2i<span style="color:#f92672">.</span>ZERO, player_definition)
</span></span><span style="display:flex;"><span>	player_created<span style="color:#f92672">.</span>emit(player)
</span></span><span style="display:flex;"><span>	remove_child(camera)
</span></span><span style="display:flex;"><span>	player<span style="color:#f92672">.</span>add_child(camera)
</span></span><span style="display:flex;"><span>	map<span style="color:#f92672">.</span>generate(player)
</span></span><span style="display:flex;"><span>	map<span style="color:#f92672">.</span>update_fov(player<span style="color:#f92672">.</span>grid_position)
</span></span><span style="display:flex;"><span>	MessageLog<span style="color:#f92672">.</span>send_message<span style="color:#f92672">.</span>bind(
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;Hello and welcome, adventurer, to yet another dungeon!&#34;</span>,
</span></span><span style="display:flex;"><span>		GameColors<span style="color:#f92672">.</span>WELCOME_TEXT
</span></span><span style="display:flex;"><span>	)<span style="color:#f92672">.</span>call_deferred()
</span></span></code></pre></div><p>We have the same problem we had earlier with UI, which is that when we do stuff in the <code>_ready()</code> function the other nodes might not be ready yet themselves. To work around this we use <code>call_deferred()</code>, which makes our function call look a bit weird. We need to take the function object <code>send_message</code> from <code>MessageLog</code>, <code>bind()</code> the two arguments we want to pass it to it, and then use <code>call_deferred()</code>. That will make sure the function is only called later, when all the nodes are ready. This should work now, and when you start the project now, you should see the welcome message.</p>
<p>However, we still have a few messages that we need to move from console printing to the message log. One of those is in <em>melee_action.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> void:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> target: Entity <span style="color:#f92672">=</span> get_target_actor()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> target:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> damage: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> entity<span style="color:#f92672">.</span>fighter_component<span style="color:#f92672">.</span>power <span style="color:#f92672">-</span> target<span style="color:#f92672">.</span>fighter_component<span style="color:#f92672">.</span>defense
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> attack_color: <span style="color:#a6e22e">Color</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> entity <span style="color:#f92672">==</span> get_map_data()<span style="color:#f92672">.</span>player:
</span></span><span style="display:flex;"><span>		attack_color <span style="color:#f92672">=</span> GameColors<span style="color:#f92672">.</span>PLAYER_ATTACK
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>		attack_color <span style="color:#f92672">=</span> GameColors<span style="color:#f92672">.</span>ENEMY_ATTACK
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> attack_description: <span style="color:#a6e22e">String</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> attacks </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> [entity<span style="color:#f92672">.</span>get_entity_name(), target<span style="color:#f92672">.</span>get_entity_name()]
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> damage <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>		attack_description <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34; for </span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> hit points.&#34;</span> <span style="color:#f92672">%</span> damage
</span></span><span style="display:flex;"><span>		MessageLog<span style="color:#f92672">.</span>send_message(attack_description, attack_color)
</span></span><span style="display:flex;"><span>		target<span style="color:#f92672">.</span>fighter_component<span style="color:#f92672">.</span>hp <span style="color:#f92672">-=</span> damage
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>		attack_description <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34; but does no damage.&#34;</span>
</span></span><span style="display:flex;"><span>		MessageLog<span style="color:#f92672">.</span>send_message(attack_description, attack_color)
</span></span></code></pre></div><p>We rewrite the perform action a bit, by first adding an attack color, and deciding which attack color to use depending on whether the attack was made by the player or an enemy. We then replace the calls to <code>print()</code> with calls to <code>MessageLog.sent_message()</code>. Remember, we don&rsquo;t need to know a specific message log for this, as this is a static function. This static function will find our singleton signal bus, which will then emit the signal, to which the actual message log listens. The other place we need to modify is the <code>die()</code> function of <em>figher_component.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> die() <span style="color:#f92672">-&gt;</span> void:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> death_message: <span style="color:#a6e22e">String</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> death_message_color: <span style="color:#a6e22e">Color</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> get_map_data()<span style="color:#f92672">.</span>player <span style="color:#f92672">==</span> entity:
</span></span><span style="display:flex;"><span>		death_message <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;You died!&#34;</span>
</span></span><span style="display:flex;"><span>		death_message_color <span style="color:#f92672">=</span> GameColors<span style="color:#f92672">.</span>PLAYER_DIE
</span></span><span style="display:flex;"><span>		SignalBus<span style="color:#f92672">.</span>player_died<span style="color:#f92672">.</span>emit()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>		death_message <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> is dead!&#34;</span> <span style="color:#f92672">%</span> entity<span style="color:#f92672">.</span>get_entity_name()
</span></span><span style="display:flex;"><span>		death_message_color <span style="color:#f92672">=</span> GameColors<span style="color:#f92672">.</span>ENEMY_DIE
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	MessageLog<span style="color:#f92672">.</span>send_message(death_message, death_message_color)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span></code></pre></div><p>Again, we need to decide the color depending on who died. Of course we also need to decide the text according to that, but we already did that before. Then, instead of printing we call the message log again. And with that our message system works. When running the project you should see new messages appearing, and you can already scroll the log with the mouse wheel. It would be nice though to be able to control the log with the keyboard. To do that, we will need another input handler. However, we will use a little trick for which we need to expand <em>base_input_handler.gd</em> ab bit:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span>class_name BaseInputHandler
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Node</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> enter() <span style="color:#f92672">-&gt;</span> void:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> exit() <span style="color:#f92672">-&gt;</span> void:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> get_action(player: Entity) <span style="color:#f92672">-&gt;</span> Action:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> null
</span></span></code></pre></div><p>We get this closer to an actual state machine. We add a function that is called when we enter an input handler, and another that is called when it is exited. This will be called in <em>input_handler.gd</em> in the <code>transition_to()</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> transition_to(input_handler: InputHandlers) <span style="color:#f92672">-&gt;</span> void:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> current_input_handler <span style="color:#f92672">!=</span> null:
</span></span><span style="display:flex;"><span>		current_input_handler<span style="color:#f92672">.</span>exit()
</span></span><span style="display:flex;"><span>	current_input_handler <span style="color:#f92672">=</span> input_handler_nodes[input_handler]
</span></span><span style="display:flex;"><span>	current_input_handler<span style="color:#f92672">.</span>enter()
</span></span></code></pre></div><p>We call the <code>exit()</code> function before we change the input handler, then call the <code>enter()</code> function once <code>current_input_handler</code> points to the new input handler. We also have a check if the <code>current_input_handler</code> is <code>null</code> for the very first transition, when we don&rsquo;t have an input handler yet.</p>
<p>Before we create a new input handler we will expand our input map a bit. Go into <em>Project</em> &gt; <em>Project Settings</em> &gt; <em>Input Map</em> again. First, we modify our quit action a bit. Most users might expect the escape key to take them back to the previous menu, not straight up quit the game. So remove the escape key from <em>quit</em>, then add the <em>Q</em> key to it. However, before confirming, check <em>Ctrl</em> in the <em>Additional Options</em>. This will mean that <em>Ctrl+Q</em> will be our quitting shortcut. Add a new action called <em>view_history</em>, and add the <em>V</em> key to that. Then create another action called <em>ui_back</em> and add the escape key to that action.</p>
<p>Now we can create a new input handler. Create a new <code>Node</code> child under <strong>InputHandler</strong> and call it <strong>HistoryViewer</strong>. Then, create a new script on that node extending <code>BaseInputHandler</code> at <em>res://src/Game/EventHandlers/history_viewer_input_handler.gd</em>. Here is the top of that script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> BaseInputHandler
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> scroll_step <span style="color:#f92672">=</span> <span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@</span>export_node_path(<span style="color:#e6db74">&#34;PanelContainer&#34;</span>) <span style="color:#66d9ef">var</span> messages_panel_path
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@</span>export_node_path(<span style="color:#e6db74">&#34;MessageLog&#34;</span>) <span style="color:#66d9ef">var</span> message_log_path
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> message_panel: <span style="color:#a6e22e">PanelContainer</span> <span style="color:#f92672">=</span> get_node(messages_panel_path)
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> message_log: MessageLog <span style="color:#f92672">=</span> get_node(message_log_path)
</span></span></code></pre></div><p>First we create a constant that sets how many pixels we will scroll with one step. Then we export a few variables. We need to access some other nodes in the tree. To do that we first export node paths, which we can then set via the editor. After that we get the actual nodes as <code>@onready</code> variables using <code>get_node</code> and the paths we will set.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> enter() <span style="color:#f92672">-&gt;</span> void:
</span></span><span style="display:flex;"><span>	message_panel<span style="color:#f92672">.</span>self_modulate <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>RED
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> exit() <span style="color:#f92672">-&gt;</span> void:
</span></span><span style="display:flex;"><span>	message_panel<span style="color:#f92672">.</span>self_modulate <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>WHITE
</span></span></code></pre></div><p>Next we use the <code>enter()</code> and <code>exit()</code> functions to toggle the <code>self_modulate</code> of the panel. When we enter this input handler / state, the panel border of the message log will turn red, and once we return to another state, it will turn white again. Now, for the actual input handling:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> get_action(player: Entity) <span style="color:#f92672">-&gt;</span> Action:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> action: Action
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;move_up&#34;</span>):
</span></span><span style="display:flex;"><span>		message_log<span style="color:#f92672">.</span>scroll_vertical <span style="color:#f92672">-=</span> scroll_step
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">elif</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;move_down&#34;</span>):
</span></span><span style="display:flex;"><span>		message_log<span style="color:#f92672">.</span>scroll_vertical <span style="color:#f92672">+=</span> scroll_step
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">elif</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;move_left&#34;</span>):
</span></span><span style="display:flex;"><span>		message_log<span style="color:#f92672">.</span>scroll_vertical <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">elif</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;move_right&#34;</span>):
</span></span><span style="display:flex;"><span>		message_log<span style="color:#f92672">.</span>scroll_vertical <span style="color:#f92672">=</span> message_log<span style="color:#f92672">.</span>get_v_scroll_bar()<span style="color:#f92672">.</span>max_value
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;view_history&#34;</span>) <span style="color:#f92672">or</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;ui_back&#34;</span>):
</span></span><span style="display:flex;"><span>		get_parent()<span style="color:#f92672">.</span>transition_to(InputHandler<span style="color:#f92672">.</span>InputHandlers<span style="color:#f92672">.</span>MAIN_GAME)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;quit&#34;</span>):
</span></span><span style="display:flex;"><span>		get_tree()<span style="color:#f92672">.</span>quit()
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> action
</span></span></code></pre></div><p>First, we use the action keys to move the log around. With the up and down movement keys we go down or up our <code>scroll_step</code>, and with the left and right movement keys we go to the beginning (<code>0</code>) or the end (<code>message_log.get_v_scroll_bar().max_value</code>). Then we check for the <em>view_history</em> action or the <em>ui_back</em> action, which triggers a input handler transition back to the main game input handler. Lastly, we check for the <em>quit</em> action, and if we encounter that we do quit the game.</p>
<p>Now, after saving the script, select the <strong>HistoryViewerInputHandler</strong> node in the editor. In the inspector click on the slot next to <em>Messages Panel Path</em> and in the window that pops up select the <strong>MessagesPanel</strong>. Then do the same with <em>Message Log Path</em> and <strong>MessageLog</strong>. We still need to integrate this input handler with the rest of the game. Let&rsquo;s start with <em>input_handler.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> InputHandlers {MAIN_GAME, GAME_OVER, HISTORY_VIEWER}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> start_input_handler: InputHandlers
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> input_handler_nodes :<span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>	InputHandlers<span style="color:#f92672">.</span>MAIN_GAME: <span style="color:#f92672">$</span>MainGameInputHandler,
</span></span><span style="display:flex;"><span>	InputHandlers<span style="color:#f92672">.</span>GAME_OVER: <span style="color:#f92672">$</span>GameOverInputHandler,
</span></span><span style="display:flex;"><span>	InputHandlers<span style="color:#f92672">.</span>HISTORY_VIEWER: <span style="color:#f92672">$</span>HistoryViewerInputHandler,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We add a new entry to the enum, and a reference to the dictionary. Then, move to <em>main_game_input_handler.gd</em>. Modify <code>get_action()</code> as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> get_action(player: Entity) <span style="color:#f92672">-&gt;</span> Action:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> action: Action <span style="color:#f92672">=</span> null
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> direction <span style="color:#f92672">in</span> directions:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(direction):
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> offset: Vector2i <span style="color:#f92672">=</span> directions[direction]
</span></span><span style="display:flex;"><span>			action <span style="color:#f92672">=</span> BumpAction<span style="color:#f92672">.</span>new(player, offset<span style="color:#f92672">.</span>x, offset<span style="color:#f92672">.</span>y)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;wait&#34;</span>):
</span></span><span style="display:flex;"><span>		action <span style="color:#f92672">=</span> WaitAction<span style="color:#f92672">.</span>new(player)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;view_history&#34;</span>):
</span></span><span style="display:flex;"><span>		get_parent()<span style="color:#f92672">.</span>transition_to(InputHandler<span style="color:#f92672">.</span>InputHandlers<span style="color:#f92672">.</span>HISTORY_VIEWER)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;quit&#34;</span>) <span style="color:#f92672">or</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;ui_back&#34;</span>):
</span></span><span style="display:flex;"><span>		action <span style="color:#f92672">=</span> EscapeAction<span style="color:#f92672">.</span>new(player)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> action
</span></span></code></pre></div><p>Here we add a check for the <em>view_history</em> action and have it trigger a transition to our new history viewer input handler. With all that in place you can now run the project, and once you have a few messages in the log you can press <em>v</em> to control the log.</p>
<p>We will have one last addition to our interface. Right now we can hit an orc to let the message log tell us that it&rsquo;s an orc, and with only two types of enemies we can easily remember what&rsquo;s what. But it would be nice if we had a way to identify entities on the screen. We will implement a simple label that shows a list of the entities under the mouse cursor.</p>
<p>Let&rsquo;s start with the part that gets the information. Create a new <code>Node2D</code> as child of <strong>Map</strong> and call it <strong>MouseoverChecker</strong>. Create a new script on that node at <em>res://src/GUI/mouseover_checker.gd</em>. Here&rsquo;s the top of that script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Node2D</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">signal</span> entities_focussed(entity_list)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> _mouse_tile :<span style="color:#f92672">=</span> Vector2i(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> map: Map <span style="color:#f92672">=</span> get_parent()
</span></span></code></pre></div><p>We have the <code>entities_focussed</code> signal we will use to relay the information to the UI later. We also have a variable that stores the tile we are currently on, so we only need to recompute things when we change tile we hover over. Also, we get a reference to the map that&rsquo;s the parent of this node. Next we have <code>_untitled_input()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> _unhandled_input(event: <span style="color:#a6e22e">InputEvent</span>) <span style="color:#f92672">-&gt;</span> void:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> event is <span style="color:#a6e22e">InputEventMouseMotion</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> mouse_position: <span style="color:#a6e22e">Vector2</span> <span style="color:#f92672">=</span> get_local_mouse_position()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> tile_position: Vector2i <span style="color:#f92672">=</span> Grid<span style="color:#f92672">.</span>world_to_grid(mouse_position)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> _mouse_tile <span style="color:#f92672">!=</span> tile_position:
</span></span><span style="display:flex;"><span>			_mouse_tile <span style="color:#f92672">=</span> tile_position
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> entity_names <span style="color:#f92672">=</span> get_names_at_location(tile_position)
</span></span><span style="display:flex;"><span>			entities_focussed<span style="color:#f92672">.</span>emit(entity_names)
</span></span></code></pre></div><p><code>_unhandled_input()</code> will trigger whenever there is an input event that hasn&rsquo;t been handled yet. If you move the mouse over the user interface the <code>Control</code> nodes will set the input as handled, meaning our mouse won&rsquo;t look <em>through</em> those panels. Then, inside the function, we first make sure the event is an <code>InputEventMouseMotion</code>, so the following code will only execute in response to mouse motions. Then we get the current mouse position as a local position, which takes the camera into account. We can use this to calculate the tile position of the tile the mouse is currently over. We then further check if that tile is another tile then the mouse was previously on, i.e., if we have changed the hovered tile. If so, we update the stored mouse position, and then get the entity names from a function we&rsquo;ll shortly write, and then emit that with that signal. Here&rsquo;s that entity name function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> get_names_at_location(grid_position: Vector2i) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">String</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> entity_names :<span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> map_data: MapData <span style="color:#f92672">=</span> map<span style="color:#f92672">.</span>map_data
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> tile: Tile <span style="color:#f92672">=</span> map_data<span style="color:#f92672">.</span>get_tile(grid_position)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> tile <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> tile<span style="color:#f92672">.</span>is_in_view:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> entity_names
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> entities_at_location: <span style="color:#a6e22e">Array</span>[Entity] <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> entity <span style="color:#f92672">in</span> map_data<span style="color:#f92672">.</span>entities:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> entity<span style="color:#f92672">.</span>grid_position <span style="color:#f92672">==</span> grid_position:
</span></span><span style="display:flex;"><span>			entities_at_location<span style="color:#f92672">.</span>append(entity)
</span></span><span style="display:flex;"><span>	entities_at_location<span style="color:#f92672">.</span>sort_custom(<span style="color:#66d9ef">func</span>(a, b): <span style="color:#66d9ef">return</span> a<span style="color:#f92672">.</span>z_index <span style="color:#f92672">&gt;</span> b<span style="color:#f92672">.</span>z_index)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> entities_at_location<span style="color:#f92672">.</span>is_empty():
</span></span><span style="display:flex;"><span>		entity_names <span style="color:#f92672">=</span> entities_at_location[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>get_entity_name()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, entities_at_location<span style="color:#f92672">.</span>size()):
</span></span><span style="display:flex;"><span>			entity_names <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;, </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> entities_at_location[i]<span style="color:#f92672">.</span>get_entity_name()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> entity_names
</span></span></code></pre></div><p>Here, we first need the <code>map_data</code>. We use it to check if the tile we&rsquo;re hovering is in view, as we don&rsquo;t want the mouseover to reveal entities we can&rsquo;t actually see. If we can&rsquo;t see the tile, we return early with an empty name list string. Otherwise we start building the list. We go through all the entities and put all the ones that are on that position in an array. Then we use <code>sort_custom()</code> with an anonymous function that sorts the entities in that list by their <code>z_index</code>. This <code>z_index</code> corresponds to the entity type, and this way we will list more important things, like alive entities, first in the list. Once we have that sorted list we assembly it into a string. We use the first entity name separately, so in the loop that goes through the remaining entities we can prepend a comma.</p>
<p>We have the system for getting what entities are under the mouse cursor, now we need a way to display it. We will just put a label below the hp bar. Create a new <code>Label</code> node as a child of <strong>StatsPanel/VBoxContainer</strong> and call it <strong>MouseoverLabel</strong>. Create a new <code>LabelSettings</code> resource and fill it with a font again (I again used &ldquo;<em>Kenney Pixel.ttf</em>&rdquo;). Also under <em>Layout</em> &gt; <em>Container Sizing</em> &gt; <em>Vertical</em> check <em>Expand</em> and select the option <em>Shrink End</em>. That way the label will sit at the bottom of that panel. As a last step we will use the signal from <strong>MouseoverChecker</strong> to change the text of <strong>MouseoverLabel</strong>. Luckily that signal has a <code>String</code> argument, meaning we can directly use signals for that. Click <strong>MouseoverChecker</strong> in the scene tree, and switch from the <em>Inspector</em> to the <em>Node</em> tab. In the <em>Signals</em> sub-tab you should see the <code>entities_focussed</code> signal. Double click that to get to the connection dialog. You need to activate the <em>Advanced</em> options at the bottom left to be able to select <strong>MouseoverLabel</strong>. Once you did that and <strong>MouseoverLabel</strong> is selected, click the <em>Pick</em> button. Deactivate <em>Script Methods Only</em> and now you&rsquo;re presented with a list of all the builtin functions of the <code>Label</code> class, including <code>set_text()</code>, which we will select. Confirm all the dialogs and the systems are hooked up.</p>
<p>Now our <strong>MouseoverChecker</strong> will generate the signal whenever we hover over a new tile, and that signal will directly trigger a change of the text of our <strong>MouseoverLabel</strong>. You can now run the project and try out the mouseover system. And that concludes this part concerning the interface. If you want to look at the code in its entirety, you can do so in the github repository: <a href="https://github.com/SelinaDev/Godot-Roguelike-Tutorial">https://github.com/SelinaDev/Godot-Roguelike-Tutorial</a></p>
<p>Find the next part of the tutorial here: <a href="https://selinadev.github.io/12-rogueliketutorial-08/">https://selinadev.github.io/12-rogueliketutorial-08/</a></p>




      </main>
  </div>
  </body>
</html>
