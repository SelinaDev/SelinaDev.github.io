<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="generator" content="Hugo 0.92.2" />
  <link rel="canonical" href="https://selinadev.github.io/14-rogueliketutorial-10/">

  
    
    <meta name="description" content="Part 10: Saving and Loading Welcome back to the roguelike tutorial series. This tutorial will continue from where the last one left off. You can find the previous tutorial here: https://selinadev.github.io/13-rogueliketutorial-09/
It’s been a while since the last tutorial, but luckily we can jump right back in. And this time we’ll make it so that our players may do the same. Up until now if a player wanted to pause and return to the game later they would have to keep the game open in tha background.">
  

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#000000">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" type="text/css" href="/css/paper.css">

  
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css">
  
  
    
  

  
  
  <title>Yet Another Roguelike Tutorial, Part 10 | SelinaDev</title>
</head>

  <body>
    <div class="container paper">
      <nav class="border split-nav">
  <div class="nav-brand">
    <h3><a href="/">SelinaDev</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
    <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
      
        <li><a href="/">Blog</a></li>
      
        <li><a href="/tags/">Tags</a></li>
      
        <li><a href="/about/">About</a></li>
      
      </ul>
    </div>
  </div>
</nav>
      <main>
        

<h1 class="post-title">Yet Another Roguelike Tutorial, Part 10</h1>


<strong>Publish date: </strong>Nov 12, 2023
<br>

  <strong>Tags: </strong>
  
    <a href="/tags/godot4">godot4</a>
  
    <a href="/tags/tutorial">tutorial</a>
  
    <a href="/tags/roguelike">roguelike</a>
  



  



<h1 id="part-10-saving-and-loading">Part 10: Saving and Loading</h1>
<p>Welcome back to the roguelike tutorial series. This tutorial will continue from where the last one left off. You can find the previous tutorial here: <a href="https://selinadev.github.io/13-rogueliketutorial-09/">https://selinadev.github.io/13-rogueliketutorial-09/</a></p>
<p>It&rsquo;s been a while since the last tutorial, but luckily we can jump right back in. And this time we&rsquo;ll make it so that our players may do the same. Up until now if a player wanted to pause and return to the game later they would have to keep the game open in tha background. However, after this tutorial part they&rsquo;ll be able to save the game and close it and load the game again when they open the application again. Granted, longer playsessions aren&rsquo;t that interesting yet, as once the player has explored all of the dungeon there isn&rsquo;t anything more to do, but we&rsquo;ll tackle that problem next time.</p>
<p>Before we tackle that, let&rsquo;s quickly fix a bug that has crept into our inventory handling. In <em>main_game_input_handler.gd</em> we need to change <code>get_item()</code> a bit.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_item(window_title: <span style="color:#a6e22e">String</span>, inventory: InventoryComponent, evaluate_for_next_step: <span style="color:#a6e22e">bool</span> <span style="color:#f92672">=</span> false) <span style="color:#f92672">-&gt;</span> Entity:
	<span style="color:#66d9ef">if</span> inventory<span style="color:#f92672">.</span>items<span style="color:#f92672">.</span>is_empty():
		await get_tree()<span style="color:#f92672">.</span>physics_frame
		MessageLog<span style="color:#f92672">.</span>send_message(<span style="color:#e6db74">&#34;No items in inventory.&#34;</span>, GameColors<span style="color:#f92672">.</span>IMPOSSIBLE)
		<span style="color:#66d9ef">return</span> null
	<span style="color:#66d9ef">var</span> inventory_menu: InventoryMenu <span style="color:#f92672">=</span> inventory_menu_scene<span style="color:#f92672">.</span>instantiate()
	add_child(inventory_menu)
	inventory_menu<span style="color:#f92672">.</span>build(window_title, inventory)
	get_parent()<span style="color:#f92672">.</span>transition_to(InputHandler<span style="color:#f92672">.</span>InputHandlers<span style="color:#f92672">.</span>DUMMY)
	<span style="color:#66d9ef">var</span> selected_item: Entity <span style="color:#f92672">=</span> await inventory_menu<span style="color:#f92672">.</span>item_selected
	<span style="color:#66d9ef">var</span> has_item: <span style="color:#a6e22e">bool</span> <span style="color:#f92672">=</span> selected_item <span style="color:#f92672">!=</span> null
	<span style="color:#66d9ef">var</span> needs_targeting: <span style="color:#a6e22e">bool</span> <span style="color:#f92672">=</span> has_item <span style="color:#f92672">and</span> selected_item<span style="color:#f92672">.</span>consumable_component <span style="color:#f92672">and</span> selected_item<span style="color:#f92672">.</span>consumable_component<span style="color:#f92672">.</span>get_targeting_radius() <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> evaluate_for_next_step <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> has_item <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> needs_targeting:
		await get_tree()<span style="color:#f92672">.</span>physics_frame
		get_parent()<span style="color:#f92672">.</span>call_deferred(<span style="color:#e6db74">&#34;transition_to&#34;</span>, InputHandler<span style="color:#f92672">.</span>InputHandlers<span style="color:#f92672">.</span>MAIN_GAME)
	<span style="color:#66d9ef">return</span> selected_item
</code></pre></div><p>We added a block at the start, that will prevent the inventory from opening if it&rsquo;s empty, which will prevent the player from getting stuck in the dummy input handler if the inventory is empty. Also we had to modify the condition for the if statement a bit (including a new variable to make things more readable). This prevents a bug that would stop us from dropping items.</p>
<p>Here&rsquo;s what we&rsquo;ll be doing this time. First, the player will need a way to choose wheter they want to start a new run or load an ongoin one when they start a session. To do that we&rsquo;ll start by implementing a very simple main menu. Once we have that we can look into how we want to save and later restore the game state. The save format I&rsquo;ll show you is far from optimal, but I&rsquo;ll try my best to explain why that is the easiest way to implement it and what you may would want to do differently.</p>
<p>So, let us start with creating the main menu. We could just use a blank background, but I went with the same background the original tutorial uses. You can find it in the github repository under <em>part_10/assets/images/menu_background.png</em>, or download it here:</p>








  


<div class="card row flex-center" style="">
  <a href="/14-rogueliketutorial-10/menu_background.png" class="img-link">
    <img src="/14-rogueliketutorial-10/menu_background_hud755ba02d0ac3131609b66e0be5dc4e8_10619_900x0_resize_box_3.png">
  </a>
  <div class="card-body">
  
    <h4 class="card-title">Background for our menu</h4>
  
  
  
    <p class="card-text">This image should be saved under <em>part_10/assets/images/menu_background.png</em></p>
  
  </div>
</div>
<p>Now, create a new scene with a <code>Control</code> node at its root. Call that node <strong>MainMenu</strong> and save the scene under <em>res://src/GUI/MainMenu/main_menu.tscn</em>. Add a <code>TextureRect</code> node to it and name it <strong>Background</strong>, as well as a <code>VBoxContainer</code>. Add two children to the <strong>VBoxContainer</strong>: a <code>CenterContainer</code> and a <code>Label</code>. Add another <code>VBoxcontainer</code> as child of the <strong>CenterContainer</strong>. This last <strong>VBoxContainer</strong> will get three children: a <code>Label</code> and three <code>Button</code> nodes. Name the buttons <strong>NewButton</strong>, <strong>LoadButton</strong>, and <strong>QuitButton</strong>. Now let&rsquo;s go over configuring this scene.</p>
<p>Set the root <strong>MainMenu</strong> node&rsquo;s <em>Anchors Preset</em> to <em>Full Rect</em>.</p>
<p>For the <strong>Background</strong> node first drag our new image from <em>res://assets/images/menu_background.png</em> into the <em>Texture</em> property. Set the <em>Stretch Mode</em> to <em>Keep Aspect Covered</em>. Other than the python tutorial this game will allow changing the game&rsquo;s resolution, and this setting should ensure that the image won&rsquo;t be stretched unnaturally while still covering the whole window. Speaking of which, we also need to set the <em>Full Rect</em> <em>Anchor Preset</em> on this node to have it cover the viewport.</p>
<p>We do the same with the outer <strong>VBoxContainer</strong>, setting it to <em>Full Rect</em> as well.</p>
<p>We want the <strong>CenterContainer</strong> to take up most of the screen, but have a little text line at the bottom. To do that we check <em>Expand</em> under <em>Layout</em> &gt; <em>Container Sizing</em> &gt; <em>Vertical</em>.</p>
<p>No changes for the inner <strong>VBoxContainer</strong>. The (inner) <strong>Label</strong> will again get <em>Label Settings</em> defined. We give it <em>res://assets/fonts/kenney_kenney-fonts/Fonts/Kenney Pixel.ttf</em> as <em>Font</em>, set the <em>Size</em> to 32, and as this should stand out as the title we give it a bright yellow <em>Color</em> (#ffff00). We also give it an outline of <em>Size</em> 2 with black <em>Color</em> (so it will always stand out event against the bright parts of the background). As text we set &ldquo;DUNGEON OF THE MAD GOD(OT)&rdquo;.</p>
<p>The three buttons will all be configured basically the same, so I will go through <strong>NewButto</strong> and then only point out the differences for the other two buttons. Set the <em>Text</em> to &ldquo;[ N ] Play a new game&rdquo;. Down in the <em>Theme Overrides</em> we change a few things so these buttons behave more or less like the buttons we already have. Tick the checkbox next to <em>Colors</em> &gt; <em>Font Outline Color</em>. Change <em>Constants</em> &gt; <em>Outline</em> to 2. Change <em>Fonts</em> &gt; <em>Font</em> to the same font as for the label above. Set <em>Font Sizes</em> &gt; <em>Font Size</em> to 32. Under <em>Styles</em> we create (or better copy) the same style boxes as for our other buttons. A <code>StyleBoxEmpty</code> for <em>Normal</em>, <em>Hover</em>, and <em>Disabled</em>, and a <code>StyleBoxFlat</code> in which we do not <em>Draw Center</em>, but have a white border of 1 pixel on all edges. We also want to be able to trigger our buttons via keyboard commands, wo we configure shortcuts again. Back up under <em>Shortcut</em> disable <em>Shortcut Feedback</em>, then create a new <code>Shortcut</code> in the <em>Shortcut</em> slot. Increase the size of that shortcut&rsquo;s <em>Events</em> array to 1. In the slot that appeared in the array add a new <code>InputEventKey</code>. Click on the <em>Configure</em> button and press the &lsquo;n&rsquo; key on your keyboard. That should configure everything properly.</p>
<p>You can configure the other two buttons separately, but it&rsquo;s probably easiest to duplicate and rename the <strong>NewButton</strong> after you have fully configured it. Now, for the <strong>LoadButton</strong> set the <em>Text</em> to &ldquo;[ C ] Continue last game&rdquo;. This button also has a different shortcut, so we need to configure a different key press. Note that if you did duplicate the <strong>NewButton</strong> to create this button it will hold the same shortcut resource. So changing the key here would also change it for the other button. So make sure you click <em>Make Unique</em> both on the Shortcut resource and the input event resource before changing the shortcut. For the <strong>LoadButton</strong> we will use the &lsquo;c&rsquo; key as shortcut, as indicated in the text. The <strong>QuitButton</strong> will get the <em>Text</em> &ldquo;[ Q ] Quit and the shortcut key &lsquo;q&rsquo;.</p>
<p>We&rsquo;ll later need two of the buttons in code, so we will configure <strong>NewButton</strong> and <strong>LoadButton</strong> to <em>Access as Unique Name</em> (by right clicking them in the scene tree).</p>
<p>Lastly, the outermost <strong>Label</strong> well again create new <em>LabelSettings</em> (at this point a common theme resource would save us a lot of work, but I hadn&rsquo;t thought of that in the beginning and now it would mean a lot of refactoring). We set it to the same <em>Font</em> again, with <em>Size</em> 16 and the same yellow <em>Color</em> as the other label. We also give it a black <em>Outline</em> of 2 pixels. Next, we set the <em>Horizontal Alignment</em> to <em>Center</em>. I wrote &ldquo;By Selina&rdquo; into the <em>Text</em> property, but feel free to change that to your name.</p>
<p>Now our main menu is set up, and we can move to coding its behavior. We&rsquo;ll see in a moment why this scene actually does very little on its own. Create a new script on <strong>MainMenu</strong> and save it under <em>res://src/GUI/MainMenu/main_menu.gd</em>. Here&rsquo;s the top of the script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name MainMenu
<span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Control</span>

<span style="color:#66d9ef">signal</span> game_requested(load)

<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> first_button: <span style="color:#a6e22e">Button</span> <span style="color:#f92672">=</span> <span style="color:#f92672">$</span><span style="color:#e6db74">&#34;%NewButton&#34;</span>
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> load_button: <span style="color:#a6e22e">Button</span> <span style="color:#f92672">=</span> <span style="color:#f92672">$</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%Lo</span><span style="color:#e6db74">adButton&#34;</span>
</code></pre></div><p>As mentioned the main menu won&rsquo;t load the game on its own, but rather request it. We do this via a signal, which will have a boolean value that tells us whether the game should attempt to load a game, or, if not, create a new game. We also get references to the two buttons we specified. Next the ready function.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _ready():
	first_button<span style="color:#f92672">.</span>grab_focus()
	<span style="color:#66d9ef">var</span> has_save_file: <span style="color:#a6e22e">bool</span> <span style="color:#f92672">=</span> FileAccess<span style="color:#f92672">.</span>file_exists(<span style="color:#e6db74">&#34;user://save_game.dat&#34;</span>)
	load_button<span style="color:#f92672">.</span>disabled <span style="color:#f92672">=</span> <span style="color:#f92672">not</span> has_save_file
</code></pre></div><p>We use the first button, in our case the new game button, to grab focus. That way it will be preselected, which will make navigating the menu via the keyboard easier. We then check if a file called <em>save_game.dat</em> exists in the user directory. If it does not, we know that we don&rsquo;t have a saved game and disable the <strong>LoadButton</strong>. Next we&rsquo;ll create a function for each of the buttons:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _on_new_button_pressed():
	game_requested<span style="color:#f92672">.</span>emit(false)


<span style="color:#66d9ef">func</span> _on_load_button_pressed():
	game_requested<span style="color:#f92672">.</span>emit(true)


<span style="color:#66d9ef">func</span> _on_quit_button_pressed():
	get_tree()<span style="color:#f92672">.</span>quit()
</code></pre></div><p>If the <strong>NewButton</strong> is pressed we emit signal mentioned above with <code>false</code>, indicating we don&rsquo;t want to try loading a game. If the <strong>LoadButton</strong> was pressed we emit the same signal but with <code>true</code>, which will tell our other code we want to try to load a saved game. Lastly, if the <strong>QuitButton</strong> was pressed we directly quit the game. All that&rsquo;s left to do now is to hook up these signals. In the editor select <strong>NewButton</strong> and switch from the <em>Inspector</em> tab to the <em>Node</em> tab. Connect the <code>pressed()</code> signal (using the default values). Do the same with the <strong>LoadButton</strong> and the <strong>QuitButton</strong>.</p>
<p>With the code in place we can look at how to use this menu scene. The menu scene itself merely signals requests for changing to the game. The reason for that is that both the <strong>NewButton</strong> and the <strong>LoadButton</strong> should switch to the same scene. However, how that scene should act differs based on whether we want to start a new game or load an existing one. The <code>change_scene()</code> function in Godot only allows us to switch the scene, we can&rsquo;t configure behavior or send any data to the new scene. There are several ways to handle this issue. One simple way would be to have an autoload that stores such information for us. However, the method I prefer is to use a state machine. We will implement this as a new root node for everything. Then, when we switch scenes we don&rsquo;t switch to a completely new root node (as <code>change_scene()</code> would do) but have the <strong>GameManager</strong> root node (which we will shortly create) free its child and instantiate the new scene in its place. The <strong>GameManager</strong> can then run specific code depending on how the scene change was requested. Let&rsquo;s start implementing that.</p>
<p>Create a new scene with a <code>Node</code> at its root and call it <strong>GameManager</strong>. Save the scene at <em>res://src/Game/game_manager.tscn</em>. The reason we need a scene with just one node is that this scene will be our new start scene. Go into <em>Project</em> &gt; <em>Project Settings</em> and navigate to <em>Application</em> &gt; <em>Run</em>. There you will find the option <em>Main Scene</em>. Click the folder icon to the far right and select our new <em>res://src/Game/game_manager.tscn</em> as the new <em>Main Scene</em>. If you were to run the project now you&rsquo;d get a black screen. The <strong>GameManager</strong> node &ldquo;works&rdquo;, it simply doesn&rsquo;t do anything at the moment. So bach in the scene create a new script on <strong>GameManager</strong> and save it at <em>res://src/Game/game_manager.gd</em>.</p>
<p>Here&rsquo;s the top of the script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Node</span>

<span style="color:#66d9ef">const</span> game_scene: <span style="color:#a6e22e">PackedScene</span> <span style="color:#f92672">=</span> preload(<span style="color:#e6db74">&#34;res://src/Game/game.tscn&#34;</span>)
<span style="color:#66d9ef">const</span> main_menu_scene: <span style="color:#a6e22e">PackedScene</span> <span style="color:#f92672">=</span> preload(<span style="color:#e6db74">&#34;res://src/GUI/MainMenu/main_menu.tscn&#34;</span>)

<span style="color:#66d9ef">var</span> current_child: <span style="color:#a6e22e">Node</span>
</code></pre></div><p>We have variables that hold the two packed scenes we can switch to, and a variable that tracks the current child (the game manager should only ever have one child, but I still find it cleaner this way). We use the latter quite a lot in the code for switching the scene:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> switch_to_scene(scene: <span style="color:#a6e22e">PackedScene</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Node</span>:
	<span style="color:#66d9ef">if</span> current_child <span style="color:#f92672">!=</span> null:
		current_child<span style="color:#f92672">.</span>queue_free()
	current_child <span style="color:#f92672">=</span> scene<span style="color:#f92672">.</span>instantiate()
	add_child(current_child)
	<span style="color:#66d9ef">return</span> current_child
</code></pre></div><p>If we currently have a scene in our child node, we call <code>queue_free()</code> on it. Then, we instantiate the new scene and store it in the <code>current_child</code> variable, which we then actually add as a child. Lastly, we might want to do specific stuff with the instantiated scene in the calling function, so we return that scene. Here&rsquo;s how this function fits in with the function that loads the main menu:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> load_main_menu() <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> main_menu: MainMenu <span style="color:#f92672">=</span> switch_to_scene(main_menu_scene)
	main_menu<span style="color:#f92672">.</span>game_requested<span style="color:#f92672">.</span>connect(_on_game_requested)
</code></pre></div><p>We first create a new main menu in place of the existing scene. After that we connect its <code>game_requested</code> signal to the <code>_on_game_requested()</code> function. Here&rsquo;s a temporary implementation of that function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _on_game_requested(try_load: <span style="color:#a6e22e">bool</span>) <span style="color:#f92672">-&gt;</span> void:
	switch_to_scene(game_scene)
</code></pre></div><p>Two issues are remaining here. The first issue is that we don&rsquo;t have an initial state for this system. This is remedied with a simple <code>_ready()</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _ready():
	load_main_menu()
</code></pre></div><p>We simply start the game off by loading the main menu. The second issue is that right now the actual game is a terminal state. We have no way of getting back to the main menu. Ok, the third issue might be that we don&rsquo;t handle all the <em>new game</em>/<em>load game</em> stuff, but that has to wait till after we actually implemented saving and loading. For now we have to refactor the existing game a bit, to better integrate it with our game manager system.</p>
<p>To do that we want two tings in our game scene. First is a top level script our game manager can interact with. We originally had the <strong>Game</strong> node, but since we have restructured our <em>game.tscn</em> to accomodate the GUI, we don&rsquo;t have a script in the root node. So now we&rsquo;ll give the root node a small bit of functionality, just so it can relay things to the <strong>Game</strong> node. The second thing we want is a way to communicate back to the game manager, for which we&rsquo;ll use a signal again. That signal will be called from our escape actions. Setting those up to communicate with the game scene root node would be a bit convoluted, so we&rsquo;ll make use of our SignalBus once more. Add one more signal to <em>signal_bus.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Node</span>

<span style="color:#66d9ef">signal</span> player_died
<span style="color:#66d9ef">signal</span> message_sent(text, color)
<span style="color:#66d9ef">signal</span> escape_requested
</code></pre></div><p>We&rsquo;ll use <code>escape_requested</code> to signal that we want to go out of the game, which now will mean going into the main menu instead of quitting the game altogether. Next, <em>game.tscn</em> create a new script on the <strong>InterfaceRoot</strong> node. Save it at <em>res://src/Game/game_root.gd</em> (as this is not only the root node of the interface, but of the whole game scene). We&rsquo;ll want to refer to the <strong>Game</strong> node, so before jumping into the script make sure to enable <em>Access as Unique Name</em> on the <strong>Game</strong> node. Then we can start with the script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name GameRoot
<span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Control</span>

<span style="color:#66d9ef">signal</span> main_menu_requested

<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> game: Game <span style="color:#f92672">=</span> <span style="color:#f92672">$</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%G</span><span style="color:#e6db74">ame&#34;</span>


<span style="color:#66d9ef">func</span> _ready() <span style="color:#f92672">-&gt;</span> void:
	SignalBus<span style="color:#f92672">.</span>escape_requested<span style="color:#f92672">.</span>connect(_on_escape_requested)


<span style="color:#66d9ef">func</span> _on_escape_requested() <span style="color:#f92672">-&gt;</span> void:
	main_menu_requested<span style="color:#f92672">.</span>emit()
</code></pre></div><p>We have a signal that will be emitted from this node to the game manager. Also here&rsquo;s the reference to the <strong>Game</strong> node. We&rsquo;ll use it in a bit when we handle new games and later loading. In the <code>_ready()</code> function we connect our new <code>escape_requested</code> from the <strong>SignalBus</strong> to a <code>_on_escape_requested()</code> function, which will in turn emit the <code>main_menu_requested</code> signal. At the moment nothing calls the signal from the <strong>SignalBus</strong>, so we&rsquo;ll handle that next. As mentioned, we&rsquo;ll use the <code>EscapeAction</code> for that. So in <em>escape_action.gd</em> change the <code>perform()</code> function to the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	SignalBus<span style="color:#f92672">.</span>escape_requested<span style="color:#f92672">.</span>emit()
	<span style="color:#66d9ef">return</span> false
</code></pre></div><p>Now the signal get&rsquo;s called at the appropriate moment. We can now use it in <em>game_manager.gd</em>. Change the <code>_on_game_requested()</code> function to the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _on_game_requested(try_load: <span style="color:#a6e22e">bool</span>) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> game: GameRoot <span style="color:#f92672">=</span> switch_to_scene(game_scene)
	game<span style="color:#f92672">.</span>main_menu_requested<span style="color:#f92672">.</span>connect(load_main_menu)
</code></pre></div><p>We added a line to connect the new <code>main_menu_requested</code> signal to the <code>load_main_menu()</code> function. At this point you should be able to start the game to see the main menu. From there you can start a new game. Pressing Escape should take you back to the main menu, where you can again start a new game. Not terribly useful at the moment, but it&rsquo;s the setup we&rsquo;ll need for what comes next: the actual saving and loading.</p>
<p>Before we dive into it, let me briefly describe the approach I&rsquo;m using. One thing that helps us with saving is our <code>MapData</code> class. This object holds the information about the map and all relevant objects in the game. So what we ultimately want to do is to be able to save and restore that <code>MapData</code> object. From there we will go in a hierarchical fashion. We will use an interface where every object that can be saved implements a <code>get_save_data()</code> function. This function will return a <code>Dictionary</code> that each objet will fill with the data it needs to save. In addition to that each object knows what other objects it is responsible for that might need saving. For example, an <code>Entity</code> know that it needs to save data from its <code>Component</code>s. It does not need to know how to save data from the components, because the save system is hierarchical, so the <code>Component</code>s will themselves also implement <code>get_save_data()</code>, and the <code>Entity</code> will just call that. What we will end up with is kind of tree inside a <code>Dictionary</code>. The nice thing about dictionaries is that they are relatively easy to save into JSON format.</p>
<p>Once it comes to loading we will go in reverse. The <code>MapData</code> will see that it needs to restore an <code>Entity</code>, so it will instantiate one and hand it its appropriate save data, via a <code>restore()</code> funciton. The entity will restore itself from that data, and then hand the contained save data concerning its components to those components, which will also restore themselves to the appropriate state. There will be a few edge cases we&rsquo;ll need to handle, but that&rsquo;s the theory.</p>
<p>One thing I need to mention is a shortcut I&rsquo;m taking in regards to the format. The benefit of JSON is that it&rsquo;s human readable. Theoretically you can go into the save file and inspect the saved game state. You could even edit it, and give yourself a lot of healing potions. And you can accidentally delete half of an entity, and bring the save file into a state that cannot be easily loaded. To load a save the game expects the data in a certain format. Now, one way to discourage messing with the save file is to serialize to a binary format, which can also bring you the benefits of faster write/read times and smaller file sizes. Saving everything as a bunch of (mostly redundant) strings is easy, but not very efficient. However, in both cases you need to account for the possibility of corrupted saves. If you don&rsquo;t the game might crash when trying to load a corrupted save file. This means you don&rsquo;t just load a game, you just try to load it, and you stop as soon as something doesn&rsquo;t quite fit. That would be the proper way. However, that means lots and lots of error handling in every function that is involved in restoring data. To keep this already relatively complex tutorial a bit shorter, I will omit that. Or rather I will use the aforementioned shortcut to summarize error handling into one check. To do that we will actually save two things: the complete save data in JSON format and a hash of that data. Then, when we load the save data we will hash the loaded data again and compare that hash with the one we load from the save file. If they don&rsquo;t match then we know that this isn&rsquo;t the data that we saved, and we declare loading the save game a failure right away. Of course this means that the user can&rsquo;t edit the data, even if it would result in data we could properly load. Still, we take that reduced functionality, as it saves us a lot of error handling. Or rather, it saves me a lot of error handling. In a proper project I would recommend you to look into implementing such error handling.</p>
<p>Now, while the way we can use <code>MapData</code> to save everything was good forward thinking (or luck), I did mess up a bit with entities and tiles. Tiles don&rsquo;t know what tiles they are, and neither do entities know what entities they are. This is not optimal, because their state involves data they share with their templates, such as their textures. We really don&rsquo;t want to save every entities texture in the save data. Therefore we need to do a bit of refactoring.</p>
<p>We start with the simple stuff, in our case the <code>Tile</code> class. Right now different tile types are handled by the dungeon generator. We&rsquo;re gonna move that code over to the <code>Tile</code> class itself. At the top of the script add the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">const</span> tile_types <span style="color:#f92672">=</span> {
	<span style="color:#e6db74">&#34;floor&#34;</span>: preload(<span style="color:#e6db74">&#34;res://assets/definitions/tiles/tile_definition_floor.tres&#34;</span>),
	<span style="color:#e6db74">&#34;wall&#34;</span>: preload(<span style="color:#e6db74">&#34;res://assets/definitions/tiles/tile_definition_wall.tres&#34;</span>),
}

<span style="color:#66d9ef">var</span> key: <span style="color:#a6e22e">String</span>
</code></pre></div><p>We have a constant that encodes the mapping of different keys and the corresponding tile definitions. We also add a <code>key</code> variable to the tile class that will hold the key corresponding to the tile. We modify <code>set_tile_type()</code> to work with these new variables:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> set_tile_type(key: <span style="color:#a6e22e">String</span>) <span style="color:#f92672">-&gt;</span> void:
	self<span style="color:#f92672">.</span>key <span style="color:#f92672">=</span> key
	_definition <span style="color:#f92672">=</span> tile_types[key]
	texture <span style="color:#f92672">=</span> _definition<span style="color:#f92672">.</span>texture
	modulate <span style="color:#f92672">=</span> _definition<span style="color:#f92672">.</span>color_dark
</code></pre></div><p>We call <code>set_tile_type()</code> in <code>_init()</code>, so that needs to be changed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _init(grid_position: Vector2i, key: <span style="color:#a6e22e">String</span>) <span style="color:#f92672">-&gt;</span> void:
	visible <span style="color:#f92672">=</span> false
	centered <span style="color:#f92672">=</span> false
	position <span style="color:#f92672">=</span> Grid<span style="color:#f92672">.</span>grid_to_world(grid_position)
	set_tile_type(key)
</code></pre></div><p>This is another &ldquo;<em>do as I say, not as I do</em>&rdquo; moment, because the alternative I would recommend is to use enums instead of strings. Strings are quick and easy, and for the scale this project will take they are fine. However, if you want to expand from there and implement the amount of content many roguelikes have, then using strings like this is a bit error prone. And while the difference might be negligible in a lot of cases, Strings do use more memory. This also relates to what I discussed above about saving to JSON. If you use enums you can reduce keys like these to a single byte of data. The downside of enums is that they require more code (which is the main reason I&rsquo;m omitting them here). If you decide to use them also be aware of your organization. If you use them for, e.g., entity ids, and you tend to alphabetize the keys, then you are changing the associated numbers. Imagine you save the game, and the value <code>TROLL</code> in your entities enum is equal to 2, so that gets saved. Then you work on the code, and add an ORC, which you insert before the TROLL in the enum. If you then load the previous game, the entity only knows it&rsquo;s value number 2 in the enum, which in now ORC, and what was previously a troll now loads as an orc. That means that with enums you need to be extra careful to not introduce breaking changes with loading savefiles of previous versions.</p>
<p>Speaking of saving, let&rsquo;s work on the interface we discussed above. There are two pieces of data the tile needs to save in order to be restored later. The newly introduced <code>key</code>, as well as <code>is_explored</code>. The position is encoded in the tile&rsquo;s index in the tiles array, and <code>is_visible</code> can easily be restored by recalculating the field of view once we load the save. So here are the two functions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_save_data() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Dictionary</span>:
	<span style="color:#66d9ef">return</span> {
		<span style="color:#e6db74">&#34;key&#34;</span>: key,
		<span style="color:#e6db74">&#34;is_explored&#34;</span>: is_explored
	}


<span style="color:#66d9ef">func</span> restore(save_data: <span style="color:#a6e22e">Dictionary</span>) <span style="color:#f92672">-&gt;</span> void:
	set_tile_type(save_data[<span style="color:#e6db74">&#34;key&#34;</span>])
	is_explored <span style="color:#f92672">=</span> save_data[<span style="color:#e6db74">&#34;is_explored&#34;</span>]
</code></pre></div><p>In <code>get_save_data()</code> we create a dictionary holding those two pieces of information I just mentioned. The <code>restore()</code> function then can consume such a dictionary and set the tile to the correct properties via <code>set_tile_type()</code> and the stored <code>key</code>, and <code>is_explored</code> is simply restored from the save data. Now that we have actually implemented such a <code>get_save_data()</code>/<code>restore()</code> pair it is hopefully clear why loading could be a bit fickle. This function simply assumes that it gets the correct data. If it would get anything else than a <code>Dictionary</code>, if the dictionary would not contain the proper keys, or if the data didn&rsquo;t have the correct types for example, the game would just crash. We would rather have a nice popup telling the player that the save data is corrupted, and can&rsquo;t be loaded, so at each step we would have to make sure that everything is as we expect it. Just to illustrate here is how this might look with some more proper error checking (this code does not go into the project, don&rsquo;t copy it):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> restore(save_data: <span style="color:#a6e22e">Dictionary</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">var</span> stored_key <span style="color:#f92672">=</span> save_data<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#34;key&#34;</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> stored_key is <span style="color:#a6e22e">String</span> <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> stored_key <span style="color:#f92672">in</span> tile_types:
		<span style="color:#66d9ef">return</span> false
	set_tile_type(stored_key)
	<span style="color:#66d9ef">var</span> stored_is_explored <span style="color:#f92672">=</span> save_data<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#34;is_explored&#34;</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> stored_is_explored is <span style="color:#a6e22e">bool</span>:
		<span style="color:#66d9ef">return</span> false
	is_explored <span style="color:#f92672">=</span> stored_is_explored
	<span style="color:#66d9ef">return</span> true
</code></pre></div><p>In such a system we would have a return value that would return a <code>false</code> early if there are any issues, and true if everything is going ok. If any of the <code>restore()</code> functions called by the load system fails, we would abort loading and declare it a failure. You see here that at every step we need to check if the data is as we expect. Thankfully, the <code>get()</code> function on the dictionary can safely get a value, i.e., if a key does not exist it returns <code>null</code>. By checking the type we can also ensure that the returned value isn&rsquo;t <code>null</code>, which is why I did not need to explicitly check if the key exists in the dictionary. As you can see, this error checking can make our game more robust, but the extra checks would add up, which I want to spare us both.</p>
<p>We have changed the way we set tiles, which means refactoring in the two places that create or set tiles. In map_data.gd_ you can first remove the <code>const</code> dictionary at the top, as we now have this data directly in the <code>Tile</code> class. Then change <code>_setup_tiles()</code> to the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _setup_tiles() <span style="color:#f92672">-&gt;</span> void:
	tiles <span style="color:#f92672">=</span> []
	<span style="color:#66d9ef">for</span> y <span style="color:#f92672">in</span> height:
		<span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> width:
			<span style="color:#66d9ef">var</span> tile_position :<span style="color:#f92672">=</span> Vector2i(x, y)
			<span style="color:#66d9ef">var</span> tile :<span style="color:#f92672">=</span> Tile<span style="color:#f92672">.</span>new(tile_position, <span style="color:#e6db74">&#34;wall&#34;</span>)
			tiles<span style="color:#f92672">.</span>append(tile)
</code></pre></div><p>Here we now use the string key instead of the dictionary key we used before. We also have to change the <code>_carve_tile()</code> function in <em>dungeon_generatore.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _carve_tile(dungeon: MapData, x: <span style="color:#a6e22e">int</span>, y: <span style="color:#a6e22e">int</span>) <span style="color:#f92672">-&gt;</span> void:
		<span style="color:#66d9ef">var</span> tile_position <span style="color:#f92672">=</span> Vector2i(x, y)
		<span style="color:#66d9ef">var</span> tile: Tile <span style="color:#f92672">=</span> dungeon<span style="color:#f92672">.</span>get_tile(tile_position)
		tile<span style="color:#f92672">.</span>set_tile_type(<span style="color:#e6db74">&#34;floor&#34;</span>)
</code></pre></div><p>Next, we can move our attention to entities. We have to do similar changes there. However, entities are more complex than tiles and have several components, which also need to be saved. And you probably know by now how much I dislike having parser errors while writing the code, so we will start with implementing the save code on the components, so we can call <code>get_save_dict()</code> and <code>restore()</code> on them from the <code>Entity</code> class later without any red lines.</p>
<p>We can actually ignore the consumable component. That component does not really have any changing state. So if we restore an entity to, let&rsquo;s say, a standard lightning scroll, then the consumable component on that will already be the correct one. So that&rsquo;s one component done already without doing any work.</p>
<p>Next the fighter component, which is the most straight forward of the components to save, but it still needs some extra attention. In <em>fighter_component.gd</em> we add the two functions necessary for the save system:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_save_data() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Dictionary</span>:
	<span style="color:#66d9ef">return</span> {
		<span style="color:#e6db74">&#34;max_hp&#34;</span>: max_hp,
		<span style="color:#e6db74">&#34;hp&#34;</span>: hp,
		<span style="color:#e6db74">&#34;power&#34;</span>: power,
		<span style="color:#e6db74">&#34;defense&#34;</span>: defense
	}


<span style="color:#66d9ef">func</span> restore(save_data: <span style="color:#a6e22e">Dictionary</span>) <span style="color:#f92672">-&gt;</span> void:
	max_hp <span style="color:#f92672">=</span> save_data[<span style="color:#e6db74">&#34;max_hp&#34;</span>]
	hp <span style="color:#f92672">=</span> save_data[<span style="color:#e6db74">&#34;hp&#34;</span>]
	power <span style="color:#f92672">=</span> save_data[<span style="color:#e6db74">&#34;power&#34;</span>]
	defense <span style="color:#f92672">=</span> save_data[<span style="color:#e6db74">&#34;defense&#34;</span>]
</code></pre></div><p>We simply store all the values that can change, and later restore all those. So far so good. However, what happens if we restore a dead enemy? Its <code>hp</code> will be zero, so setting it in the <code>restore()</code> function will call the setter on <code>hp</code>, which in turn will call <code>die()</code> function. This is good news for us, because we don&rsquo;t need to store the death texture on the parent entity separately, or the changed name. This does, however, introduce two issues. One is that the die function might run before the entity is actually spawned, which can cause problems with accessing the entity texture, etc. The other problem is that the <code>die()</code> function creates a log message. Now, imagine you defeat every monster on a dungeon floor, then save the game, and upon loading the game again are greeted with dozens of &ldquo;%s is dead!&rdquo; messages. For that reason we change the <code>die()</code> function to allow entities to die silently:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> die(log_message :<span style="color:#f92672">=</span> true) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> death_message: <span style="color:#a6e22e">String</span>
	<span style="color:#66d9ef">var</span> death_message_color: <span style="color:#a6e22e">Color</span>
	
	<span style="color:#66d9ef">if</span> get_map_data()<span style="color:#f92672">.</span>player <span style="color:#f92672">==</span> entity:
		death_message <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;You died!&#34;</span>
		death_message_color <span style="color:#f92672">=</span> GameColors<span style="color:#f92672">.</span>PLAYER_DIE
		SignalBus<span style="color:#f92672">.</span>player_died<span style="color:#f92672">.</span>emit()
	<span style="color:#66d9ef">else</span>:
		death_message <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> is dead!&#34;</span> <span style="color:#f92672">%</span> entity<span style="color:#f92672">.</span>get_entity_name()
		death_message_color <span style="color:#f92672">=</span> GameColors<span style="color:#f92672">.</span>ENEMY_DIE
	
	<span style="color:#66d9ef">if</span> log_message:
		MessageLog<span style="color:#f92672">.</span>send_message(death_message, death_message_color)
	<span style="color:#f92672">...</span>
</code></pre></div><p>So we only spawn the log message if we tell the function to. This function gets called in the <code>hp</code> setter, so we need to adapt that setter:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">var</span> hp: <span style="color:#a6e22e">int</span>:
	set(value):
		hp <span style="color:#f92672">=</span> clampi(value, <span style="color:#ae81ff">0</span>, max_hp)
		hp_changed<span style="color:#f92672">.</span>emit(hp, max_hp)
		<span style="color:#66d9ef">if</span> hp <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>:
			<span style="color:#66d9ef">var</span> die_silently :<span style="color:#f92672">=</span> false
			<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> is_inside_tree():
				die_silently <span style="color:#f92672">=</span> true
				await ready
			die(<span style="color:#f92672">not</span> die_silently)
</code></pre></div><p>The important part is that we check whether or not the <code>FighterComponent</code> is in the scene tree or not. If it is not, then that&rsquo;s because the entity is dying during loading. In that case we want it to die silently (and wait to do so until it is in the tree). If it is in the scene tree, then it&rsquo;s dying regularly, and we want to have the same behavior we had so far. Now that we handled that we move to another edge case. Remember how I said that we don&rsquo;t need to handle the consumable component, because it doesn&rsquo;t have state? Well, the enemy AI also doesn&rsquo;t have state. Except for the confused AI. On top of that the confused ai should temporarily replace the default ai, but that one still needs to exist, so it can be restored after the confusion is over. For this reason I have decided to handle the AI component in the saving code for the entity. However, we still need info about the AI, namely which type it is, and if it&rsquo;s a confused AI, how many turns are remaining. That&rsquo;s why we&rsquo;ll only implement the <code>get_save_data()</code> function on the AI components. So open <em>base_ai_component.gd</em> and add the following function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_save_data() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Dictionary</span>:
	<span style="color:#66d9ef">return</span> {}
</code></pre></div><p>This is basically an abstract base class, so this won&rsquo;t return any concrete data. However, the hostile enemy AI will inform us about its type. So the function for <em>hostile_enemy_ai_component.gd</em> looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_save_data() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Dictionary</span>:
	<span style="color:#66d9ef">return</span> {<span style="color:#e6db74">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;HostileEnemyAI&#34;</span>}
</code></pre></div><p>We simply save the name of the AI as a string. In <em>confused_enemy_ai_component.gd</em> we do the same, but in addition we save the remaining turns as well:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_save_data() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Dictionary</span>:
	<span style="color:#66d9ef">return</span> {
		<span style="color:#e6db74">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;ConfusedEnemyAI&#34;</span>,
		<span style="color:#e6db74">&#34;turns_remaining&#34;</span>: turns_remaining
	}
</code></pre></div><p>That&rsquo;s all the info we need from the AI component. We&rsquo;ll look at how to restore it once we get to the restore code for the entity. For now we have one more component to take care of, the inventory. The inventory needs to save two things. It&rsquo;s capacity (which isn&rsquo;t strictly necessary because we don&rsquo;t allow the capacity to change at the moment, so that technically isn&rsquo;t part of its state) and the stored items. The items are entities, so here we do get to a cyclic dependency, but we&rsquo;ll get to the entity shortly. So here&rsquo;s the code for saving we&rsquo;ll add to <em>inventory_component.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_save_data() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Dictionary</span>:
	<span style="color:#66d9ef">var</span> save_data: <span style="color:#a6e22e">Dictionary</span> <span style="color:#f92672">=</span> {
		<span style="color:#e6db74">&#34;capacity&#34;</span>: capacity,
		<span style="color:#e6db74">&#34;items&#34;</span>: []
	}
	<span style="color:#66d9ef">for</span> item <span style="color:#f92672">in</span> items:
		save_data[<span style="color:#e6db74">&#34;items&#34;</span>]<span style="color:#f92672">.</span>append(item<span style="color:#f92672">.</span>get_save_data())
	<span style="color:#66d9ef">return</span> save_data
</code></pre></div><p>This is where our hierarchical approach shines. We create an array in which we will save the data for the items. Then we go through all the items and request the save data from each. Imagine if you were to create a container item that had an inventory itself. In that case the save system would still work, and would just recursively get the data from entities, their inventory components, their entities, their inventory components, their entities, and so on. Now to restoring the inventory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> restore(save_data: <span style="color:#a6e22e">Dictionary</span>) <span style="color:#f92672">-&gt;</span> void:
	capacity <span style="color:#f92672">=</span> save_data[<span style="color:#e6db74">&#34;capacity&#34;</span>]
	<span style="color:#66d9ef">for</span> item_data <span style="color:#f92672">in</span> save_data[<span style="color:#e6db74">&#34;items&#34;</span>]:
		<span style="color:#66d9ef">var</span> item: Entity <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(null, Vector2i(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>), <span style="color:#e6db74">&#34;&#34;</span>)
		item<span style="color:#f92672">.</span>restore(item_data)
		items<span style="color:#f92672">.</span>append(item)
</code></pre></div><p>Here we read in an array which should contain multiple dictionaries, each containing save data of an entity (i.e., an item). We loop through each of those and instantiate a new entity for it. You will get a parsing error at this point, because this constructor does not match the constructor you currently have for the <code>Entity</code> class. Nonetheless, we pass the item&rsquo;s save data to the newly created entities <code>restore()</code> function, and then add it to our <code>items</code> array.</p>
<p>Before we tackle saving and restoring entities, we have to refactor them a bit, just as we did with tiles. So, in <em>entity.gd</em> we&rsquo;ll add the following two things:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name Entity
<span style="color:#66d9ef">extends</span> Sprite2D

<span style="color:#66d9ef">enum</span> AIType {NONE, HOSTILE}
<span style="color:#66d9ef">enum</span> EntityType {CORPSE, ITEM, ACTOR}

<span style="color:#66d9ef">const</span> entity_types <span style="color:#f92672">=</span> {
	<span style="color:#e6db74">&#34;player&#34;</span>: <span style="color:#e6db74">&#34;res://assets/definitions/entities/actors/entity_definition_player.tres&#34;</span>,
	<span style="color:#e6db74">&#34;orc&#34;</span>: <span style="color:#e6db74">&#34;res://assets/definitions/entities/actors/entity_definition_orc.tres&#34;</span>,
	<span style="color:#e6db74">&#34;troll&#34;</span>: <span style="color:#e6db74">&#34;res://assets/definitions/entities/actors/entity_definition_troll.tres&#34;</span>,
	<span style="color:#e6db74">&#34;health_potion&#34;</span>: <span style="color:#e6db74">&#34;res://assets/definitions/entities/items/health_potion_definition.tres&#34;</span>,
	<span style="color:#e6db74">&#34;lightning_scroll&#34;</span>: <span style="color:#e6db74">&#34;res://assets/definitions/entities/items/lightning_scroll_definition.tres&#34;</span>,
	<span style="color:#e6db74">&#34;confusion_scroll&#34;</span>: <span style="color:#e6db74">&#34;res://assets/definitions/entities/items/confusion_scroll_definition.tres&#34;</span>,
	<span style="color:#e6db74">&#34;fireball_scroll&#34;</span>: <span style="color:#e6db74">&#34;res://assets/definitions/entities/items/fireball_scroll_definition.tres&#34;</span>,
}

<span style="color:#66d9ef">var</span> key: <span style="color:#a6e22e">String</span>
</code></pre></div><p>Here we added a constant dictionary that maps string keys to entity definitions. This information was previously in the dungeon generator. One important thing to notice here is that we don&rsquo;t use <code>preload()</code>. Unfortunately <code>preload()</code> would cause cyclic dependency errors, so instead we&rsquo;ll load these resources at runtime. They&rsquo;re pretty lightweight, so it won&rsquo;t be an issue here. Apart from this dictionary we also added a <code>key</code> variable, so an entity can know what type of entity it is. As with the <code>Tile</code> class, this changes how we set the entity type. Here&rsquo;s the (top part of) that function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> set_entity_type(key: <span style="color:#a6e22e">String</span>) <span style="color:#f92672">-&gt;</span> void:
	self<span style="color:#f92672">.</span>key <span style="color:#f92672">=</span> key
	<span style="color:#66d9ef">var</span> entity_definition: EntityDefinition <span style="color:#f92672">=</span> load(entity_types[key])
	_definition <span style="color:#f92672">=</span> entity_definition
</code></pre></div><p>We now give that function a key, which it will use to look up the path to the entity definition and load that. The rest of that function stays the same. This of course also affects our constructor again:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _init(map_data: MapData, start_position: Vector2i, key: <span style="color:#a6e22e">String</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>) <span style="color:#f92672">-&gt;</span> void:
	centered <span style="color:#f92672">=</span> false
	grid_position <span style="color:#f92672">=</span> start_position
	self<span style="color:#f92672">.</span>map_data <span style="color:#f92672">=</span> map_data
	<span style="color:#66d9ef">if</span> key <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span>:
		set_entity_type(key)
</code></pre></div><p>We now have a key string we pass into the function. We do need the ability to spawn an entity without a type and then set that type later, as you saw in the <code>restore()</code> function of the inventory component. We encode this with an empty string, in which case we simply don&rsquo;t set any type.</p>
<p>Let&rsquo;s clean up the rest of the code to work with these changes. Open <em>dungeon_generator.gd</em> and remove the <code>entity_types</code> constant from the top of the script. Then, in <code>_place_entities()</code> we change the way we instantiate new entities. Here are the relevant parts:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">		<span style="color:#66d9ef">if</span> can_place:
			<span style="color:#66d9ef">var</span> new_entity: Entity
			<span style="color:#66d9ef">if</span> _rng<span style="color:#f92672">.</span>randf() <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.8</span>:
				new_entity <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(dungeon, new_entity_position, <span style="color:#e6db74">&#34;orc&#34;</span>)
			<span style="color:#66d9ef">else</span>:
				new_entity <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(dungeon, new_entity_position, <span style="color:#e6db74">&#34;troll&#34;</span>)
			dungeon<span style="color:#f92672">.</span>entities<span style="color:#f92672">.</span>append(new_entity)

		<span style="color:#75715e"># ...</span>

		<span style="color:#66d9ef">if</span> can_place:
			<span style="color:#66d9ef">var</span> item_chance: <span style="color:#a6e22e">float</span> <span style="color:#f92672">=</span> _rng<span style="color:#f92672">.</span>randf()
			<span style="color:#66d9ef">var</span> new_entity: Entity
			<span style="color:#66d9ef">if</span> item_chance <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.7</span>:
				new_entity <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(dungeon, new_entity_position, <span style="color:#e6db74">&#34;health_potion&#34;</span>)
			<span style="color:#66d9ef">elif</span> item_chance <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.8</span>:
				new_entity <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(dungeon, new_entity_position, <span style="color:#e6db74">&#34;fireball_scroll&#34;</span>)
			<span style="color:#66d9ef">elif</span> item_chance <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.9</span>:
				new_entity <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(dungeon, new_entity_position, <span style="color:#e6db74">&#34;confusion_scroll&#34;</span>)
			<span style="color:#66d9ef">else</span>:
				new_entity <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(dungeon, new_entity_position, <span style="color:#e6db74">&#34;lightning_scroll&#34;</span>)
			dungeon<span style="color:#f92672">.</span>entities<span style="color:#f92672">.</span>append(new_entity)
</code></pre></div><p>The one extra place we are create an entity is the <code>_ready()</code> function of <em>game.gd</em>, where we create the player:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> new_game() <span style="color:#f92672">-&gt;</span> void:
	player <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(null, Vector2i<span style="color:#f92672">.</span>ZERO, <span style="color:#e6db74">&#34;player&#34;</span>)
	<span style="color:#75715e"># ...</span>
</code></pre></div><p>Now back to <em>entity.gd</em>. We are ready to save some data:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_save_data() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Dictionary</span>:
	<span style="color:#66d9ef">var</span> save_data: <span style="color:#a6e22e">Dictionary</span> <span style="color:#f92672">=</span> {
		<span style="color:#e6db74">&#34;x&#34;</span>: grid_position<span style="color:#f92672">.</span>x,
		<span style="color:#e6db74">&#34;y&#34;</span>: grid_position<span style="color:#f92672">.</span>y,
		<span style="color:#e6db74">&#34;key&#34;</span>: key,
	}
	<span style="color:#66d9ef">if</span> fighter_component:
		save_data[<span style="color:#e6db74">&#34;fighter_component&#34;</span>] <span style="color:#f92672">=</span> fighter_component<span style="color:#f92672">.</span>get_save_data()
	<span style="color:#66d9ef">if</span> ai_component:
		save_data[<span style="color:#e6db74">&#34;ai_component&#34;</span>] <span style="color:#f92672">=</span> ai_component<span style="color:#f92672">.</span>get_save_data()
	<span style="color:#66d9ef">if</span> inventory_component:
		save_data[<span style="color:#e6db74">&#34;inventory_component&#34;</span>] <span style="color:#f92672">=</span> inventory_component<span style="color:#f92672">.</span>get_save_data()
	<span style="color:#66d9ef">return</span> save_data
</code></pre></div><p>We save the position, the key and info about the three components for which we coded <code>get_save_data()</code> functions. One thing of note here is that JSON does not have a concept of <code>Vector2i</code>, so we save the coordinates individually. Next, the slightly more complicated <code>restore()</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> restore(save_data: <span style="color:#a6e22e">Dictionary</span>) <span style="color:#f92672">-&gt;</span> void:
	grid_position <span style="color:#f92672">=</span> Vector2i(save_data[<span style="color:#e6db74">&#34;x&#34;</span>], save_data[<span style="color:#e6db74">&#34;y&#34;</span>])
	set_entity_type(save_data[<span style="color:#e6db74">&#34;key&#34;</span>])
	<span style="color:#66d9ef">if</span> fighter_component <span style="color:#f92672">and</span> save_data<span style="color:#f92672">.</span>has(<span style="color:#e6db74">&#34;fighter_component&#34;</span>):
		fighter_component<span style="color:#f92672">.</span>restore(save_data[<span style="color:#e6db74">&#34;fighter_component&#34;</span>])
	<span style="color:#66d9ef">if</span> ai_component <span style="color:#f92672">and</span> save_data<span style="color:#f92672">.</span>has(<span style="color:#e6db74">&#34;ai_component&#34;</span>):
		<span style="color:#66d9ef">var</span> ai_data: <span style="color:#a6e22e">Dictionary</span> <span style="color:#f92672">=</span> save_data[<span style="color:#e6db74">&#34;ai_component&#34;</span>]
		<span style="color:#66d9ef">if</span> ai_data[<span style="color:#e6db74">&#34;type&#34;</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;ConfusedEnemyAI&#34;</span>:
			<span style="color:#66d9ef">var</span> confused_enemy_ai :<span style="color:#f92672">=</span> ConfusedEnemyAIComponent<span style="color:#f92672">.</span>new(ai_data[<span style="color:#e6db74">&#34;turns_remaining&#34;</span>])
			add_child(confused_enemy_ai)
	<span style="color:#66d9ef">if</span> inventory_component <span style="color:#f92672">and</span> save_data<span style="color:#f92672">.</span>has(<span style="color:#e6db74">&#34;inventory_component&#34;</span>):
		inventory_component<span style="color:#f92672">.</span>restore(save_data[<span style="color:#e6db74">&#34;inventory_component&#34;</span>])
</code></pre></div><p>Here, we first restore the position by rebuilding the <code>grid_position</code> vector from the individual coordinates we saved. Then we set the entity type. This tells us that restoring the entity type will be the entities job, and whatever creates the restored entities will create typeless entities (using an empty string as key). Restoring the fighter component and the inventory component is straight forward. We just have to check if these exist so our code works for all kinds of entities. For example items don&rsquo;t have a fighter component. Where we have to do a bit more work is the AI component. Currently all actor entities will spawn (and therefore restore) with a <code>HostileEnemyAIComponent</code>. That&rsquo;s good, because that&rsquo;s the one we have to back up when using the confused AI. So in the case we detect that we have stored a confused AI, we create a new <code>ConfusedEnemyAIComponent</code> and get the number of turns remaining from the save data. Ten we add it as a child, from where that component will handle the rest.</p>
<p>The entities in the inventory will be handled recursively. However, there is an issue. Components get their parent entity when they are added to it, but if we restore entities within the inventory they are not added to the tree, and the <code>_ready()</code> function associating components with their parent entities won&rsquo;t run. For consumables that is problematic, because when we create item actions they will try to access the parent entity. We can get around that by setting the parent entity manually. In <em>entity.gd</em> modify the <code>handle_consumables()</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _handle_consumable(consumable_definition: ConsumableComponentDefinition) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">if</span> consumable_definition is HealingConsumableComponentDefinition:
		consumable_component <span style="color:#f92672">=</span> HealingConsumableComponent<span style="color:#f92672">.</span>new(consumable_definition)
	<span style="color:#66d9ef">elif</span> consumable_definition is LightningDamageConsumableComponentDefinition:
		consumable_component <span style="color:#f92672">=</span> LightningDamageConsumableComponent<span style="color:#f92672">.</span>new(consumable_definition)
	<span style="color:#66d9ef">elif</span> consumable_definition is ConfusionConsumableComponentDefinition:
		consumable_component <span style="color:#f92672">=</span> ConfusionConsumableComponent<span style="color:#f92672">.</span>new(consumable_definition)
	<span style="color:#66d9ef">elif</span> consumable_definition is FireballDamageConsumableComponentDefinition:
		consumable_component <span style="color:#f92672">=</span> FireballDamageConsumableComponent<span style="color:#f92672">.</span>new(consumable_definition)
	
	<span style="color:#66d9ef">if</span> consumable_component:
		add_child(consumable_component)
	consumable_component<span style="color:#f92672">.</span>entity <span style="color:#f92672">=</span> self
</code></pre></div><p>We added a line that directly sets the <code>entity</code> of the <code>consumable_component</code>, and this will work even if the entity isn&rsquo;t in the scene tree.</p>
<p>The last thing that needs code for saving and restoring is <em>map_data.gd</em>. The <code>MapData</code> will coordinate all the rest of the saving and loading. One last time we implement <code>get_save_data()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_save_data() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Dictionary</span>:
	<span style="color:#66d9ef">var</span> save_data :<span style="color:#f92672">=</span> {
		<span style="color:#e6db74">&#34;width&#34;</span>: width,
		<span style="color:#e6db74">&#34;height&#34;</span>: height,
		<span style="color:#e6db74">&#34;player&#34;</span>: player<span style="color:#f92672">.</span>get_save_data(),
		<span style="color:#e6db74">&#34;entities&#34;</span>: [],
		<span style="color:#e6db74">&#34;tiles&#34;</span>: []
	}
	<span style="color:#66d9ef">for</span> entity <span style="color:#f92672">in</span> entities:
		<span style="color:#66d9ef">if</span> entity <span style="color:#f92672">==</span> player:
			<span style="color:#66d9ef">continue</span>
		save_data[<span style="color:#e6db74">&#34;entities&#34;</span>]<span style="color:#f92672">.</span>append(entity<span style="color:#f92672">.</span>get_save_data())
	<span style="color:#66d9ef">for</span> tile <span style="color:#f92672">in</span> tiles:
		save_data[<span style="color:#e6db74">&#34;tiles&#34;</span>]<span style="color:#f92672">.</span>append(tile<span style="color:#f92672">.</span>get_save_data())
	<span style="color:#66d9ef">return</span> save_data
</code></pre></div><p>We save the width and height of the map itself. As we treat the player entity in a special way we store its data separately. This also means skipping it when we save the entities array. The other array we save is an array of save data from tiles. Now to restoring that data:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> restore(save_data: <span style="color:#a6e22e">Dictionary</span>) <span style="color:#f92672">-&gt;</span> void:
	width <span style="color:#f92672">=</span> save_data[<span style="color:#e6db74">&#34;width&#34;</span>]
	height <span style="color:#f92672">=</span> save_data[<span style="color:#e6db74">&#34;height&#34;</span>]
	_setup_tiles()
	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> tiles<span style="color:#f92672">.</span>size():
		tiles[i]<span style="color:#f92672">.</span>restore(save_data[<span style="color:#e6db74">&#34;tiles&#34;</span>][i])
	setup_pathfinding()
	player<span style="color:#f92672">.</span>restore(save_data[<span style="color:#e6db74">&#34;player&#34;</span>])
	player<span style="color:#f92672">.</span>map_data <span style="color:#f92672">=</span> self
	entities <span style="color:#f92672">=</span> [player]
	<span style="color:#66d9ef">for</span> entity_data <span style="color:#f92672">in</span> save_data[<span style="color:#e6db74">&#34;entities&#34;</span>]:
		<span style="color:#66d9ef">var</span> new_entity :<span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(self, Vector2i<span style="color:#f92672">.</span>ZERO, <span style="color:#e6db74">&#34;&#34;</span>)
		new_entity<span style="color:#f92672">.</span>restore(entity_data)
		entities<span style="color:#f92672">.</span>append(new_entity)
</code></pre></div><p>We restore width and height, after which we can call <code>_setup_tiles()</code>. This fills the map data with the appropriate amount of tiles. We can then restore each tile with the appropriate save data. After that we can call <code>setup_pathfinding()</code> to create our AStar map. Our map data is fed a player from the outside when it is created, so we can directly restore that variable from the save data, and start a new <code>entities</code> array with it. Lastly, we go through all the saved entities, create new ones and restore them with the save data, then add them to the array.</p>
<p>As the <code>MapData</code> class is somewhat of an entry point into our save system we can also give it the responsibility of actually saving to and loading from a file. We start with a <code>save()</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> save() <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> file <span style="color:#f92672">=</span> FileAccess<span style="color:#f92672">.</span>open(<span style="color:#e6db74">&#34;user://save_game.dat&#34;</span>, FileAccess<span style="color:#f92672">.</span>WRITE)
	<span style="color:#66d9ef">var</span> save_data: <span style="color:#a6e22e">Dictionary</span> <span style="color:#f92672">=</span> get_save_data()
	<span style="color:#66d9ef">var</span> save_string: <span style="color:#a6e22e">String</span> <span style="color:#f92672">=</span> JSON<span style="color:#f92672">.</span>stringify(save_data)
	<span style="color:#66d9ef">var</span> save_hash: <span style="color:#a6e22e">String</span> <span style="color:#f92672">=</span> save_string<span style="color:#f92672">.</span>sha256_text()
	file<span style="color:#f92672">.</span>store_line(save_hash)
	file<span style="color:#f92672">.</span>store_line(save_string)
</code></pre></div><p>We first open a file which we will call <em>save_game.dat</em> for writing. If the file doesn&rsquo;t exist this will create a new one, otherwise it will overwrite an existing save file. Then we get the save data, which we subsequently turn into JSON string. We also compute a hash of that string. We then store the hash in the first line and the save data in a second line. This means that ultimately our save data is just a text file. Now to loading that data again:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> load_game() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">var</span> file <span style="color:#f92672">=</span> FileAccess<span style="color:#f92672">.</span>open(<span style="color:#e6db74">&#34;user://save_game.dat&#34;</span>, FileAccess<span style="color:#f92672">.</span>READ)
	<span style="color:#66d9ef">var</span> retrieved_hash: <span style="color:#a6e22e">String</span> <span style="color:#f92672">=</span> file<span style="color:#f92672">.</span>get_line()
	<span style="color:#66d9ef">var</span> save_string: <span style="color:#a6e22e">String</span> <span style="color:#f92672">=</span> file<span style="color:#f92672">.</span>get_line()
	<span style="color:#66d9ef">var</span> calculated_hash: <span style="color:#a6e22e">String</span> <span style="color:#f92672">=</span> save_string<span style="color:#f92672">.</span>sha256_text()
	<span style="color:#66d9ef">var</span> valid_hash: <span style="color:#a6e22e">bool</span> <span style="color:#f92672">=</span> retrieved_hash <span style="color:#f92672">==</span> calculated_hash
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> valid_hash:
		<span style="color:#66d9ef">return</span> false
	<span style="color:#66d9ef">var</span> save_data: <span style="color:#a6e22e">Dictionary</span> <span style="color:#f92672">=</span> JSON<span style="color:#f92672">.</span>parse_string(save_string)
	restore(save_data)
	<span style="color:#66d9ef">return</span> true
</code></pre></div><p>First thing to note is the return value, which will indicate if we could successfully load the save. In the function we start by opening the same <em>save_game.dat</em> file for reading. We can get both the saved hash and the save data by querying the two lines of the file. Next we calculate the hash of the save data we just retrieved from the file. If this did not change from the data that we originally saved to the file then this new hash should be the same as the one we stored, so this is what we check. If the hashes differ, we abort and return false, declaring loading a failure. However, if they match then everything should be ok and we can move forward with parsing the retrieved data string into a dictionary, and then using that dictionary to restore our previous game state.</p>
<p>This is the functionality we needed for saving and loading our data. We still need to make sure all the things render properly, which is the responsibility of our <em>map.gd</em> class. To do that we add a new function to it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> load_game(player: Entity) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	map_data <span style="color:#f92672">=</span> MapData<span style="color:#f92672">.</span>new(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, player)
	map_data<span style="color:#f92672">.</span>entity_placed<span style="color:#f92672">.</span>connect(entities<span style="color:#f92672">.</span>add_child)
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> map_data<span style="color:#f92672">.</span>load_game():
		<span style="color:#66d9ef">return</span> false
	_place_tiles()
	_place_entities()
	<span style="color:#66d9ef">return</span> true
</code></pre></div><p>Again we have the bool that indicates whether loading was successful or not. We create a new map data. Other than in <code>generate()</code> we don&rsquo;t get it from the dungeon generator. Then we try to load the game. This will restore both the <code>entities</code> and the <code>tiles</code> array on <code>map_data</code>. Just like in <code>generate()</code>, however, the contents of these arrays are not yet in the scene tree, so we call <code>_place_tiles()</code> and <code>_place_entities()</code>.</p>
<p>Next we go to <em>game.gd</em>, which will handle the top level code for new games and loading games. If you think about it, we already know how to create a brand new game. It&rsquo;s what we&rsquo;ve been doing all the time so far, and it&rsquo;s what the <strong>Game</strong> node automatically does upon loading. So if we want a bit more control of when this code is called we can just rename the <code>_ready()</code> function to <code>new_game()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> new_game() <span style="color:#f92672">-&gt;</span> void:
	player <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(null, Vector2i<span style="color:#f92672">.</span>ZERO, <span style="color:#e6db74">&#34;player&#34;</span>)
	player_created<span style="color:#f92672">.</span>emit(player)
	remove_child(camera)
	player<span style="color:#f92672">.</span>add_child(camera)
	map<span style="color:#f92672">.</span>generate(player)
	map<span style="color:#f92672">.</span>update_fov(player<span style="color:#f92672">.</span>grid_position)
	MessageLog<span style="color:#f92672">.</span>send_message<span style="color:#f92672">.</span>bind(
		<span style="color:#e6db74">&#34;Hello and welcome, adventurer, to yet another dungeon!&#34;</span>,
		GameColors<span style="color:#f92672">.</span>WELCOME_TEXT
	)<span style="color:#f92672">.</span>call_deferred()
	camera<span style="color:#f92672">.</span>make_current<span style="color:#f92672">.</span>call_deferred()
</code></pre></div><p>The alternative is to load a game, which works similarly but has some variation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> load_game() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	player <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(null, Vector2i<span style="color:#f92672">.</span>ZERO, <span style="color:#e6db74">&#34;&#34;</span>)
	remove_child(camera)
	player<span style="color:#f92672">.</span>add_child(camera)
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> map<span style="color:#f92672">.</span>load_game(player):
		<span style="color:#66d9ef">return</span> false
	player_created<span style="color:#f92672">.</span>emit(player)
	map<span style="color:#f92672">.</span>update_fov(player<span style="color:#f92672">.</span>grid_position)
	MessageLog<span style="color:#f92672">.</span>send_message<span style="color:#f92672">.</span>bind(
		<span style="color:#e6db74">&#34;Welcome back, adventurer!&#34;</span>,
		GameColors<span style="color:#f92672">.</span>WELCOME_TEXT
	)<span style="color:#f92672">.</span>call_deferred()
	camera<span style="color:#f92672">.</span>make_current<span style="color:#f92672">.</span>call_deferred()
	<span style="color:#66d9ef">return</span> true
</code></pre></div><p>The most important differences are that we return a bool to indicate whether loading was successful. Most of the other code is pretty similar, save for another message and that we don&rsquo;t let the map generate anew, but load from the saved state, with the code we just implemented above. With that code in place we can go further up the tree, back to <em>game_root.gd</em>. We create two new functions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> new_game() <span style="color:#f92672">-&gt;</span> void:
	game<span style="color:#f92672">.</span>new_game()


<span style="color:#66d9ef">func</span> load_game() <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> game<span style="color:#f92672">.</span>load_game():
		main_menu_requested<span style="color:#f92672">.</span>emit()
</code></pre></div><p>Here we handle the possibility for error. The proper way would probably be to display a popup. In our code, we simply return to the main menu if loading a save game fails. We can now call these functions from <em>game_manager.gd</em>. So now, for the proper version of <code>_on_game_requested()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _on_game_requested(try_load: <span style="color:#a6e22e">bool</span>) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> game: GameRoot <span style="color:#f92672">=</span> switch_to_scene(game_scene)
	game<span style="color:#f92672">.</span>main_menu_requested<span style="color:#f92672">.</span>connect(load_main_menu)
	<span style="color:#66d9ef">if</span> try_load:
		game<span style="color:#f92672">.</span>load_game()
	<span style="color:#66d9ef">else</span>:
		game<span style="color:#f92672">.</span>new_game()
</code></pre></div><p>Depending on which button is pressed in the main menu, we now either create a new map or load an existing one. If you paid attention you might notice that nothing actually causes our game to save yet. We want to do that when exiting to the menu, meaning <em>escape_action.gd</em> is the proper spot for that:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	entity<span style="color:#f92672">.</span>map_data<span style="color:#f92672">.</span>save()
	SignalBus<span style="color:#f92672">.</span>escape_requested<span style="color:#f92672">.</span>emit()
	<span style="color:#66d9ef">return</span> false
</code></pre></div><p>Now we save the game right before we request a change back to the main menu.</p>
<p>There are a few issues that we need to tackle. First, a change to the UI. So far, we created the game and everything as within the <strong>Game</strong> node&rsquo;s <code>_ready()</code> function. The way our tree was set up meant that at that point in time not all other nodes were ready themselves. We accounted for this in <em>hp_display.gd</em>, when we called <code>await ready</code> inside <code>initialize()</code>. However, now <code>initialize()</code> gets called after the HP display is already ready. So the function ends up waiting for the <code>ready</code> signal which it already missed, i.e., the function never gets executed. We can mitigate this by extending the function as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> initialize(player: Entity) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> is_inside_tree():
		await ready
	player<span style="color:#f92672">.</span>fighter_component<span style="color:#f92672">.</span>hp_changed<span style="color:#f92672">.</span>connect(player_hp_changed)
	<span style="color:#66d9ef">var</span> player_hp: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> player<span style="color:#f92672">.</span>fighter_component<span style="color:#f92672">.</span>hp
	<span style="color:#66d9ef">var</span> player_max_hp: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> player<span style="color:#f92672">.</span>fighter_component<span style="color:#f92672">.</span>max_hp
	player_hp_changed(player_hp, player_max_hp)
</code></pre></div><p>Now we only <code>await</code> if the node is not inside the tree, i.e., is not ready yet. (Thinking about this now, after I have already written the code, this clause may be superfluous altogether, and we maybe could have just deleted <code>await ready</code>).</p>
<p>And that is the save system. If you run the game now and click on new game, then exit back to the menu, you should then be able to click on <em>Continue last game</em> and be taken back to the same map as before, with all your items still in your inventory, and so on.</p>
<p>And that concludes the saving and loading part of the tutorial. The next tutorial will be all about levels. Exploring multiple dungeon levels and leveling up your character while you&rsquo;re at it. You can find that part here: <a href="https://selinadev.github.io/15-rogueliketutorial-11/">https://selinadev.github.io/15-rogueliketutorial-11/</a></p>




      </main>
  </div>
  </body>
</html>
