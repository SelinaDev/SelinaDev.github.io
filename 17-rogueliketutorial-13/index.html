<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="generator" content="Hugo 0.92.2" />
  <link rel="canonical" href="https://selinadev.github.io/17-rogueliketutorial-13/">

  
    
    <meta name="description" content="Part 13: Gearing Up Welcome to the last part of the roguelike tutorial series. Youâ€™ve made it all the way here through the 12 previous parts. Speaking of, you can find the previous part here: https://selinadev.github.io/16-rogueliketutorial-12/
In this final part of the series we will expand our players&#39; options once more. By now they can gain XP and permanently level up their stats by slaying monsters, and they can find single-use items in the dungeon.">
  

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#000000">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" type="text/css" href="/css/paper.css">

  
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css">
  
  
    
  

  
  
  <title>Yet Another Roguelike Tutorial, Part 13 | SelinaDev</title>
</head>

  <body>
    <div class="container paper">
      <nav class="border split-nav">
  <div class="nav-brand">
    <h3><a href="/">SelinaDev</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
    <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
      
        <li><a href="/">Blog</a></li>
      
        <li><a href="/tags/">Tags</a></li>
      
        <li><a href="/about/">About</a></li>
      
      </ul>
    </div>
  </div>
</nav>
      <main>
        

<h1 class="post-title">Yet Another Roguelike Tutorial, Part 13</h1>


<strong>Publish date: </strong>Dec 17, 2023
<br>

  <strong>Tags: </strong>
  
    <a href="/tags/godot4">godot4</a>
  
    <a href="/tags/tutorial">tutorial</a>
  
    <a href="/tags/roguelike">roguelike</a>
  



  



<h1 id="part-13-gearing-up">Part 13: Gearing Up</h1>
<p>Welcome to the last part of the roguelike tutorial series. You&rsquo;ve made it all the way here through the 12 previous parts. Speaking of, you can find the previous part here: <a href="https://selinadev.github.io/16-rogueliketutorial-12/">https://selinadev.github.io/16-rogueliketutorial-12/</a></p>
<p>In this final part of the series we will expand our players' options once more. By now they can gain XP and permanently level up their stats by slaying monsters, and they can find single-use items in the dungeon. This time we will tackle equipment, allowing players to find items that will increase their stats while they wear them.</p>
<p>To start things off, we will start on a new component. Create a new script extenting <code>Component</code> at <em>res://src/Entities/Actors/Components/equippable_component.gd</em>. Here&rsquo;s the script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name EquippableComponent
<span style="color:#66d9ef">extends</span> Component

<span style="color:#66d9ef">enum</span> EquipmentType { WEAPON, ARMOR }

<span style="color:#66d9ef">var</span> equipment_type: EquipmentType
<span style="color:#66d9ef">var</span> power_bonus: <span style="color:#a6e22e">int</span>
<span style="color:#66d9ef">var</span> defense_bonus: <span style="color:#a6e22e">int</span>


<span style="color:#66d9ef">func</span> _init(definition: EquippableComponentDefinition) <span style="color:#f92672">-&gt;</span> void:
	equipment_type <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>equipment_type
	power_bonus <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>power_bonus
	defense_bonus <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>defense_bonus
</code></pre></div><p>First, we define an equipment type enum. This will correspond to the different equipment slots, so the player will be allowed to have one weapon and one armor equipped (so no dual wielding in this implementation). As you can see in the variables, each equippable item has an equipment type, and can give a bonus to power and/or defense. The <code>_init()</code> function simply initializes these values from a corresponding definition resource. Let&rsquo;s set that one up now. Create an new script extending <code>rResource</code> at <em>res://src/Entities/Actors/Components/ComponentDefinitions/equippable_component_definition.gd</em>. This script defines exported values for those three variables:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name EquippableComponentDefinition
<span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Resource</span>

<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> equipment_type: EquippableComponent<span style="color:#f92672">.</span>EquipmentType
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> power_bonus: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> defense_bonus: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</code></pre></div><p>We won&rsquo;t change these values, meaning eqippable components don&rsquo;t have state, and as such won&rsquo;t need special consideration in the save system, but should work as they are. The equippable component will work in conjunction with an equipment component, which we will code later. However, we can already think about items using that component. In our simple system an item will either have a consumable component or an equippable component. We will use the same item interaction system for equipping and unequipping we have used for consumables, so having both on an item would mean the game won&rsquo;t know if you intend to consume an item or equip it.</p>
<p>We will embed that restriction in our entity definition system, by changing the expected types of the exported variable. This will show both a strength and a weakness of Godot&rsquo;s resource system. As a first step, create a new script extending <code>Resource</code> at <em>res://src/Entities/Actors/Components/ComponentDefinitions/item_component_definition.gd</em>. Here&rsquo;s the whole script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name ItemComponentDefinition
<span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Resource</span>
</code></pre></div><p>That&rsquo;s it. Just like with the consumable definition, we only need this as a base type. Speaking of which, change <em>consumable_component_definition.gd</em> as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name ConsumableComponentDefinition
<span style="color:#66d9ef">extends</span> ItemComponentDefinition
</code></pre></div><p>Equippables are also items, so we change the top of <em>equippable_component_definition.gd</em> again right away:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name EquippableComponentDefinition
<span style="color:#66d9ef">extends</span> ItemComponentDefinition
</code></pre></div><p>Now, in <em>entity_definition.gd</em> we remove <code>consumable_defintion</code> and replace it with an <code>item_definition</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#960050;background-color:#1e0010">@</span>export_category(<span style="color:#e6db74">&#34;Components&#34;</span>)
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> fighter_definition: FighterComponentDefinition
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> ai_type: Entity<span style="color:#f92672">.</span>AIType
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> item_definition: ItemComponentDefinition
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> inventory_capacity: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> level_info: LevelComponentDefinition
</code></pre></div><p>This new variable is of type <code>ItemComponentDefinition</code>, meaning it can hold a definition for any of the consumables we have, as well as one for an equippable item. And the nice thing is that when we create a sub-resource for that variable in the inspector, we will get offered just these options (as we had with just the consumables). I really like that part of the resource system. Now, what I don&rsquo;t like is that we just lost some data. All the consumable definitions were stored in the variable <code>consumable_definition</code>, which no longer exists. Godot cannot know that we are refactoring that same information to the <code>item_definition</code> variable. Of course, we could have just changed the type of <code>consumable_definition</code>, but that name would have been misleading. The effect of this is that we have to reopen our existing item definitions and restore the component definitions we had on them previously. I&rsquo;ll quickly go over them:</p>
<p><em>confusion_scroll_definition.tres</em>:
<code>ConfusionConsumableComponentDefinition</code></p>
<table>
<thead>
<tr>
<th>property</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Number of Turns</td>
<td>10</td>
</tr>
</tbody>
</table>
<p><em>fireball_scroll_definition.tres</em>:
<code>FireballDamageConsumableComponentDefinition</code></p>
<table>
<thead>
<tr>
<th>property</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Damage</td>
<td>12</td>
</tr>
<tr>
<td>Radius</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><em>health_potion_definition.tres</em>:
<code>HealingConsumableComponentDefinition</code></p>
<table>
<thead>
<tr>
<th>property</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Healing Amount</td>
<td>4</td>
</tr>
</tbody>
</table>
<p><em>lightning_scroll_definition.tres</em>:
<code>LightningDamageConsumableComponentDefinition</code></p>
<table>
<thead>
<tr>
<th>property</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Damage</td>
<td>20</td>
</tr>
<tr>
<td>Maximum Range</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>And with that the functionality of our existing items is restored. Now let&rsquo;s create some equippable items. Save them next to the other item definitions and choose appropriate icons for them, as usual:</p>
<p><em>dagger_definition.tres</em>:</p>
<table>
<thead>
<tr>
<th>property</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Name</td>
<td>Dagger</td>
</tr>
<tr>
<td>Color</td>
<td>#7f7f7f</td>
</tr>
<tr>
<td>Is Blocking</td>
<td>false</td>
</tr>
<tr>
<td>Type</td>
<td>Item</td>
</tr>
<tr>
<td>Item Definition</td>
<td><code>EquippableComponentDefinition</code></td>
</tr>
<tr>
<td>Equipment Type</td>
<td>Weapon</td>
</tr>
<tr>
<td>Power Bonus</td>
<td>2</td>
</tr>
<tr>
<td>Defense Bonus</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><em>sword_definition.tres</em>:</p>
<table>
<thead>
<tr>
<th>property</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Name</td>
<td>Sword</td>
</tr>
<tr>
<td>Color</td>
<td>#7f7f7f</td>
</tr>
<tr>
<td>Is Blocking</td>
<td>false</td>
</tr>
<tr>
<td>Type</td>
<td>Item</td>
</tr>
<tr>
<td>Item Definition</td>
<td><code>EquippableComponentDefinition</code></td>
</tr>
<tr>
<td>Equipment Type</td>
<td>Weapon</td>
</tr>
<tr>
<td>Power Bonus</td>
<td>4</td>
</tr>
<tr>
<td>Defense Bonus</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><em>leather_armor_definition.tres</em>:</p>
<table>
<thead>
<tr>
<th>property</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Name</td>
<td>Leather Armor</td>
</tr>
<tr>
<td>Color</td>
<td>#ff7f00</td>
</tr>
<tr>
<td>Is Blocking</td>
<td>false</td>
</tr>
<tr>
<td>Type</td>
<td>Item</td>
</tr>
<tr>
<td>Item Definition</td>
<td><code>EquippableComponentDefinition</code></td>
</tr>
<tr>
<td>Equipment Type</td>
<td>Armor</td>
</tr>
<tr>
<td>Power Bonus</td>
<td>0</td>
</tr>
<tr>
<td>Defense Bonus</td>
<td>1</td>
</tr>
</tbody>
</table>
<p><em>chainmail_definition.tres</em>:</p>
<table>
<thead>
<tr>
<th>property</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Name</td>
<td>Chainmail</td>
</tr>
<tr>
<td>Color</td>
<td>#7f7f7f</td>
</tr>
<tr>
<td>Is Blocking</td>
<td>false</td>
</tr>
<tr>
<td>Type</td>
<td>Item</td>
</tr>
<tr>
<td>Item Definition</td>
<td><code>EquippableComponentDefinition</code></td>
</tr>
<tr>
<td>Equipment Type</td>
<td>Armor</td>
</tr>
<tr>
<td>Power Bonus</td>
<td>0</td>
</tr>
<tr>
<td>Defense Bonus</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>There&rsquo;s three places in our code we need to update to integrate our new shiny toys into the existing game (if only as dumb items without any functionality yet). First, open <em>entity.gd</em> and update the list of <code>entity_types</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">const</span> entity_types <span style="color:#f92672">=</span> {
	<span style="color:#e6db74">&#34;player&#34;</span>: <span style="color:#e6db74">&#34;res://assets/definitions/entities/actors/entity_definition_player.tres&#34;</span>,
	<span style="color:#e6db74">&#34;orc&#34;</span>: <span style="color:#e6db74">&#34;res://assets/definitions/entities/actors/entity_definition_orc.tres&#34;</span>,
	<span style="color:#e6db74">&#34;troll&#34;</span>: <span style="color:#e6db74">&#34;res://assets/definitions/entities/actors/entity_definition_troll.tres&#34;</span>,
	<span style="color:#e6db74">&#34;health_potion&#34;</span>: <span style="color:#e6db74">&#34;res://assets/definitions/entities/items/health_potion_definition.tres&#34;</span>,
	<span style="color:#e6db74">&#34;lightning_scroll&#34;</span>: <span style="color:#e6db74">&#34;res://assets/definitions/entities/items/lightning_scroll_definition.tres&#34;</span>,
	<span style="color:#e6db74">&#34;confusion_scroll&#34;</span>: <span style="color:#e6db74">&#34;res://assets/definitions/entities/items/confusion_scroll_definition.tres&#34;</span>,
	<span style="color:#e6db74">&#34;fireball_scroll&#34;</span>: <span style="color:#e6db74">&#34;res://assets/definitions/entities/items/fireball_scroll_definition.tres&#34;</span>,
	<span style="color:#e6db74">&#34;dagger&#34;</span>: <span style="color:#e6db74">&#34;res://assets/definitions/entities/items/dagger_definition.tres&#34;</span>,
	<span style="color:#e6db74">&#34;sword&#34;</span>: <span style="color:#e6db74">&#34;res://assets/definitions/entities/items/sword_definition.tres&#34;</span>,
	<span style="color:#e6db74">&#34;chainmail&#34;</span>: <span style="color:#e6db74">&#34;res://assets/definitions/entities/items/chainmail_definition.tres&#34;</span>,
	<span style="color:#e6db74">&#34;leather_armor&#34;</span>: <span style="color:#e6db74">&#34;res://assets/definitions/entities/items/leather_armor_definition.tres&#34;</span>,
}
</code></pre></div><p>Next, we update our spawn tables in <em>dungeon_generator.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">const</span> item_chances <span style="color:#f92672">=</span> {
	<span style="color:#ae81ff">0</span>: {<span style="color:#e6db74">&#34;health_potion&#34;</span>: <span style="color:#ae81ff">35</span>},
	<span style="color:#ae81ff">2</span>: {<span style="color:#e6db74">&#34;confusion_scroll&#34;</span>: <span style="color:#ae81ff">10</span>},
	<span style="color:#ae81ff">4</span>: {<span style="color:#e6db74">&#34;lightning_scroll&#34;</span>: <span style="color:#ae81ff">25</span>, <span style="color:#e6db74">&#34;sword&#34;</span>: <span style="color:#ae81ff">5</span>},
	<span style="color:#ae81ff">6</span>: {<span style="color:#e6db74">&#34;fireball_scroll&#34;</span>: <span style="color:#ae81ff">25</span>, <span style="color:#e6db74">&#34;chainmail&#34;</span>: <span style="color:#ae81ff">15</span>},
}
</code></pre></div><p>We will have the player spawn with a dagger and a leather armor, so we only entered the sword and chainmail. However, that&rsquo;s all the work we have to do here, our spawning system is flexible enough by now to handle the rest on its own. Swords and chainmails will now appear once the player is deep enough into the dungeon, but we&rsquo;ll need one more change in order for them to be able to pick them up. We need to expand the <code>get_items()</code> function in <em>map_data.gd</em> as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_items() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Array</span>[Entity]:
	<span style="color:#66d9ef">var</span> items: <span style="color:#a6e22e">Array</span>[Entity] <span style="color:#f92672">=</span> []
	<span style="color:#66d9ef">for</span> entity <span style="color:#f92672">in</span> entities:
		<span style="color:#66d9ef">if</span> entity<span style="color:#f92672">.</span>consumable_component <span style="color:#f92672">!=</span> null <span style="color:#f92672">or</span> entity<span style="color:#f92672">.</span>equippable_component <span style="color:#f92672">!=</span> null:
			items<span style="color:#f92672">.</span>append(entity)
	<span style="color:#66d9ef">return</span> items
</code></pre></div><p>So far it only checked for the presence of a consumable component, but now we also allow picking up entities with equippable components. You can now find and pick up equipment, but you can&rsquo;t equip it, so let&rsquo;s take care of that now. We will create a new equipment component for that. Create a new script extending <code>Component</code> at <em>res://src/Entities/Actors/Components/equipment_component.gd</em>. Here&rsquo;s the very top of it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name EquipmentComponent
<span style="color:#66d9ef">extends</span> Component

<span style="color:#66d9ef">signal</span> equipment_changed

<span style="color:#66d9ef">var</span> slots :<span style="color:#f92672">=</span> {}
</code></pre></div><p>We will later use the <code>equipment_changed</code> signal to notify our stats display when the equipment has changed, so it can update accordingly. We also have a <code>slots</code> variable that&rsquo;s currently an empty dictionary. We don&rsquo;t need to create variables for each slot, because we can just use the values of the <code>EquipmentType</code> enum as keys. As mentioned earlier that means no dual wielding, and no multiple rings and the like. You&rsquo;d need a more complex system for that. However, if you want helmets you only need to add an entry for that in <code>EquipmentType</code> and just like that the system will work for helmets as well.</p>
<p>Equipment will give boni to the power and defense stats, and the equipment component is responsible to tell us how much:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_defense_bonus() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">int</span>:
	<span style="color:#66d9ef">var</span> bonus <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
	
	<span style="color:#66d9ef">for</span> item <span style="color:#f92672">in</span> slots<span style="color:#f92672">.</span>values():
		<span style="color:#66d9ef">if</span> item<span style="color:#f92672">.</span>equippable_component:
			bonus <span style="color:#f92672">+=</span> item<span style="color:#f92672">.</span>equippable_component<span style="color:#f92672">.</span>defense_bonus
	
	<span style="color:#66d9ef">return</span> bonus


<span style="color:#66d9ef">func</span> get_power_bonus() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">int</span>:
	<span style="color:#66d9ef">var</span> bonus <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
	
	<span style="color:#66d9ef">for</span> item <span style="color:#f92672">in</span> slots<span style="color:#f92672">.</span>values():
		<span style="color:#66d9ef">if</span> item<span style="color:#f92672">.</span>equippable_component:
			bonus <span style="color:#f92672">+=</span> item<span style="color:#f92672">.</span>equippable_component<span style="color:#f92672">.</span>power_bonus
	
	<span style="color:#66d9ef">return</span> bonus
</code></pre></div><p>Both these functions simply iterate over all equipped items and add the appropriate bonus to a counter, which we then return. Next, we want to be able to know whether an item is equipped:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> is_item_equipped(item: Entity) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">return</span> item <span style="color:#f92672">in</span> slots<span style="color:#f92672">.</span>values()
</code></pre></div><p>Here we simply check if the item is part of the values of the <code>slots</code> dictionary. And now for the actual equipping and unequipping. We start with unequip:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _unequip_from_slot(slot: EquippableComponent<span style="color:#f92672">.</span>EquipmentType, add_message: <span style="color:#a6e22e">bool</span>) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> current_item <span style="color:#f92672">=</span> slots<span style="color:#f92672">.</span>get(slot)
	
	<span style="color:#66d9ef">if</span> add_message:
		MessageLog<span style="color:#f92672">.</span>send_message(<span style="color:#e6db74">&#34;You remove the </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">.&#34;</span> <span style="color:#f92672">%</span> current_item<span style="color:#f92672">.</span>get_entity_name(), <span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>WHITE)
	
	slots<span style="color:#f92672">.</span>erase(slot)
	
	equipment_changed<span style="color:#f92672">.</span>emit()
</code></pre></div><p>We get an equipment type as an argument that tells us which slot we will unequip from, as well as a boolean argument that tells us whether we want to log the unequipping to the message log (this will be useful later for both the starting equipment and the save system). Then in the function we get the current item. Note that the way we will call this function should ensure that we will only ever try to unequip from a slot that actually has an item, otherwise we should probably add checks here to abort the function if that slot does not hold an item. Next, we log the message if we specified so in the arguments and then erase the slot from the dictionary. Lastly, we emit the <code>equipment_changed</code> signal, so the ui can show the new resulting stats. Now to equipping, which has only one more step:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _equip_to_slot(slot: EquippableComponent<span style="color:#f92672">.</span>EquipmentType, item: Entity, add_message: <span style="color:#a6e22e">bool</span>) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> current_item <span style="color:#f92672">=</span> slots<span style="color:#f92672">.</span>get(slot)
	<span style="color:#66d9ef">if</span> current_item:
		unequip_from_slot(slot, add_message)
	slots[slot] <span style="color:#f92672">=</span> item
	<span style="color:#66d9ef">if</span> add_message:
		MessageLog<span style="color:#f92672">.</span>send_message(<span style="color:#e6db74">&#34;You equip the </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">.&#34;</span> <span style="color:#f92672">%</span> item<span style="color:#f92672">.</span>get_entity_name(), <span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>WHITE)
	
	equipment_changed<span style="color:#f92672">.</span>emit()
</code></pre></div><p>When we equip we don&rsquo;t know whether or not there&rsquo;s currently an item in that slot. So we first try to get it. If we don&rsquo;t have that slot, <code>slots.get()</code> will return <code>null</code>. If we do get an item, we call <code>unequip_from_slot()</code> on it. Now the slot is free, and we can enter the item we passed into the function to it. Then we can optionally log this event and, again, emit the signal. However, our interface is very minimal, and when interacting with the inventory we basically can only tell the game &ldquo;do something with this item&rdquo;. So we allow the equipment component to figure out what it has to do with an item with the following function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> toggle_equip(equippable_item: Entity, add_message: <span style="color:#a6e22e">bool</span> <span style="color:#f92672">=</span> true) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> equippable_item<span style="color:#f92672">.</span>equippable_component:
		<span style="color:#66d9ef">return</span>
	<span style="color:#66d9ef">var</span> slot: EquippableComponent<span style="color:#f92672">.</span>EquipmentType <span style="color:#f92672">=</span> equippable_item<span style="color:#f92672">.</span>equippable_component<span style="color:#f92672">.</span>equipment_type
	
	<span style="color:#66d9ef">if</span> slots<span style="color:#f92672">.</span>get(slot) <span style="color:#f92672">==</span> equippable_item:
		_unequip_from_slot(slot, add_message)
	<span style="color:#66d9ef">else</span>:
		_equip_to_slot(slot, equippable_item, add_message)
</code></pre></div><p>The <code>toggle_equip()</code> function first checks if the entity we passed it actually has an equippable component, and if not it returns early. If we have an equippable component on the item, we can retrieve the equipment type, and thereby the appropriate slot for it. We then check if the item we passed in already is in that slot. If so then the player must want to unequip it. If it is not equipped there, we equip it (and if something else is equipped there already, the <code>_equip_to_slot()</code> function will take care of unequipping that item first). Lastly, we don&rsquo;t want the player just letting go of all equipped items whenever they load the game, so we prepare the interface for our save system:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_save_data() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Dictionary</span>:
	<span style="color:#66d9ef">var</span> equipped_indices :<span style="color:#f92672">=</span> []
	<span style="color:#66d9ef">var</span> inventory: InventoryComponent <span style="color:#f92672">=</span> entity<span style="color:#f92672">.</span>inventory_component
	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> inventory<span style="color:#f92672">.</span>items<span style="color:#f92672">.</span>size():
		<span style="color:#66d9ef">var</span> item: Entity <span style="color:#f92672">=</span> inventory<span style="color:#f92672">.</span>items[i]
		<span style="color:#66d9ef">if</span> is_item_equipped(item):
			equipped_indices<span style="color:#f92672">.</span>append(i)
	<span style="color:#66d9ef">return</span> {<span style="color:#e6db74">&#34;equipped_indices&#34;</span>: equipped_indices}
</code></pre></div><p>We don&rsquo;t want to store the items directly in the equipment system, they are still in the inventory. So what we do is we get the inventory and just save the indices of all equipped items.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> restore(save_data: <span style="color:#a6e22e">Dictionary</span>) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> equipped_indices: <span style="color:#a6e22e">Array</span> <span style="color:#f92672">=</span> save_data[<span style="color:#e6db74">&#34;equipped_indices&#34;</span>]
	<span style="color:#66d9ef">var</span> inventory: InventoryComponent <span style="color:#f92672">=</span> entity<span style="color:#f92672">.</span>inventory_component
	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> inventory<span style="color:#f92672">.</span>items<span style="color:#f92672">.</span>size():
		<span style="color:#66d9ef">if</span> equipped_indices<span style="color:#f92672">.</span>any(<span style="color:#66d9ef">func</span>(index): <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">int</span>(index) <span style="color:#f92672">==</span> i):
			<span style="color:#66d9ef">var</span> item: Entity <span style="color:#f92672">=</span> inventory<span style="color:#f92672">.</span>items[i]
			toggle_equip(item, false)
</code></pre></div><p>To restore the equipment we just need to retrieve the inventory, go through it and equip all the items at the inventory indices that we retrieved. I want to point out two things here. First, note that this introduces a loading dependency, which we did not have on any component before. If you shuffle around the order in which you restore components on entities, you should still get pretty much the same entity. However, with the equipment component we need to make sure to restore the inventory component before it. Things should work as long as we remember to do that, but I wanted to point that out anyway in case you create your own components with dependencies. The second thing is the slightly odd seeming code of <code>if equipped_indices.any(func(index): return int(index) == i)</code>. Initially I tried to use <code>if i in equipped_indices</code>. However, that didn&rsquo;t work, and I assume it&rsquo;s because when loading from json it reads in all numbers as <code>float</code>. I therefore used the <code>any()</code> function, which is a function on arrays that takes in a function that returns a boolean, runs it on everything in the array, and itself returns true if any of those function calls returns true. I passed it an anonymous function here, i.e., a function I defined directly as the function argument. That function explicitly turns the stored index into an integer before comparing. So, the effect of that line is that we ask if <code>i</code> is equal to the integer value of any of the indices in <code>equipped_indices</code>. If so, we retrieve it from the inventory and equip it (without a log message).</p>
<p>That&rsquo;s the equipment component done. Our next step is to integrate it with the entity and the other affected components (i.e., the fighter component). Let&rsquo;s update our <em>entity_difinition.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#960050;background-color:#1e0010">@</span>export_category(<span style="color:#e6db74">&#34;Components&#34;</span>)
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> fighter_definition: FighterComponentDefinition
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> ai_type: Entity<span style="color:#f92672">.</span>AIType
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> item_definition: ItemComponentDefinition
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> inventory_capacity: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> level_info: LevelComponentDefinition
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> has_equipment: <span style="color:#a6e22e">bool</span> <span style="color:#f92672">=</span> false
</code></pre></div><p>We only need to know whether or not an entity should have an equipment component or not, and most entities should not have one. In fact, in our game only the player should, so we open <em>entity_definition_player.tres</em> and tick <em>Has Equipment</em>. Now to the entity itself. Open <em>entity.gd</em> and start by adding a slot for the new component:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">var</span> fighter_component: FighterComponent
<span style="color:#66d9ef">var</span> ai_component: BaseAIComponent
<span style="color:#66d9ef">var</span> consumable_component: ConsumableComponent
<span style="color:#66d9ef">var</span> equippable_component: EquippableComponent
<span style="color:#66d9ef">var</span> inventory_component: InventoryComponent
<span style="color:#66d9ef">var</span> level_component: LevelComponent
<span style="color:#66d9ef">var</span> equipment_component: EquipmentComponent
</code></pre></div><p>Next, in <code>set_entity_type()</code> we need to create it, if the definition tells us to:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">	<span style="color:#66d9ef">if</span> entity_definition<span style="color:#f92672">.</span>level_info:
		level_component <span style="color:#f92672">=</span> LevelComponent<span style="color:#f92672">.</span>new(entity_definition<span style="color:#f92672">.</span>level_info)
		add_child(level_component)
	
	
	<span style="color:#66d9ef">if</span> entity_definition<span style="color:#f92672">.</span>has_equipment:
		equipment_component <span style="color:#f92672">=</span> EquipmentComponent<span style="color:#f92672">.</span>new()
		add_child(equipment_component)
		equipment_component<span style="color:#f92672">.</span>entity <span style="color:#f92672">=</span> self
</code></pre></div><p>Lastly, the save system:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_save_data() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Dictionary</span>:
	<span style="color:#75715e"># ...</span>
	<span style="color:#66d9ef">if</span> fighter_component:
		save_data[<span style="color:#e6db74">&#34;fighter_component&#34;</span>] <span style="color:#f92672">=</span> fighter_component<span style="color:#f92672">.</span>get_save_data()
	<span style="color:#66d9ef">if</span> ai_component:
		save_data[<span style="color:#e6db74">&#34;ai_component&#34;</span>] <span style="color:#f92672">=</span> ai_component<span style="color:#f92672">.</span>get_save_data()
	<span style="color:#66d9ef">if</span> inventory_component:
		save_data[<span style="color:#e6db74">&#34;inventory_component&#34;</span>] <span style="color:#f92672">=</span> inventory_component<span style="color:#f92672">.</span>get_save_data()
	<span style="color:#66d9ef">if</span> equipment_component:
		save_data[<span style="color:#e6db74">&#34;equipment_component&#34;</span>] <span style="color:#f92672">=</span> equipment_component<span style="color:#f92672">.</span>get_save_data()
	<span style="color:#66d9ef">if</span> level_component:
		save_data[<span style="color:#e6db74">&#34;level_component&#34;</span>] <span style="color:#f92672">=</span> level_component<span style="color:#f92672">.</span>get_save_data()
	<span style="color:#66d9ef">return</span> save_data

<span style="color:#66d9ef">func</span> restore(save_data: <span style="color:#a6e22e">Dictionary</span>) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#75715e"># ...</span>
	<span style="color:#66d9ef">if</span> inventory_component <span style="color:#f92672">and</span> save_data<span style="color:#f92672">.</span>has(<span style="color:#e6db74">&#34;inventory_component&#34;</span>):
		inventory_component<span style="color:#f92672">.</span>restore(save_data[<span style="color:#e6db74">&#34;inventory_component&#34;</span>])
	<span style="color:#66d9ef">if</span> equipment_component <span style="color:#f92672">and</span> save_data<span style="color:#f92672">.</span>has(<span style="color:#e6db74">&#34;equipment_component&#34;</span>):
		equipment_component<span style="color:#f92672">.</span>restore(save_data[<span style="color:#e6db74">&#34;equipment_component&#34;</span>])
	<span style="color:#66d9ef">if</span> level_component <span style="color:#f92672">and</span> save_data<span style="color:#f92672">.</span>has(<span style="color:#e6db74">&#34;level_component&#34;</span>):
		level_component<span style="color:#f92672">.</span>restore(save_data[<span style="color:#e6db74">&#34;level_component&#34;</span>])
</code></pre></div><p>As mentioned, it is important, at least for the <code>restore()</code> function, that we restore the equipment after we are done restoring the inventory. Now, for equipment to actually have an effect, we need to account for the equipment bonus in <em>fighter.gd</em>. We change some variables:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">var</span> base_defense: <span style="color:#a6e22e">int</span>
<span style="color:#66d9ef">var</span> base_power: <span style="color:#a6e22e">int</span>
<span style="color:#66d9ef">var</span> defense: <span style="color:#a6e22e">int</span>: 
	get:
		<span style="color:#66d9ef">return</span> base_defense <span style="color:#f92672">+</span> get_defense_bonus()
<span style="color:#66d9ef">var</span> power: <span style="color:#a6e22e">int</span>: 
	get:
		<span style="color:#66d9ef">return</span> base_power <span style="color:#f92672">+</span> get_power_bonus()
</code></pre></div><p>We will use the values we previously had as <code>base_defense</code> and <code>base_power</code>. In order to minimize refactoring with the rest of the code, we still use <code>defense</code> and <code>power</code> for the results. But we use a trick. By using a get method we effectively make it so that when this property is accessed, it will return the sum of the <code>base_defense</code> or <code>base_power</code> and the corresponding bonus. Here&rsquo;s how we calculate those boni:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_defense_bonus() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">int</span>:
	<span style="color:#66d9ef">if</span> entity<span style="color:#f92672">.</span>equipment_component:
		<span style="color:#66d9ef">return</span> entity<span style="color:#f92672">.</span>equipment_component<span style="color:#f92672">.</span>get_defense_bonus()
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>


<span style="color:#66d9ef">func</span> get_power_bonus() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">int</span>:
	<span style="color:#66d9ef">if</span> entity<span style="color:#f92672">.</span>equipment_component:
		<span style="color:#66d9ef">return</span> entity<span style="color:#f92672">.</span>equipment_component<span style="color:#f92672">.</span>get_power_bonus()
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</code></pre></div><p>To calculate the bonus we check if the entity has an equipment component. If it does, we return the bonus the equipment gives. If the entity doesn&rsquo;t have a bonus, we return 0, and the entity uses just the base stat. We need to change our initialization to set the base stats now:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _init(definition: FighterComponentDefinition) <span style="color:#f92672">-&gt;</span> void:
	max_hp <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>max_hp
	hp <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>max_hp
	base_defense <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>defense
	base_power <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>power
	death_texture <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>death_texture
	death_color <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>death_color
</code></pre></div><p>We also have to change the code for saving and restoring to affect the base stats:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_save_data() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Dictionary</span>:
	<span style="color:#66d9ef">return</span> {
		<span style="color:#e6db74">&#34;max_hp&#34;</span>: max_hp,
		<span style="color:#e6db74">&#34;hp&#34;</span>: hp,
		<span style="color:#e6db74">&#34;power&#34;</span>: base_power,
		<span style="color:#e6db74">&#34;defense&#34;</span>: base_defense
	}


<span style="color:#66d9ef">func</span> restore(save_data: <span style="color:#a6e22e">Dictionary</span>) <span style="color:#f92672">-&gt;</span> void:
	max_hp <span style="color:#f92672">=</span> save_data[<span style="color:#e6db74">&#34;max_hp&#34;</span>]
	hp <span style="color:#f92672">=</span> save_data[<span style="color:#e6db74">&#34;hp&#34;</span>]
	base_power <span style="color:#f92672">=</span> save_data[<span style="color:#e6db74">&#34;power&#34;</span>]
	base_defense <span style="color:#f92672">=</span> save_data[<span style="color:#e6db74">&#34;defense&#34;</span>]
</code></pre></div><p>Now the fighter component can properly coordinate with the equipment. The last (mechanical) piece of the puzzle is a way to actually interact with equipment in the inventory. Interacting with equipment is an action, so we create a new action. For that we create a new script extending <code>Action</code> at <em>res://src/Entities/Actors/Actions/equip_action.gd</em>. Here&rsquo;s the code for that:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name EquipAction
<span style="color:#66d9ef">extends</span> Action

<span style="color:#66d9ef">var</span> _item: Entity


<span style="color:#66d9ef">func</span> _init(entity: Entity, item: Entity) <span style="color:#f92672">-&gt;</span> void:
	super<span style="color:#f92672">.</span>_init(entity)
	_item <span style="color:#f92672">=</span> item


<span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	entity<span style="color:#f92672">.</span>equipment_component<span style="color:#f92672">.</span>toggle_equip(_item)
	<span style="color:#66d9ef">return</span> true
</code></pre></div><p>You see that we return true for this action, meaning changing equipment costs a turn. Now we need a place to create this action. We already have the <code>ItemAction</code>, and just like we do in the <code>BumpAction</code> we can use that to change to another action on the fly. So we change the <code>perform()</code> function of <em>item_action.gd</em> to the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">if</span> item <span style="color:#f92672">==</span> null:
		<span style="color:#66d9ef">return</span> false
	<span style="color:#66d9ef">if</span> item<span style="color:#f92672">.</span>equippable_component:
		<span style="color:#66d9ef">return</span> EquipAction<span style="color:#f92672">.</span>new(entity, item)<span style="color:#f92672">.</span>perform()
	<span style="color:#66d9ef">return</span> item<span style="color:#f92672">.</span>consumable_component<span style="color:#f92672">.</span>activate(self)
</code></pre></div><p>If we have an equippable component, we create an <code>EquipAction</code>, perform it and return the result. One other place that should interact with the equipment is dropping items. We don&rsquo;t want to keep an item equipped that we drop. We update <em>drop_item_action.gd</em> to check if the item is equipped, and if so, we unequip it before dropping it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">if</span> item <span style="color:#f92672">==</span> null:
		<span style="color:#66d9ef">return</span> false
	<span style="color:#66d9ef">if</span> entity<span style="color:#f92672">.</span>equipment_component <span style="color:#f92672">and</span> entity<span style="color:#f92672">.</span>equipment_component<span style="color:#f92672">.</span>is_item_equipped(item):
		entity<span style="color:#f92672">.</span>equipment_component<span style="color:#f92672">.</span>toggle_equip(item)
	entity<span style="color:#f92672">.</span>inventory_component<span style="color:#f92672">.</span>drop(item)
	<span style="color:#66d9ef">return</span> true
</code></pre></div><p>With that equipping should work now, just by interacting with the inventory, same as with consumables. To test that, we can give the player some starting equipment. We create a new function in <em>game.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _add_player_start_equipment(item_key: <span style="color:#a6e22e">String</span>) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> item :<span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(null, Vector2i<span style="color:#f92672">.</span>ZERO, item_key)
	player<span style="color:#f92672">.</span>inventory_component<span style="color:#f92672">.</span>items<span style="color:#f92672">.</span>append(item)
	player<span style="color:#f92672">.</span>equipment_component<span style="color:#f92672">.</span>toggle_equip(item, false)
</code></pre></div><p>This function takes a string, then spawns an entity of that type, puts it in the player&rsquo;s inventory and then equips it (silently). We call this right after we create the player:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> new_game() <span style="color:#f92672">-&gt;</span> void:
	player <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(null, Vector2i<span style="color:#f92672">.</span>ZERO, <span style="color:#e6db74">&#34;player&#34;</span>)
	_add_player_start_equipment(<span style="color:#e6db74">&#34;dagger&#34;</span>)
	_add_player_start_equipment(<span style="color:#e6db74">&#34;leather_armor&#34;</span>)
	<span style="color:#75715e"># ...</span>
</code></pre></div><p>Now the player starts with a dagger and leather armor. If you start the game now you should be able to go into the inventory and select these items. Doing so should create messages in the message log telling you that you equipped or unequipped an item. However, our user interface has two issues at the moment. The first is that we have now way of knowing if an item is currently equipped. And the other is that the nice stats display we have below the HP and XP bars does not properly update. We will tackle these issues in that order.</p>
<p>To keep things simple we will indicate equipped items in the inventory list by marking them with &ldquo;<em>(E)</em>&rdquo;. We do this in <em>inventory_meny.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _register_item(index: <span style="color:#a6e22e">int</span>, item: Entity, is_equipped: <span style="color:#a6e22e">bool</span>) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> item_button: <span style="color:#a6e22e">Button</span> <span style="color:#f92672">=</span> inventory_menu_item_scene<span style="color:#f92672">.</span>instantiate()
	<span style="color:#66d9ef">var</span> char: <span style="color:#a6e22e">String</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">String</span><span style="color:#f92672">.</span>chr(<span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">.</span>unicode_at(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> index)
	item_button<span style="color:#f92672">.</span>text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;( </span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> ) </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> [char, item<span style="color:#f92672">.</span>get_entity_name()]
	<span style="color:#66d9ef">if</span> is_equipped:
		item_button<span style="color:#f92672">.</span>text <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34; (E)&#34;</span>
	<span style="color:#66d9ef">var</span> shortcut_event :<span style="color:#f92672">=</span> <span style="color:#a6e22e">InputEventKey</span><span style="color:#f92672">.</span>new()
	shortcut_event<span style="color:#f92672">.</span>keycode <span style="color:#f92672">=</span> KEY_A <span style="color:#f92672">+</span> index
	item_button<span style="color:#f92672">.</span>shortcut <span style="color:#f92672">=</span> Shortcut<span style="color:#f92672">.</span>new()
	item_button<span style="color:#f92672">.</span>shortcut<span style="color:#f92672">.</span>events <span style="color:#f92672">=</span> [shortcut_event]
	item_button<span style="color:#f92672">.</span>pressed<span style="color:#f92672">.</span>connect(button_pressed<span style="color:#f92672">.</span>bind(item))
	inventory_list<span style="color:#f92672">.</span>add_child(item_button)
</code></pre></div><p>The <code>_register_item()</code> function now takes an argument telling it if the item is equipped. If that&rsquo;s the case, we add our equipped marker to the end of the button&rsquo;s text. We can check in <code>build()</code> whether the items we iterate through are equipped:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> build(title_text: <span style="color:#a6e22e">String</span>, inventory: InventoryComponent) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">if</span> inventory<span style="color:#f92672">.</span>items<span style="color:#f92672">.</span>is_empty():
		button_pressed<span style="color:#f92672">.</span>call_deferred()
		MessageLog<span style="color:#f92672">.</span>send_message(<span style="color:#e6db74">&#34;No items in inventory.&#34;</span>, GameColors<span style="color:#f92672">.</span>IMPOSSIBLE)
		<span style="color:#66d9ef">return</span>
	<span style="color:#66d9ef">var</span> equipment: EquipmentComponent <span style="color:#f92672">=</span> inventory<span style="color:#f92672">.</span>entity<span style="color:#f92672">.</span>equipment_component
	title_label<span style="color:#f92672">.</span>text <span style="color:#f92672">=</span> title_text
	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> inventory<span style="color:#f92672">.</span>items<span style="color:#f92672">.</span>size():
		<span style="color:#66d9ef">var</span> item: Entity <span style="color:#f92672">=</span> inventory<span style="color:#f92672">.</span>items[i]
		<span style="color:#66d9ef">var</span> is_equipped: <span style="color:#a6e22e">bool</span> <span style="color:#f92672">=</span> equipment<span style="color:#f92672">.</span>is_item_equipped(item)
		_register_item(i, item, is_equipped)
	inventory_list<span style="color:#f92672">.</span>get_child(<span style="color:#ae81ff">0</span>)<span style="color:#f92672">.</span>grab_focus()
	show()
</code></pre></div><p>We now need to get the equipment component. Then, when we go through the items we check for each item if it&rsquo;s in the equipment, and pass that result to <code>_register_item()</code>. If you run the game now, you will see that our starting equipment is shown as equipped, and if you unequip it, that marker is no longer shown.</p>
<p>The second issue is the stats display. We handle that in <em>character_info_box.gd</em>. <code>update_labels()</code> will pull the current values, and with the way the fighter component works now, this includes boni from equipment. So we just need to tell it that in addition to level ups it also needs to update when the equipment changes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> setup(player: Entity) <span style="color:#f92672">-&gt;</span> void:
	_player <span style="color:#f92672">=</span> player
	_player<span style="color:#f92672">.</span>level_component<span style="color:#f92672">.</span>leveled_up<span style="color:#f92672">.</span>connect(update_labels)
	_player<span style="color:#f92672">.</span>equipment_component<span style="color:#f92672">.</span>equipment_changed<span style="color:#f92672">.</span>connect(update_labels)
	update_labels()
</code></pre></div><p>Unfortunately, with the way we do the starting equipment, this means that <code>update_labels()</code> would be called before the player is ready. That means we need a short check at the start of that function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> update_labels() <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> _player<span style="color:#f92672">.</span>is_inside_tree():
		await _player<span style="color:#f92672">.</span>ready
	level_label<span style="color:#f92672">.</span>text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;LVL: </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> _player<span style="color:#f92672">.</span>level_component<span style="color:#f92672">.</span>current_level
	attack_label<span style="color:#f92672">.</span>text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ATK: </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> _player<span style="color:#f92672">.</span>fighter_component<span style="color:#f92672">.</span>power
	defense_label<span style="color:#f92672">.</span>text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;DEF: </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> _player<span style="color:#f92672">.</span>fighter_component<span style="color:#f92672">.</span>defense
</code></pre></div><p>If the player isn&rsquo;t yet in the scene tree, we wait for it to be ready. And with that, the gui will update as well. If you start the game you can take off your already equipped starting equipment, and see the power and defense values update accordingly, always showing the current total.</p>
<p>And now we have equipment in our roguelike as well! That concludes this part, and with it the roguelike tutorial. I hope this was helpful to you, and I&rsquo;m proud of you if you&rsquo;ve made it this far. As before, you can find the full code of all parts in the GitHub repository: <a href="https://github.com/SelinaDev/Godot-Roguelike-Tutorial">https://github.com/SelinaDev/Godot-Roguelike-Tutorial</a></p>
<p>If you find bugs or have problems, you can use the Issues or Discussions on the GitHub repo. You can also find me on Mastodon as @selinadev@indiepocalypse.social, or can talk to me on my discord: <a href="https://discord.gg/fXBdwVGh">https://discord.gg/fXBdwVGh</a></p>




      </main>
  </div>
  </body>
</html>
