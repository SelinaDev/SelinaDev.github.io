<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="generator" content="Hugo 0.120.4">
  <link rel="canonical" href="https://selinadev.github.io/02-scene-transitions/">

  
    
    <meta name="description" content="In this tutorial I will tackle scene transitions in three steps of complexity. The first will be a simple fade to black. The second will use a wipe to black based on a shader, and the third and final one will be a wipe from one scene directly to the other.
Dummy Assets To make this visually somewhat appealing I will be using the following two photographs by Peter Janzen for this tutorial.">
  

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#000000">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" type="text/css" href="/css/paper.css">

  
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css">
  
  
    
  

  
  
  <title>Godot 3 Tutorial: Scene Transitions | SelinaDev</title>
</head>

  <body>
    <div class="container paper">
      <nav class="border split-nav">
  <div class="nav-brand">
    <h3><a href="/">SelinaDev</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
    <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
      
        <li><a href="/">Blog</a></li>
      
        <li><a href="/tags/">Tags</a></li>
      
        <li><a href="/about/">About</a></li>
      
      </ul>
    </div>
  </div>
</nav>
      <main>
        

<h1 class="post-title">Godot 3 Tutorial: Scene Transitions</h1>


<strong>Publish date: </strong>Feb 19, 2022
<br>

  <strong>Tags: </strong>
  
    <a href="/tags/godot3">godot3</a>
  
    <a href="/tags/tutorials">tutorials</a>
  



  

<div class="child-borders">
  <div class="toc border" aria-labelledby="toc-heading">
    <h2 id="toc-heading">Table of contents</h2>
    <ol>
      
        <li>
          
          
          
          
          <a href="#dummy-assets">
            Dummy Assets
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#preparation">
            Preparation
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#fade-to-black">
            Fade to Black
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#complex-transition-to-black">
            Complex Transition to Black
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#complex-transition-directly-to-the-next-scene">
            Complex Transition directly to the Next Scene
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#conclusion">
            Conclusion
          </a>
        </li>
      
    </ol>
  </div>
</div>



<p>In this tutorial I will tackle scene transitions in three steps of complexity. The first will be a simple fade to black. The second will use a wipe to black based on a shader, and the third and final one will be a wipe from one scene directly to the other.</p>
<h2 id="dummy-assets">Dummy Assets</h2>
<p>To make this visually somewhat appealing I will be using the following two photographs by Peter Janzen for this tutorial.</p>








  


<div class="card row flex-center" style="">
  <a href="/02-scene-transitions/red-orange-rose-in-detail.jpg" class="img-link">
    <img src="/02-scene-transitions/red-orange-rose-in-detail_hu2efab5e3a3f81b69fe238d4d94e7406a_4086038_900x0_resize_q99_box.jpg">
  </a>
  <div class="card-body">
  
    <h4 class="card-title">Red-orange rose in detail</h4>
  
  
  
    <p class="card-text">Photo by Peter Janzen (<a href="https://cc0.photo/2015/11/06/red-orange-rose-in-detail/">https://cc0.photo/2015/11/06/red-orange-rose-in-detail/</a>)</p>
  
  </div>
</div>








  


<div class="card row flex-center" style="">
  <a href="/02-scene-transitions/single-apple-blossom.jpg" class="img-link">
    <img src="/02-scene-transitions/single-apple-blossom_hud26f3182b8777e25f7091479b260420e_5154698_900x0_resize_q99_box.jpg">
  </a>
  <div class="card-body">
  
    <h4 class="card-title">Single apple blossom</h4>
  
  
  
    <p class="card-text">Photo by Peter Janzen (<a href="https://cc0.photo/2015/11/06/red-orange-rose-in-detail/">https://cc0.photo/2015/11/06/red-orange-rose-in-detail/</a>)</p>
  
  </div>
</div>
<p>I also use a luma trasition texture as they are common in video editing. The one you can download from the mentioned link is in a file format Godot cannot use, but it can be opened in GIMP and saved as PNG there.</p>








  


<div class="card row flex-center" style="">
  <a href="/02-scene-transitions/horiz_paint_brush.png" class="img-link">
    <img src="/02-scene-transitions/horiz_paint_brush_hu864f9424739404e31ff2364a66e4fe42_552407_900x0_resize_box_3.png">
  </a>
  <div class="card-body">
  
    <h4 class="card-title">Horizontal Paint Brush Wipe</h4>
  
  
  
    <p class="card-text">Luma texture by <a href="https://store.kde.org/u/roxanep">Roxanep</a>, found at <a href="https://store.kde.org/p/1675120">https://store.kde.org/p/1675120</a>, licensed under <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution</a></p>
  
  </div>
</div>
<p>You can find all assets, scenes and finished code in the GitHub repository accompanying this tutorial: <a href="https://github.com/SelinaDev/02_Scene_Transitions">https://github.com/SelinaDev/02_Scene_Transitions</a></p>
<h2 id="preparation">Preparation</h2>
<p>If you are following along let me go over the initial setup I have, so you can work from the same starting point as I. I first created a folder called <em>assets</em>, where I put the three pictures shown above. Next I created a folder I called <em>example_scenes</em>. This folder will hold a few common files.</p>
<p>So let&rsquo;s start populating this folder. Create a new scene, and as root node we choose &ldquo;Other Node&rdquo; and then choose a <code>TextureRect</code>. We will call it <em>Background1</em>, and save it under <em>res://example_scenes/Background1.tscn</em>. Now we click on the <em>Layout</em> button (the last option in the top bar) and select <em>Full Rect</em>, so it will cover the screen. Drag the <em>Red-orange-rose-in-detail.jpg</em> into the <em>Texture</em> slot in the Inspector, check <em>Expand</em> there, and set the <em>Stretch Mode</em> to <em>Keep Aspect Covered</em>. Next do the same with the other image and save that as <em>Background2.tscn</em> at the same location.</p>
<p>Next, in order to keep this more compact I want to create a reusable script for all the scenes. So we create a script called <em>Scene.gd</em> in <em>example_scenes</em> as well, and fill it with the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Control</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">signal</span> <span style="color:#a6e22e">scene_change_requested</span>(next_scene)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export (<span style="color:#a6e22e">String</span>, FILE, <span style="color:#e6db74">&#34;*.tscn&#34;</span>) <span style="color:#66d9ef">var</span> next_scene
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_process</span>(_delta: <span style="color:#66d9ef">float</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span><span style="color:#a6e22e">is_action_just_pressed</span>(<span style="color:#e6db74">&#34;ui_accept&#34;</span>):
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">emit_signal</span>(<span style="color:#e6db74">&#34;scene_change_requested&#34;</span>, next_scene)
</span></span></code></pre></div><p>The <code>export</code> will allow us to select a next scene to transition to for each of
the scenes. Once we press the <em>ui_accept</em> action (which is per default mapped to the space bar as well as the enter key), the scene will emit a signal that will tell the nodes responsible for the scene transitions that they should change the scene, and where to.</p>
<p>With that out of the way, let us move on to the actual scene transitions.</p>
<h2 id="fade-to-black">Fade to Black</h2>
<p>This first one is a popular choice, and very simple. I also want to point out that this is only adapted from another tutorial. This is how I learned it initially from this GDQuest Tutorial by Henrique Campos: <a href="https://www.gdquest.com/tutorial/godot/2d/scene-transition-rect/">https://www.gdquest.com/tutorial/godot/2d/scene-transition-rect/</a>
I am using a slightly adapted version of that one, with the main difference being that I will use a Tween node instead of an AnimationPlayer (I am just really into parametric procedural animations).</p>
<p>So, to stay organized let us first create a folder called <em>Stage1</em> in the project&rsquo;s root directory. Now we create a new scene, choose &ldquo;Other Node&rdquo; as root again and now choose a <code>CanvasLayer</code> node as root node, which we will call <em>SceneChanger1</em> (Usually I would just call it <em>SceneChanger</em>, but as I will show you multiple variants of these I will keep them distinct by numbering them for the sake of the tutorial). Set its <em>Layer</em> property to something high, like 100, so that it will be on top even if the scenes we attach it to use their own <code>CanvasLayer</code> nodes. We also add two children to it, a <code>ColorRect</code> and a <code>Tween</code>. Select the <code>ColorRect</code> node and again click <em>Layout</em> &gt; <em>Full Rect</em>, and set its color to black. Save this scene at <em>res://Stage1/SceneChanger1.tscn</em>.</p>
<p>Now we add a script to the <em>SceneChanger1</em> node, and call it <em>SceneChanger1.gd</em>. We will use the following script for the first version of this scene changer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">class_name</span> <span style="color:#a6e22e">SceneChanger1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">CanvasLayer</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export (<span style="color:#a6e22e">String</span>, FILE, <span style="color:#e6db74">&#34;*.tscn&#34;</span>) <span style="color:#66d9ef">var</span> target_scene
</span></span><span style="display:flex;"><span>export (<span style="color:#66d9ef">float</span>) <span style="color:#66d9ef">var</span> fade_duration <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0.5</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> color_rect: <span style="color:#a6e22e">ColorRect</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$ColorRect</span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> tween: <span style="color:#a6e22e">Tween</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$Tween</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_ready</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">interpolate_property</span>(color_rect, <span style="color:#e6db74">&#34;modulate:a&#34;</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, fade_duration)
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">interpolate_callback</span>(color_rect, fade_duration, <span style="color:#e6db74">&#34;hide&#34;</span>)
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">transition_to</span>(_next_scene <span style="color:#f92672">:=</span> target_scene) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	color_rect<span style="color:#f92672">.</span><span style="color:#a6e22e">show</span>()
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">interpolate_property</span>(color_rect, <span style="color:#e6db74">&#34;modulate:a&#34;</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, fade_duration)
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">yield</span>(tween, <span style="color:#e6db74">&#34;tween_all_completed&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">get_tree</span>()<span style="color:#f92672">.</span><span style="color:#a6e22e">change_scene</span>(_next_scene)
</span></span></code></pre></div><p>We export two variables. The <code>target_scene</code> is a default scene the scene changer should change to. We will not use it in this tutorial, as the scenes will tell the node what the next scene will be. But this can be useful if you for example have multiple menus, like a settings menu, that will only transition back to the main menu. In such a case you could set the scene changer itself to transition to the main menu, and then connect the &ldquo;back&rdquo; button&rsquo;s &ldquo;pressed&rdquo; signal directly to the scene changer&rsquo;s <code>transition_to()</code> method, without the need for any extra scripts.</p>
<p>The other exported variable is the <em>fade_duration</em>. This will be the duration of one fade, so the total scene change from starting to fade out to finishing fading in on the new scene will take twice that duration (plus loading time of the scene).</p>
<p>The <code>_ready()</code> function will create a fade-in. As this node will be attached to another scene, and therefore be loaded together with it, this will take care of the fade in part. The fade-in consists of the <code>Tween</code> node animating the alpha channel <code>ColorRect</code>&rsquo;s modulate property from 1 to 0, i.e., from fully opaque to fully transparent. The tween will also call <code>hide()</code> on the <code>ColorRect</code> after the fade is complete, using <code>interpolate_callback()</code>. The reason is that the <code>ColorRect</code> will block mouse inputs if it is drawn on top of everything. the original GDQuest tutorial sets it up in a way that it will not, but I like if the player cannot interact with the scene while it is fading, so I let it block, but then hide it after the fade, so it will let mouse input through. It is up to you which variant you prefer.</p>
<p>The <code>transition_to()</code> function starts by doing the same fade in the opposite direction, so immediately showing the <code>ColorRect</code> again, then animating its modulate color&rsquo;s alpha channel from 0 to 1. Afterward the function halts execution until the <code>Tween</code> is done using <code>yield(tween, &quot;tween_all_completed&quot;)</code>. Once the tween is done and execution resumes we change the scene to the target scene as our last step.</p>
<p>The first scene changer is now complete, so let us put together some scenes to use it. Create a new scene with a <code>Control</code> node as root node and rename it to <em>Scene1</em>. Instance both <em>Background1.tscn</em> and <em>SceneChanger1.tscn</em> as child nodes. Add our <em>Scene.gd</em> script to the root node. Now save this at <em>res://Stage1/Scene1.tscn</em>. Let us also create a <em>Scene2</em>, using <em>Background2.tscn</em> instead, and save it at <em>res://Stage1/Scene2.tscn</em>. Once you have saved both of them you can go into each of them, select the root node and set its <em>next_scene</em> property to the opposite scene (so <em>Scene1</em>&rsquo;s next scene is <em>Scene2</em> and <em>Scene2</em>&rsquo;s next scene is <em>Scene1</em>). This way we can change scenes back and forth for this example.</p>
<p>Now we are ready for a test run. Make sure you have <em>Scene 1</em> selected, then click on <em>Play Scene</em> (or press F6). You should see the first scene fading in. Once you press space, it should fade out, and the other scene fade in. You can do this back and forth. With this working, let us see how we can replace this simple fade to black with something more visually interesting.</p>
<p><img src="transition_1.gif" alt="Fade Transition"></p>
<h2 id="complex-transition-to-black">Complex Transition to Black</h2>
<p>There are several ways to make a transition to or from black more interesting. You could get some geometric effects completely in a shader, but we will take inspiration from video editing and use a luma texture, a texture encoding the transition as a grayscale image. I will use a texture from <a href="https://store.kde.org/browse?cat=185&amp;ord=latest">https://store.kde.org/browse?cat=185&amp;ord=latest</a>. If you get one from there make sure you convert it to a file format usable by Godot, like PNG.</p>
<p>The texture encodes the progression of the transition as varying grayscale values. To make use of them we need a way to translate how far along we are in the transition to wheter or not a certain pixel should be transparent. We can do this using a shader. But first for our setup.</p>
<p>Let us start off by creating a new folder called <em>Stage2</em> alongside <em>Stage1</em> to keep things tidy. This scene changer will work very similarly to <em>SceneChanger1.tscn</em>, so duplicate it and rename the duplicate <em>SceneChanger2.tscn</em> and move it into the <em>Stage2</em> folder. Now open <em>SceneChanger2.tscn</em>, and also rename the root node to <em>SceneChanger2</em>. Let us first take care of the shader. Click on <code>ColorRect</code>, then in the Inspector under <em>Material</em> create a <em>New Shader Material</em> in the <em>Material</em> property. In there create a <em>New Shader</em> in the <em>Shader</em> property. Clicking on that shader should open the shader editor at the bottom of the screen. There we input the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span>shader_type canvas_item;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uniform</span> <span style="color:#66d9ef">sampler2D</span> transition_effect;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uniform</span> <span style="color:#66d9ef">float</span> progress<span style="color:#f92672">:</span> hint_range(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uniform</span> <span style="color:#66d9ef">bool</span> invert <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> fragment() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">float</span> transition_value <span style="color:#f92672">=</span> texture(transition_effect, UV).r;
</span></span><span style="display:flex;"><span>	COLOR.a <span style="color:#f92672">=</span> <span style="color:#66d9ef">float</span>(transition_value <span style="color:#f92672">&lt;=</span> progress) <span style="color:#f92672">*</span> <span style="color:#66d9ef">float</span>(<span style="color:#f92672">!</span>invert) <span style="color:#f92672">+</span> <span style="color:#66d9ef">float</span>(transition_value <span style="color:#f92672">&gt;</span> progress) <span style="color:#f92672">*</span> <span style="color:#66d9ef">float</span>(invert);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The first line declares this as a <code>canvas_item</code> shader, as we are using 2D. Then we create three <code>uniform</code> variables. If you are unfamiliar with shaders, you can think of these as similar to exported variables in GDScript, so we can edit them from outside the shader, even from the editor. The <code>transition_effect</code> is a <code>sampler2D</code>, so a texture. This is where we will put the luma. <code>progress</code> is a value that will go from 0 to 1, indicating the animation progress. The last is a boolean variable called <code>invert</code>. While we could just reverse the animation for the fade-in, I felt that it looked better if we do the animation in the same direction twice, meaning for one direction we need to invert the meaning of the color values.</p>
<p>The fragment function, which runs for each pixel, will first get the value of the corresponding pixel from the luma texture. As it is grayscale we do not need all the channels, but can just use one to get the brightness of that pixel.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span>COLOR.a <span style="color:#f92672">=</span> <span style="color:#66d9ef">float</span>(transition_value <span style="color:#f92672">&lt;=</span> progress) <span style="color:#f92672">*</span> <span style="color:#66d9ef">float</span>(<span style="color:#f92672">!</span>invert) <span style="color:#f92672">+</span> <span style="color:#66d9ef">float</span>(transition_value <span style="color:#f92672">&gt;</span> progress) <span style="color:#f92672">*</span> <span style="color:#66d9ef">float</span>(invert);
</span></span></code></pre></div><p>This last line might seem a bit complicated, but it is actually just a conditional statement converted to math. The graphics card is not good at if-else-statements, so while we can use them in shaders it is good practice to avoid them if there is an alternative. This shader will do a hard edge, so we want to set the rendered alpha to either 0 or 1 in this line. We have two terms, one for the regular, non-inverted case, and one for the inverted case. <code>float(invert)</code> will evaluate to a <code>float</code> with the value 0 if <code>invert</code> is <code>false</code> and to 1 if it is <code>true</code>. <code>float(!invert)</code> will do the opposite. So if <code>invert</code> is set to <code>false</code> then the left term will be multiplied with a 1 (i.e., will not change), and the right term will be multiplied with a 0 (i.e., will be 0 overall and not contribute to the addition).</p>
<p>This means depending on whether or not the animation is inverted, we either check if the progress value is above the pixel&rsquo;s brightness (<code>float(transition_value &lt;= progress)</code>) or if it is lower (<code>float(transition_value &gt; progress)</code>) respectively. This check will also be converted to a <code>float</code> that is either 0 or 1.</p>
<p>With this, the transition shader is complete. Click on the <code>ColorRect</code> node again, navigate to the <em>Material</em> property, where under the shader itself should now be a category <em>Shader Param</em>, which we open. Here we find the <code>uniform</code> variables from the shader&rsquo;s code. Drag <em>horiz_paint_brush.png</em> from the <em>assets</em> folder into the slot of <em>Transition Effect</em>. Once this is done you can play around with the progress slider should already see the black <code>ColorRect</code> appear or disappear in a wiping motion. With the shader complete let us adapt the scene changer&rsquo;s code to properly drive it.</p>
<p>On the <em>SceneChanger2</em> first detach the script then create a new script at <em>res://Stage2/SceneChanger2.tscn</em>. This script will be similar to the previous one but different enough that I will go over it here once more. Here is the code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">class_name</span> <span style="color:#a6e22e">SceneChanger2</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">CanvasLayer</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export (<span style="color:#a6e22e">String</span>, FILE, <span style="color:#e6db74">&#34;*.tscn&#34;</span>) <span style="color:#66d9ef">var</span> target_scene
</span></span><span style="display:flex;"><span>export (<span style="color:#66d9ef">float</span>) <span style="color:#66d9ef">var</span> fade_duration <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1.5</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> color_rect: <span style="color:#a6e22e">ColorRect</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$ColorRect</span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> tween: <span style="color:#a6e22e">Tween</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$Tween</span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> shader_material: <span style="color:#a6e22e">ShaderMaterial</span> <span style="color:#f92672">=</span> color_rect<span style="color:#f92672">.</span>material
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_ready</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	shader_material<span style="color:#f92672">.</span><span style="color:#a6e22e">set_shader_param</span>(<span style="color:#e6db74">&#34;invert&#34;</span>, <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>	shader_material<span style="color:#f92672">.</span><span style="color:#a6e22e">set_shader_param</span>(<span style="color:#e6db74">&#34;progress&#34;</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">interpolate_method</span>(self, <span style="color:#e6db74">&#34;_set_progress&#34;</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, fade_duration)
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">interpolate_callback</span>(color_rect, fade_duration, <span style="color:#e6db74">&#34;hide&#34;</span>)
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">transition_to</span>(_next_scene <span style="color:#f92672">:=</span> target_scene) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	color_rect<span style="color:#f92672">.</span><span style="color:#a6e22e">show</span>()
</span></span><span style="display:flex;"><span>	shader_material<span style="color:#f92672">.</span><span style="color:#a6e22e">set_shader_param</span>(<span style="color:#e6db74">&#34;invert&#34;</span>, <span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span>	shader_material<span style="color:#f92672">.</span><span style="color:#a6e22e">set_shader_param</span>(<span style="color:#e6db74">&#34;progress&#34;</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">interpolate_method</span>(self, <span style="color:#e6db74">&#34;_set_progress&#34;</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, fade_duration)
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">yield</span>(tween, <span style="color:#e6db74">&#34;tween_all_completed&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">get_tree</span>()<span style="color:#f92672">.</span><span style="color:#a6e22e">change_scene</span>(_next_scene)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_set_progress</span>(progress: <span style="color:#66d9ef">float</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	shader_material<span style="color:#f92672">.</span><span style="color:#a6e22e">set_shader_param</span>(<span style="color:#e6db74">&#34;progress&#34;</span>, progress)
</span></span></code></pre></div><p>First thing to mention is that we have a new <code>onready</code> variable, which caches a reference to the shader material, which we will use to set the shader&rsquo;s parameters. Next I want to mention the new <code>_set_progress()</code> function at the bottom of the script. To set the shader&rsquo;s parameters we need to call <code>shader_material.set_shader_param(param, value)</code>, meaning the parameter&rsquo;s name needs to be the first argument, and the target value the second. The <code>Tween</code>&rsquo;s <code>interpolate_method()</code> will however only work on methods that take one value. We therefore wrap the <code>set_shader_param()</code> call in a method that does just that, so we can use it with the <code>Tween</code>.</p>
<p>The <code>_ready()</code> and <code>transition_to()</code> functions work mostly the same. As shaders are a <code>Resource</code> and their values are therefore shared / persistent across scenes we need to make sure to directly set them at the start of the animation, otherwise we may get flickering issues where we see the shader in an old state for a frame. Other than that we can simply animate the progress from 0 to 1 by using <code>interpolate_method()</code> on <code>_set_progress()</code>.</p>
<p>With the scene changer finished let us build some test scenes again. This will be fairly similar to Stage 1. We create a new scene with a <code>Control</code> node as root, called <em>Scene1</em>. Again we add <em>Background1.tscn</em> and this time our new <em>SceneChanger2.tscn</em> as children. We add <em>Scene.gd</em> to <em>Scene1</em> and save it at <em>res://Stage2/Scene1.tscn</em>. We also do the same for a <em>Scene2</em> with <em>Background2</em>. Once both are saved we can set each scene&rsquo;s <em>Next Scene</em> property to its respective opposite. With that done we make sure we are in <em>Scene1</em> and click <em>Play Scene</em> again (or press F6). You should now see a scene fairly similar to the previous scene transition demo, but with the new transition effect.</p>
<p>This transition is hopefully even more appealing than the simple one, and arguably more flexible, as you can use it with any luma. If you experiment a bit you could also write your own shader to procedurally create a transition based on geometric shapes (like in the old Pokémon games). Such a shader can have the benefit of better scaling to various different aspect ratios. So you&rsquo;d want to use a shader if, for example, you want to have squares in your transition, as a texture based shader would distort those (at least without some additional shader magic). Now that we have this more complex transition the next step I will show you is a direct transition without the immediate blank screen. Due to the complexity we will need a slightly different approach than for the last two.</p>
<p><img src="transition_2.gif" alt="Wipe Transition"></p>
<h2 id="complex-transition-directly-to-the-next-scene">Complex Transition directly to the Next Scene</h2>
<p>Both these previous two scene transitions have the fade to back (or a color of your choice) in common. This makes it easy to mask the actual scene change in the middle of the transition. Depending on your system and the size of the scene you&rsquo;re loading you might experience a bit of a delay, i.e., the transition takes longer than just the time for fade out and fade in, due to the added time of loading the scene. However, I would argue that unless it takes a long time (more than ten seconds or so), then players will understand that this visual language as an indicator for loading a new scene, so we should be good. What also makes these previous two transitions useful is the way we can just attach them to existing scenes and have everything work.</p>



  


<div class="child-borders">
  <div class="sm col border-dotted">
    This next, direct transition will not only need a way of two scenes coexisting, but will require us to load one scene while the other is still visible and playing. The loading of the new scene and rendering and processing of two scenes at once can potentially create some noticeable lag, so you will have to make a decision on when to use this kind of transition. If you face these issues you can still try to mitigate them with techniques like loading the next scene in the background in advance, but that goes beyond the topic of this tutorial (you can look into the official documentation for how <a href="https://docs.godotengine.org/en/stable/tutorials/io/background_loading.html">background loading</a> works).
  </div>
</div>

<p>As mentioned above we need a way to have both scenes coexist. Furthermore, in order to transition from one scene to the other we need a way to manipulate the final render of one scene. For these reasons we will create a scene manager that will hold our scenes in <code>Viewport</code> nodes, which will also allow us to switch between arbitrary scenes without complications (e.g., we can switch from a 2D to a 3D scene).</p>
<p>So let us create a new scene, choose <em>Other Node</em> as base and select a plain <em>Node</em>, which we rename to <em>SceneManager</em>. We create three children: a <code>ViewportContainer</code> which we call <em>BackLayer</em>, another one which we call <em>FrontLayer</em>, and lastly a <em>Tween</em>. For both <code>ViewportContainer</code>s we select <em>Layout</em> &gt; <em>Full Rect</em>, and make sure the <em>Stretch</em> property is checked. Then we add one <code>Viewport</code> as a child of each <code>ViewportContainer</code>. The only thing we change in our case is to set the property <em>Rendering</em> &gt; <em>Usage</em> to <em>2D</em> on each of the <code>Viewports</code>. Lastly, we add a <code>ColorRect</code> to the <em>FrontLayer</em>&rsquo;s <code>Viewport</code>, set its color to black, and set the <em>Right</em> and <em>Bottom</em> <em>Anchor</em> properties to 1 (this is equivalent to setting the <em>Layout</em> to <em>Full Rect</em>, which Godot does not give us the option to do directly in this case).</p>
<p><img src="SceneManager_SceneTree.png" alt="Node tree of the Scene Manager"></p>
<p>Save the <em>SceneManager</em> at <em>res://Stage3/SceneManager.tscn</em>. Again we will need to create a shader. Go to the <em>FrontLayer</em>&rsquo;s <em>Material</em> property, and again add a mew <em>ShaderMaterial</em>. Create a <em>New Shader</em> in its <em>Shader</em> property. This shader works very similar to the last one, but as we do not need to reverse any fade, but do the transition all at once we do not need to invert anything anymore. So here is the code for this next shader:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span>shader_type canvas_item;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uniform</span> <span style="color:#66d9ef">sampler2D</span> transition_effect;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uniform</span> <span style="color:#66d9ef">float</span> progress<span style="color:#f92672">:</span> hint_range(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> fragment() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">float</span> transition_value <span style="color:#f92672">=</span> texture(transition_effect, UV).r;
</span></span><span style="display:flex;"><span>	COLOR.rgb <span style="color:#f92672">=</span> texture(TEXTURE, UV).rgb;
</span></span><span style="display:flex;"><span>	COLOR.a <span style="color:#f92672">=</span> <span style="color:#66d9ef">float</span>(transition_value <span style="color:#f92672">&gt;=</span> progress);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>One addition is that we need to read out the rendered texture and manually set the rgb components of the rendered color. Clich on the <em>FrontLayer</em> node again, navigate to the <em>Material</em> and open the <em>ShaderParam</em> category. Here, we need to drag the luma texture into the slot of <em>Transition Effect</em> again. Now save the scene again  let us add a script to the <em>SceneManager</em>, which we will save at <em>res://Stage3/SceneManager.gd</em>. While it is not terribly long it needs some explanation, so I will go through it step by step. The top of the script starts with the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">class_name</span> <span style="color:#a6e22e">SceneManager</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Node</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export (<span style="color:#a6e22e">String</span>, FILE, <span style="color:#e6db74">&#34;*.tscn&#34;</span>) <span style="color:#66d9ef">var</span> start_scene
</span></span><span style="display:flex;"><span>export (<span style="color:#66d9ef">float</span>) <span style="color:#66d9ef">var</span> duration <span style="color:#f92672">:=</span> <span style="color:#ae81ff">2.0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> back_viewport: <span style="color:#a6e22e">Viewport</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$BackLayer/Viewport</span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> front_viewport: <span style="color:#a6e22e">Viewport</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$FrontLayer/Viewport</span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> front_scene: <span style="color:#a6e22e">Node</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$FrontLayer/Viewport/ColorRect</span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> shader_material: <span style="color:#a6e22e">ShaderMaterial</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$FrontLayer</span><span style="color:#f92672">.</span>material
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> tween: <span style="color:#a6e22e">Tween</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$Tween</span>
</span></span></code></pre></div><p>The way this will work is that we will add a new scene to the <code>back_viewport</code>, then make the <em>FrontLayer</em> gradually transparent via its <code>shader_material</code>, animating it with the <code>tween</code>. Once that is done, we remove the old <code>front_scene</code> from the <code>front_viewport</code>, move the new scene there and save in in <code>front_scene</code>, so we can insert another scene behind it for the next transition (and we cache it so we can easily queue it free later). In order to allow us to add any scene, regardless of 2D, 3D, or even with some other node as root, we use <code>Node</code> as type hint for <code>front_scene</code>.</p>
<p>We need to set this system up with an initial state. We do two things for this. As there is no scene to request a next scene we <code>export</code> a path to an initial scene. Also, we do not have a proper scene to transition away from. This is what the <code>ColorRect</code> is for, and why we are caching it in <code>front_scene</code>. When we start this <em>Scene Manager</em> the screen will be the color of the <code>ColorRect</code>. The <code>start_scene</code> will then be loaded and be revealed behind the <code>ColorRect</code>. Now let us look at the meat of this script, the <code>_change_scene()</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_change_scene</span>(next_scene: <span style="color:#a6e22e">String</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> back_scene: <span style="color:#a6e22e">Node</span> <span style="color:#f92672">=</span> load(next_scene)<span style="color:#f92672">.</span><span style="color:#a6e22e">instance</span>()
</span></span><span style="display:flex;"><span>	back_viewport<span style="color:#f92672">.</span><span style="color:#a6e22e">add_child</span>(back_scene)
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">interpolate_method</span>(self, <span style="color:#e6db74">&#34;_set_transition_progress&#34;</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, duration)
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">yield</span>(tween, <span style="color:#e6db74">&#34;tween_all_completed&#34;</span>)
</span></span><span style="display:flex;"><span>	back_viewport<span style="color:#f92672">.</span><span style="color:#a6e22e">remove_child</span>(back_scene)
</span></span><span style="display:flex;"><span>	front_scene<span style="color:#f92672">.</span><span style="color:#a6e22e">queue_free</span>()
</span></span><span style="display:flex;"><span>	front_scene <span style="color:#f92672">=</span> back_scene
</span></span><span style="display:flex;"><span>	front_viewport<span style="color:#f92672">.</span><span style="color:#a6e22e">add_child</span>(front_scene)
</span></span><span style="display:flex;"><span>	shader_material<span style="color:#f92672">.</span><span style="color:#a6e22e">set_shader_param</span>(<span style="color:#e6db74">&#34;progress&#34;</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	front_scene<span style="color:#f92672">.</span><span style="color:#a6e22e">connect</span>(<span style="color:#e6db74">&#34;scene_change_requested&#34;</span>, self, <span style="color:#e6db74">&#34;_change_scene&#34;</span>)
</span></span></code></pre></div><p>This function directly implements the process detailed above. We load the next scene as <code>back_scene</code> and add it as a child of <code>back_viewport</code>. We then interpolate the method <code>_set_transition_progress</code> (which we still have to write, so do not worry if you get an error at this point) from 0 to 1 over our exported <code>duration</code>. We then wait for the tween to finish using <code>yield</code>. After the transition is complete, we know that the <code>front_scene</code> is no longer visible, so now we can make the switch. We remove the <code>back_scene</code> from the <code>back_viewport</code> again, and <code>queue_free()</code> the current <code>front_scene</code>. We save the new scene, stored in <code>back_scene</code> as the new <code>front_scene</code> and insert it as child of the <code>front_viewport</code>. At this point the <code>front_viewport</code> is not visible, so we have to set the <code>shader_material</code>&rsquo;s <em>progress</em> parameter to 0 again, making it visible again with our new scene. All this is happening within a single frame, so we do not need to worry that this will cause any flickering. The last thing to do is to set up the next transition. For this we expect our scenes to implement a <em>scene_change_requested</em> <code>signal</code> that gives us the path of the next scene. We <code>connect()</code> this signal directly to the <code>_change_scene()</code> function.</p>
<p>The only thing left in this script now are the following two functions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_ready</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	shader_material<span style="color:#f92672">.</span><span style="color:#a6e22e">set_shader_param</span>(<span style="color:#e6db74">&#34;progress&#34;</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_change_scene</span>(start_scene)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_set_transition_progress</span>(progress: <span style="color:#66d9ef">float</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	shader_material<span style="color:#f92672">.</span><span style="color:#a6e22e">set_shader_param</span>(<span style="color:#e6db74">&#34;progress&#34;</span>, progress)
</span></span></code></pre></div><p>The <code>_ready()</code> function simply ensures that the shader starts off in the right state, and then transitions to the first scene. The <code>_set_transition_progress()</code> works exactly like described in the last transition.</p>
<p>We now have the <em>SceneManager</em> completed and ready to go. We only need some scenes to fill it, so we will create some demo scenes again. You are probably familiar with this by now. Create a new scene with a <code>Control</code> node as root and name that <em>Scene1</em>. Drop in <em>Background1.tscn</em> as its child, and <em>Scene.gd</em> as script. Then save it at <em>res://Stage3/Scene1.tscn</em>. Do the same again but name it <em>Scane2</em>, use <em>Background2.tscn</em> as child and save it at the same location but as <em>Scene2.tscn</em>. Once both are saved select each scene&rsquo;s counterpart as its <em>Next Scene</em> property, then go back to the <em>SceneManager</em> scene and set the new <em>Scene1.tscn</em> as the start scene. Save all the scenes. The scenes should now be set up. This time we do not start the demo from <em>Scene1</em>, but from the <em>SceneManager</em>. So select it, and click <em>Play Scene</em> (or press F6). Now our scene manager should play, starting off with a blank screen and then revealing scene one. After that we can again press <em>space</em> or <em>enter</em> to trigger the transition to the next scene.</p>
<p><img src="transition_3.gif" alt="Direct Wipe Transition"></p>
<h2 id="conclusion">Conclusion</h2>
<p>In this tutorial we created three different scene transitions. As mentioned, the last, direct transition might require some extra work to get working properly, as it does not nicely mask the loading of the new scene. However, I do hope that you find these scenes useful. You can find the finished project on my GitHub: <a href="https://github.com/SelinaDev/02_Scene_Transitions">https://github.com/SelinaDev/02_Scene_Transitions</a>.</p>
<p>If you have questions, noticed an error, or just want to say hi, you can find me on Twitter <a href="https://twitter.com/SelinaDev">@SelinaDev</a>, or drop by <a href="https://discord.gg/KrnB6mJyMk">my Discord</a>.</p>




      </main>
  </div>
  </body>
</html>
