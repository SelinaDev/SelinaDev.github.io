<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="generator" content="Hugo 0.119.0">
  <link rel="canonical" href="https://selinadev.github.io/03-dropdown-menu/">

  
    
    <meta name="description" content="Godot provides a lot of tools out of the box, including a system for user interfaces, such as drop-down menus. After all, the Godot editor is built on just that technology an it has some of those UI elements. And those elements and the styling options work fine for something that looks like a UI-heavy application, as is the case with the Godot editor. However, sometimes we want something a bit more flashy for a game.">
  

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#000000">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" type="text/css" href="/css/paper.css">

  
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css">
  
  
    
  

  
  
  <title>Godot 3 Tutorial: Drop-down Menu | SelinaDev</title>
</head>

  <body>
    <div class="container paper">
      <nav class="border split-nav">
  <div class="nav-brand">
    <h3><a href="/">SelinaDev</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
    <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
      
        <li><a href="/">Blog</a></li>
      
        <li><a href="/tags/">Tags</a></li>
      
        <li><a href="/about/">About</a></li>
      
      </ul>
    </div>
  </div>
</nav>
      <main>
        

<h1 class="post-title">Godot 3 Tutorial: Drop-down Menu</h1>


<strong>Publish date: </strong>Apr 25, 2023
<br>

  <strong>Tags: </strong>
  
    <a href="/tags/godot3">godot3</a>
  
    <a href="/tags/tutorials">tutorials</a>
  



  

<div class="child-borders">
  <div class="toc border" aria-labelledby="toc-heading">
    <h2 id="toc-heading">Table of contents</h2>
    <ol>
      
        <li>
          
          
          
          
          <a href="#setup">
            Setup
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#menu-structue">
            Menu structue
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#menu-items">
            Menu Items
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#menuitemconfig">
            MenuItemConfig
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#menu-containers">
            Menu Containers
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#menubutton">
            MenuButton
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#test-stage">
            Test Stage
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#running-the-project">
            Running the Project
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#conclusion">
            Conclusion
          </a>
        </li>
      
    </ol>
  </div>
</div>



<p>Godot provides a lot of tools out of the box, including a system for user interfaces, such as drop-down menus. After all, the Godot editor is built on just that technology an it has some of those UI elements. And those elements and the styling options work fine for something that looks like a UI-heavy application, as is the case with the Godot editor. However, sometimes we want something a bit more flashy for a game. Or maybe just something that&rsquo;s a bit more customizable.</p>
<p>Therefore, I want to guide you through building a custom drop-down menu in this tutorial. It will have custom buttons with colored symbols, all of which will be defined by resources. The whole system will have a centralized way of emitting signals, meaning other nodes listening for menu clicks only need to connect to a single node. And while we&rsquo;re at it I will try to add some juice.</p>
<p><img src="menu_demo.gif" alt="Dropdown Menu in Action"></p>
<p>Hopefully this tutorial can serve as a starting point for you to build your own custom user interfaces in Godot. I will do my best to show it in what I believe is a clean way. And there is one technique I&rsquo;m eager to show you. A trick that allows you to combine the automatic UI scaling of containers with precise parametric positioning via code. But I will get to that. Let us go over it from the start.</p>
<h2 id="setup">Setup</h2>
<p>All code and files for this tutorial will be available on my <a href="https://github.com/SelinaDev/03_Drop_Down_Menus">GitHub</a> again (<a href="https://github.com/SelinaDev/03_Drop_Down_Menus">https://github.com/SelinaDev/03_Drop_Down_Menus</a>). If you want to follow along, start with a fresh Godot project, with two folders: <em>assets</em> and <em>src</em>. We&rsquo;ll use a few of Kenney&rsquo;s assets, which we&rsquo;ll put into <em>assets</em> subfolders:</p>
<ul>
<li>A <em>Font</em> folder with <em>&ldquo;Kenney Future.tff&rdquo;</em> from <a href="https://kenney.nl/assets/kenney-fonts">Kenney Fonts</a>.</li>
<li>An <em>Icons</em> folder with the following icons from <a href="https://kenney.nl/assets/board-game-icons">Board Game Icons</a>:
<ul>
<li><em>&ldquo;d4_outline_number.png&rdquo;</em></li>
<li><em>&ldquo;d6_outline_number.png&rdquo;</em></li>
<li><em>&ldquo;d8_outline_number.png&rdquo;</em></li>
<li><em>&ldquo;d10_outline_number.png&rdquo;</em></li>
<li><em>&ldquo;d12_outline_number.png&rdquo;</em></li>
<li><em>&ldquo;d20_outline_number.png&rdquo;</em></li>
</ul>
</li>
<li>A <em>UI</em> folder with two button textures from <a href="https://kenney.nl/assets/ui-pack-rpg-expansion">UI Pack: RPG Expansion</a>:
<ul>
<li><em>&ldquo;buttonLong_brown_pressed.png&rdquo;</em></li>
<li><em>&ldquo;buttonSquare_brown_pressed.png&rdquo;</em></li>
</ul>
</li>
</ul>
<h2 id="menu-structue">Menu structue</h2>
<p>Before we can start populating this menu bar with menu buttons which will spawn drop-down menus, we first have to create all of those elements. I have not found a good way to separate all these elements. It would probably be more fun to test each new feature out on its own as we implement them. However, as the parent nodes need to handle child nodes I would have to split up each node&rsquo;s code a lot, which I fear would be confusing. So in order to keep this tutorial concise I will explain the nodes we will create here, and then show the implementation from the outermost nodes to the innermost.</p>
<p>The innermost node we need to create is the <strong>MenuButton</strong>. It sits in the menu bar we have just created. When clicked, it will spawn a drop-down menu. This drop-down menu consists of several components, which are grouped together by a <strong>MenuContainer</strong>. This menu container in turn holds the <strong>MenuItems</strong>, the individual buttons of the drop-down menu. So let us start implementing the latter one.</p>
<h2 id="menu-items">Menu Items</h2>
<p>We will start with what I will call <strong>MenuItem</strong> (I will be the first to admit that my nomenclature is not the cleanest, but I hope you will be able to follow anyway). The menu items are the items in the drop-down menu that will pop up. If you think of our menu strucutre as a tree, then they are the leaf nodes (at least here, as the system could be extended to submenus). Let us start by creating a new scene with a <code>Control</code> node at its rook, which we will call, unsurprisingly, <strong>MenuItem</strong>. Save the scene in a new folder under <em>res://src/UI_Elements/MenuItem.tscn</em>. Now for the scene tree structure: We add a <code>MarginContainer</code>as a child of <strong>MenuItem</strong>. To that we add two nodes, a <code>Button</code> and another <code>MarginContainer</code>. We then add a <code>HBoxContainer</code> to the inner <code>MarginContainer</code>. In that <code>HBoxcontainer</code> we add a <code>Label</code> node and a <code>TextureRect</code> node, the latter of which we will call <strong>Icon</strong>. We add one last child to the root <strong>MenuItem</strong>, and if you&rsquo;ve read my other tutorials you will not be surprised to learn that we now add a <code>Tween</code>.</p>
<p><img src="MenuItem_SceneTree.png" alt="MenuItem Scene Tree"></p>
<p>Now for the nodes&rsquo; setup. For the <strong>Icon</strong> we tick its <em>Expand</em> property. We set <em>Mouse</em> &gt; <em>Filter</em> to <em>Ignore</em>. And in the <em>Size Flags</em> we untick the horizontal <em>Fill</em>, and instead set it to <em>Expand</em> and <em>Shrink End</em>. This will cause the <strong>Icon</strong> to be pushed to the far right of the available space. That way it currently has zero width, but we will deal with that in code later.</p>
<p>Set the <code>Label</code>&rsquo;s <em>text</em> to <em>&ldquo;Item Name&rdquo;</em> as a placeholder for now. Set its <em>V Align</em> to <em>Center</em>. In the <em>Size Flags</em> check <em>Fill</em> both for <em>Horizontal</em> and <em>Vertical</em>. Lastly, go to <em>Theme Overrides</em> &gt; <em>Fonts</em> and create a new <code>DynamicFont</code> in the <em>Font</em> slot. Set that font&rsquo;s outline <em>Outline Size</em> to 1 and its <em>Outline Color</em> to black. Drag <em>res://assets/Font/Kenney Future.ttf</em> into <em>Font</em> &gt; <em>Font Data</em>.</p>
<p>For both the <code>HBoxContainer</code> and the inner <code>MarginContainer</code> we set <em>Mouse</em> &gt; <em>Filter</em> to <em>Ignore</em> as well. We also configure the inner <code>MarginContainer</code>&rsquo;s <em>Margin Right</em> and <em>Margin Left</em> under <em>Theme Overrides</em> &gt; <em>Constants</em> to be <em>5</em> pixels.</p>
<p>The <code>Button</code> will catch input events, so we leave its filters as they are. We only need give it some custom <em>Styles</em> under <em>Theme Overrides</em> &gt; <em>Styles</em>. Create a new <em>StyleBoxTexture</em> in the <em>Normal</em>, and drag in <em>&ldquo;buttonLong_brown_pressed.png&rdquo;</em> as <em>Texture</em>. We set all the <em>Margins</em> to 8, and change the <em>Horizontal</em> <em>Axis Strech</em> to <em>Tile</em> and the <em>Vertical</em> one to <em>Tile Fit</em>. Once we configered the <em>StyleBox</em> for <em>Normal</em> we simply copy by dragging it from <em>Normal</em> and dropping it into the all of the other slots one by one.</p>
<p>Lastly, on the <strong>MenuItem</strong> we have to check <em>Rect</em> &gt; <em>Clip Content</em>. All the positioning will come later. As you will see this setup, as unconventional as it may seem right now, will give us quite a bit of flexibility.</p>
<p>Now for some code. Let us add a script to <strong>MenuItem</strong> and call it <em>MenuItem.gd</em>. We save it alongside <em>MenuItem.tscn</em>. Let us look at the top of the script first, then go over the individual functions.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">class_name</span> <span style="color:#a6e22e">MenuItem</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Control</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">signal</span> pressed
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> fade_duration: <span style="color:#66d9ef">float</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.15</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export (<span style="color:#a6e22e">Color</span>) <span style="color:#66d9ef">var</span> highlight_color
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> label: <span style="color:#a6e22e">Label</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$MarginContainer/MarginContainer/HBoxContainer/Label</span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> icon: <span style="color:#a6e22e">TextureRect</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$MarginContainer/MarginContainer/HBoxContainer/Icon</span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> margin_container: <span style="color:#a6e22e">MarginContainer</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$MarginContainer</span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> button: <span style="color:#a6e22e">Button</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$MarginContainer/Button</span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> tween: <span style="color:#a6e22e">Tween</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$Tween</span>
</span></span></code></pre></div><p>Here, we define a <em>pressed</em> signal, so we can have the scene behave like a button. We export a highlight_color, so we can set it in the editor, and define a constant value for how long the fade to and from that highlight should take. Lastly, we cache all the nodes we need access to later.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_ready</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	rect_min_size<span style="color:#f92672">.</span>x <span style="color:#f92672">=</span> margin_container<span style="color:#f92672">.</span>rect_size<span style="color:#f92672">.</span>x
</span></span><span style="display:flex;"><span>	icon<span style="color:#f92672">.</span>rect_min_size<span style="color:#f92672">.</span>x <span style="color:#f92672">=</span> icon<span style="color:#f92672">.</span>rect_size<span style="color:#f92672">.</span>y
</span></span></code></pre></div><p>It is relatively compact, but it is important for positioning. We will later add this scene to a container, which will try to compress its dimensions as far as it can, which is why we did not care for the size of the <strong>MenuItem</strong> root node itself. In order to preserve what we see in the scene, which is dependent on the width of the (outer) <strong>MarginContainer</strong>, we set this nodes minimum width to that of the <strong>MarginContainer</strong>. We don&rsquo;t set the height yet, meaning it will be squished to 0, and due to the content clipping the node will be invisible. This is actually just what we want for the animation, but more on that later.</p>
<p>We also want the <strong>Icon</strong> to be square, so we set the minimum x dimension to the current y. This will ensure that even if squished vertically, it won&rsquo;t go below a width that is equal to its height, making it square.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">setup</span>(text: <span style="color:#a6e22e">String</span>, icon_texture: <span style="color:#a6e22e">Texture</span>, icon_color: <span style="color:#a6e22e">Color</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	label<span style="color:#f92672">.</span>text <span style="color:#f92672">=</span> text
</span></span><span style="display:flex;"><span>	icon<span style="color:#f92672">.</span>texture <span style="color:#f92672">=</span> icon_texture
</span></span><span style="display:flex;"><span>	icon<span style="color:#f92672">.</span>modulate <span style="color:#f92672">=</span> icon_color
</span></span></code></pre></div><p>Here is our setup function. This is something I like to have for UI nodes that get instanced in code. All the things you would have as exports if you&rsquo;d do this in the editor are set via this function. Everything that will vary from one instance of this scene to the next, i.e., the text, icon and icon color, are set in this function. Notice that the trick using the modulate to color the icons will only work properly for white icons.</p>
<p>For the next block we will connect a signal from the <strong>Button</strong> to this script. Select the <strong>Button</strong>, and click on <em>Node</em> next to the <em>Inspector</em>. Make sure you are in the <em>Signals</em> tab rather than the <em>Groups</em> tab.</p>
<p><img src="MenuItem_SignalConnection.png" alt="Signal Connections"></p>
<p>Double click on the <em>pressed()</em> signal, then clich <em>Connect</em> in the window that pops up.</p>
<p><img src="MenuItem_SignalConnectionDialogue.png" alt="Signal Connection Dialogue"></p>
<p>This will create the function in the script for you, which we will fill with the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_on_Button_pressed</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">emit_signal</span>(<span style="color:#e6db74">&#34;pressed&#34;</span>)
</span></span></code></pre></div><p>Here we simply emit this scene&rsquo;s <em>pressed()</em> signal whenever we receive it from the <strong>Button</strong> effectively relaying it. The <strong>Button</strong> will catch all mouse clicks and screen taps, and now our scene will too, but with some added functionality.</p>
<p>Speaking of buttons, you might have noticed that I have not used an alternative texture for the <strong>Button</strong>&rsquo;s <em>Hover</em> state. Sometimes you don&rsquo;t have alternative textures available, so I wanted to show a nice trick to achieve a hover effect procedurally.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_highlight</span>(fade_in) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span>(button, <span style="color:#e6db74">&#34;self_modulate&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> start: <span style="color:#a6e22e">Color</span> <span style="color:#f92672">=</span> highlight_color <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> fade_in <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>white
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> target: <span style="color:#a6e22e">Color</span> <span style="color:#f92672">=</span> highlight_color <span style="color:#66d9ef">if</span> fade_in <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>white
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> duration <span style="color:#f92672">:=</span> fade_duration <span style="color:#f92672">*</span> inverse_lerp(target<span style="color:#f92672">.</span>r, start<span style="color:#f92672">.</span>r, button<span style="color:#f92672">.</span>self_modulate<span style="color:#f92672">.</span>r)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">interpolate_property</span>(
</span></span><span style="display:flex;"><span>		button,
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;self_modulate&#34;</span>,
</span></span><span style="display:flex;"><span>		button<span style="color:#f92672">.</span>self_modulate,
</span></span><span style="display:flex;"><span>		target,
</span></span><span style="display:flex;"><span>		duration
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span>()
</span></span></code></pre></div><p>This is the function that does the highlighting. We will highlight by changing the modulate of the <strong>Button</strong> (i.e., the background of this scene) between neutral (i.e., white) and the highlight color we still have to define. But more on that later. First, we remove any ongoing tweenings of <em>self_modulate</em> from our <strong>Tween</strong> node. We will combine different kinds of animations later, so we have to be specific in what we want to remove. You will have noticed that this function is taking an argument <code>fade_in</code>. This argument tells us whether we are using this function to fade the highlight in or out. For that reason we will also define a <code>start</code> and <code>target</code>. These will evaluate either to the <code>highlight_color</code> or to a neutral <code>Color.white</code>, depending on which way we are going. We also calculate a duration. We have already defined how long a complete fade should take, but what if the user is quick and moves away from the <strong>MenuItem</strong> before the fade in of the highlight is complete. We do not want to wait for the first fade to complete, and we also do not want to jump straight to the full highlight for the start of the fade out. So we calculate how close we already are to our target modulate and scale our duration according to that. This makes things a lot smoother.</p>
<p>You can see somethin similar in the <code>interpolate_property()</code>. We do not start the tween at the start value. That is only a hypothetical value for a full animation in a certain direction. Rather, we start at the current modulate, and animate to the target, for the calculated duration. We omit the easing parameters to stay on a linear interpolation. That&rsquo;s the downside of accounting for these partial animations. They could get wonky if we use non-linear easings that always start at different points and have different durations.</p>
<p>At this point we have to step out of the code again and head over to the <strong>Button</strong>&rsquo;s signals once again. This time we double click on <em>mouse_entered()</em>. We will not leave the receiver method at its default, however, but set it to <em>&quot;_highlight&quot;</em>. We remember that <code>_highlight()</code> takes in an argument, which we need to account for. For this reason we activate the <em>advanced</em> setting. Let us add a <code>bool</code> argument to the call. Once it appears under <em>Bind</em> we make sure the checkbox is ticked, so <code>fade_in</code> is <code>true</code> when the function gets called in reaction to the mouse entering. Once all that is set up, we click <em>Connect</em>.</p>
<p><img src="MenuItem_SignalConnectionDialogue_Advanced.png" alt="Advanced Signal Connection Dialogue with Bindings"></p>
<p>We also connect <em>mouse_exited()</em> in the same way, so with <em>&quot;_highlight&quot;</em> as receiver method and an extra <code>bool</code> argument, just this time we make sure the checkbox is not ticked. This setup will call <code>_highlight()</code> to fade in when the mouse is entered, and to fade out when it exits, without need for extra code.</p>
<p>Lastly, the <strong>MenuItems</strong> themselves will handle opening and closing of the drop-down menu, so we need functions for that. Let us first look at the code, and then I will go into a bit of detail of what will be happening, which will hopefully make my choice for this kind of node setup a bit more clear.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">open</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	button<span style="color:#f92672">.</span>self_modulate <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>white
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> duration <span style="color:#f92672">:=</span> fade_duration <span style="color:#f92672">*</span> inverse_lerp(<span style="color:#ae81ff">0</span>, margin_container<span style="color:#f92672">.</span>rect_size<span style="color:#f92672">.</span>y, rect_min_size<span style="color:#f92672">.</span>y)
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span>(self, <span style="color:#e6db74">&#34;rect_min_size:y&#34;</span>)
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">interpolate_property</span>(
</span></span><span style="display:flex;"><span>		self,
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;rect_min_size:y&#34;</span>,
</span></span><span style="display:flex;"><span>		rect_min_size<span style="color:#f92672">.</span>y,
</span></span><span style="display:flex;"><span>		margin_container<span style="color:#f92672">.</span>rect_size<span style="color:#f92672">.</span>y,
</span></span><span style="display:flex;"><span>		duration
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">close</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> duration <span style="color:#f92672">:=</span> fade_duration <span style="color:#f92672">*</span> inverse_lerp(margin_container<span style="color:#f92672">.</span>rect_size<span style="color:#f92672">.</span>y, <span style="color:#ae81ff">0</span>, rect_min_size<span style="color:#f92672">.</span>y)
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span>(self, <span style="color:#e6db74">&#34;rect_min_size:y&#34;</span>)
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">interpolate_property</span>(
</span></span><span style="display:flex;"><span>		self,
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;rect_min_size:y&#34;</span>,
</span></span><span style="display:flex;"><span>		rect_min_size<span style="color:#f92672">.</span>y,
</span></span><span style="display:flex;"><span>		<span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>		duration
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span>()
</span></span></code></pre></div><p>These are both pretty similar, and mostly differ in the direction they work. Indeed, we could use a similar trick like with the <code>_highlight()</code> function. However, these functions will get called from other nodes, and in that case I prefer to be a bit more explicit. The <code>_open()</code> funcition has one extra line at the start, which resets the <strong>Button</strong>&rsquo;s <em>self_modulate</em>. This is necessary as we won&rsquo;t reliably get <em>mouse_exited</em> signal when the menu closes, and we don&rsquo;t want the <strong>MenuItems</strong> to remain highlighted when it is opened again.</p>
<p>After that the two functions only differ in their direction. What we want to animate is the <em>y</em> coordinate of the <strong>MenuItem</strong>&rsquo;s <em>rect_min_size</em> property. I&rsquo;ll explain why below. We have two lines that look familiar to how we did things in the <code>_highlight()</code> function. We calculate the actual animation duration from the point we are at the moment. If the menu is fully opened or closed, then <em>duration</em> will be the full <em>fade_duration</em>. If we rapidly open and close the menu before the previous animation completed, we&rsquo;ll use less time. For this case we also remove any previous tweenings of our target property. Then it&rsquo;s setting up the tween. In the closed state we want <em>rect_min_size.y</em> to be <em>0</em>, and in the opened state we want it to the height of its child node, the <strong>MarginContainer</strong>&rsquo;s rect_size.y. We always start from the current height and animate to the target height. And just like that, individual **MenuItem*s are theoreticall able to open and close. Next, we will need a container to group our them.</p>



  


<div class="child-borders">
  <div class="sm col border-dotted">
    So how will this opening and closing effect work exactly? The <strong>MenuItems</strong> will live inside an <code>VBoxContainer</code>, which will group them vertically. Containers will try to scale their children. If their anchors and size are configured to a certain size they might want to stretch their children, but most of the time they try to compress their children to the minimum required size. If that child is a container a well, then this will work recursively. That&rsquo;s how you can build nice UIs in Godot with nesting Containers. That&rsquo;s why we set the <strong>MenuItem</strong>&rsquo;s minimum width in its <code>setup()</code> function. We don&rsquo;t want it compressed below that width. However, we use the minimum size to animate opening and closing. But aren&rsquo;t we working with containers, and shouldn&rsquo;t that prevent us from compressing the <strong>MenuItem</strong> below the minimum height of all it&rsquo;s components? Well, we use containers, yes, but we are consciously breaking that hierarchy of containers with a plain <code>Control</code> as the <strong>MenuItem</strong>&rsquo;s root. A <code>Control</code> won&rsquo;t manage it&rsquo;s children&rsquo;s size the same way a container would. With clipping enabled it will only show the part of its child that&rsquo;s inside its own extents. Therefore, by animating the minimum height of the root <code>Control</code> we can change how much we show of the full <strong>MenuItem</strong>, from not showing it (closed) to showing all of it (opened).
  </div>
</div>

<h2 id="menuitemconfig">MenuItemConfig</h2>
<p>Before we start with the container for the <strong>MenuItem</strong>s we need something to hold configuration data for them. We create a custom resource that holds all the information we set in the <strong>MenuItem</strong>&rsquo;s <em>setup()</em> function, plus a button_id.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">class_name</span> <span style="color:#a6e22e">MenuItemConfig</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Resource</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export (<span style="color:#a6e22e">String</span>) <span style="color:#66d9ef">var</span> text
</span></span><span style="display:flex;"><span>export (<span style="color:#a6e22e">String</span>) <span style="color:#66d9ef">var</span> button_id
</span></span><span style="display:flex;"><span>export (<span style="color:#a6e22e">Texture</span>) <span style="color:#66d9ef">var</span> icon
</span></span><span style="display:flex;"><span>export (<span style="color:#a6e22e">Color</span>) <span style="color:#66d9ef">var</span> icon_color <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>white
</span></span></code></pre></div><h2 id="menu-containers">Menu Containers</h2>
<p>Now we create a container for the menu. This container will basically be a <code>VBoxContainer</code> wrapped inside a <code>Control</code> with some code attached. So create a new scene with a <code>Control</code> node as root, and call it <strong>MenuContainer</strong>. Save it under <em>res://src/UI_Elements/MenuContainer.tscn</em>. Add a <code>VBoxContainer</code> as a child node.</p>
<p><img src="MenuContainer_SceneTree.png" alt="MenuContainer Scene Tree"></p>
<p>Attach a script to the root node. We&rsquo;ll save the script as <em>res://src/UI_Elements/MenuContainer.gd</em>. Here&rsquo;s the top of the script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">class_name</span> <span style="color:#a6e22e">MenuContainer</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Control</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">signal</span> <span style="color:#a6e22e">button_pressed</span>(button_id)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> menu_item_scene: <span style="color:#a6e22e">PackedScene</span> <span style="color:#f92672">=</span> preload(<span style="color:#e6db74">&#34;res://src/UI_Elements/MenuItem.tscn&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> v_box: <span style="color:#a6e22e">VBoxContainer</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$VBoxContainer</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_ready</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">hide</span>()
</span></span></code></pre></div><p>We define a <em>button_pressed</em> signal that relays button presses from the contained <strong>MenuItem</strong>s and attaches their id. We also load the <strong>MenuItem</strong> scene into a variable so we can instantiate it later. We need a reference to the <code>VBoxContainer</code> so we can fill it with the <strong>MenuItems</strong>. In the ready function we simply make sure the container starts out invisible.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fill</span>(menu_items: <span style="color:#a6e22e">Array</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> menu_item_config <span style="color:#f92672">in</span> menu_items:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">create_button</span>(menu_item_config)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">create_button</span>(menu_item_config: MenuItemConfig) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> new_menu_item: MenuItem <span style="color:#f92672">=</span> menu_item_scene<span style="color:#f92672">.</span><span style="color:#a6e22e">instance</span>()
</span></span><span style="display:flex;"><span>	v_box<span style="color:#f92672">.</span><span style="color:#a6e22e">add_child</span>(new_menu_item)
</span></span><span style="display:flex;"><span>	new_menu_item<span style="color:#f92672">.</span><span style="color:#a6e22e">connect</span>(<span style="color:#e6db74">&#34;pressed&#34;</span>, self, <span style="color:#e6db74">&#34;_on_MenuItem_pressed&#34;</span>, [menu_item_config<span style="color:#f92672">.</span>button_id])
</span></span><span style="display:flex;"><span>	new_menu_item<span style="color:#f92672">.</span><span style="color:#a6e22e">setup</span>(menu_item_config<span style="color:#f92672">.</span>text, menu_item_config<span style="color:#f92672">.</span>icon, menu_item_config<span style="color:#f92672">.</span>icon_color)
</span></span></code></pre></div><p>Next come two functions to populate the container. The <code>fill()</code> function expects an array of <code>MenuItemConfig</code> resources and uses the <code>create_button()</code> function to create one item from each config. The <code>create_button()</code> function instantiates our <strong>MenuItem</strong> scene and adds it to the <code>VBoxContainer</code>. It then connects the <strong>MenuItem</strong>&rsquo;s <em>pressed</em> signal so a <code>_on_MenuItem_pressed()</code> function and binds the <em>button_id</em> to that signal, so we later know which button was pressed. Lastly we call the <code>setup()</code> function we wrote on the <strong>MenuItem</strong> and feed it with the info it needs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_on_MenuItem_pressed</span>(button_id: <span style="color:#a6e22e">String</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">emit_signal</span>(<span style="color:#e6db74">&#34;button_pressed&#34;</span>, button_id)
</span></span></code></pre></div><p>The function we connect to simply emits the <em>button_pressed</em> signal with the associated <em>button_id</em> whenever a <strong>MenuItem</strong> is pressed.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">set_menu_position</span>(global_position: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	v_box<span style="color:#f92672">.</span>rect_global_position <span style="color:#f92672">=</span> global_position
</span></span></code></pre></div><p>Next we have a wrapper to set the global position.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">has_position</span>(global_position: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">bool</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> v_box<span style="color:#f92672">.</span><span style="color:#a6e22e">get_global_rect</span>()<span style="color:#f92672">.</span><span style="color:#a6e22e">has_point</span>(global_position)
</span></span></code></pre></div><p>We later will need a way of knowing if an input event was inside the menu, for which we will use this function.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">open</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">show</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> item <span style="color:#f92672">in</span> v_box<span style="color:#f92672">.</span><span style="color:#a6e22e">get_children</span>():
</span></span><span style="display:flex;"><span>		item<span style="color:#f92672">.</span><span style="color:#a6e22e">open</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">close</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> items <span style="color:#f92672">=</span> v_box<span style="color:#f92672">.</span><span style="color:#a6e22e">get_children</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> item <span style="color:#f92672">in</span> items:
</span></span><span style="display:flex;"><span>		item<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">yield</span>(<span style="color:#a6e22e">get_tree</span>()<span style="color:#f92672">.</span><span style="color:#a6e22e">create_timer</span>(MenuItem<span style="color:#f92672">.</span>fade_duration), <span style="color:#e6db74">&#34;timeout&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">hide</span>()
</span></span></code></pre></div><p>To open the whole menu we simply show it and then open every individual item. Closing works similarly, only we need to hide once the animation is complete, so we delay hiding by the <strong>MenuItem</strong>&rsquo;s <em>fade_duration</em>. Not the most elegant solution here, but it works. And with that we&rsquo;re done with the <strong>MenuContainer</strong>. We need only two more pieces for the system itself, and after that we will put the system to use.</p>
<h2 id="menubutton">MenuButton</h2>
<p>The menus we created so far will be attached to a button that opens it. For this we create a new scene with a <code>MarginContainer</code> as a root node and call it <strong>MenuButton</strong>. Save it in the same directory as the other scenes, under <em>res://src/UI_Elements/MenuButton.tscn</em>. Now for the node structure. The first child will be a <code>Button</code>. In a previous version I was using input events to check for mouse clicks. However, this method gets a bit more convoluted when you also want to check for touch events. <code>Button</code> nodes already check for everything we need, so there&rsquo;s not need to reinvent the wheel. We&rsquo;ll also want to highlight this element, but here I wanted to show a slightly different method. We will use a <code>Panel</code> node as background for our <code>Label</code>. So add a <code>Panel</code> and rename it to <strong>Highlight</strong>. Then add a <code>MarginContainer</code> and to that add a <code>Label</code>. The <strong>MenuButton</strong> needs two more nodes. One <code>Tween</code> and an instance of our <strong>MenuContainer</strong> scene.</p>
<p><img src="MenuButton_SceneTree.png" alt="MenuButton Scene Tree"></p>



  


<div class="child-borders">
  <div class="sm col border-dotted">
    You might be wondering &ldquo;Why are there so many <code>MarginContainer</code>s? The obvious use of them is to add padding to some elements so they get the space they need, like we do here with the <code>Label</code>. Don&rsquo;t be afraid to give your elements some space to breathe. However, the way <code>MarginContainer</code>s position their children is that they take all children and strech them to their own size minus the <em>margin</em> settings. In some cases I simply want to make use of container positioning and make sure a few node are all the same size, like the <strong>Highlight</strong> <code>Panel</code> and the <code>Button</code> in this example. For this I find it most convenient to simply use a <code>MarginContainer</code> with all <em>margins</em> set to 0, as this will do exactly this job.
  </div>
</div>

<p>A lot of nodes in this scene, so let&rsquo;s get to configuring them. I want this element to just be text, so we need the <code>Button</code>&rsquo;s functionality, but not its visual background. For this, go into the <code>Button</code>&rsquo;s <em>Theme Overrides</em> &gt; <em>Styles</em> and create a new <code>StyleBoxEmpty</code> in the first slot. Then drag and drop it from the first into all the other slots. Next, for the <strong>Highlight</strong> set <em>Mouse</em> &gt; <em>Filter</em> to <em>Ignore</em>. Then, let&rsquo;s create a new <code>StyleBoxFlat</code> in <em>Theme Overrides</em> &gt; <em>Styles</em> &gt; <em>Panel</em>. For the <em>BG Color</em> white that&rsquo;s halfway transparent, i.e., with an alpha of arount 128. We also want borderst. Set <em>Border Width</em> to 2 for all borders. Set the <em>Boder</em> &gt; <em>Color</em> to a solid white. Lastly, set all the corners in <em>Corner Radius</em> to 5. Moving on to the <strong>MarginContainer</strong> we again set <em>Mouse</em> &gt; <em>Filter</em> to <em>Ignore</em>. We then set the margins under <em>Theme Overrides</em> &gt; <em>Constants</em> to 5, 3, 7, and 3 (for right, top, left, and bottom respectively). For the <code>Label</code> we set the <em>V Align</em> to <em>Center</em>, and check <em>Fill</em> in the <em>Size Flags</em> for both <em>Horizontal</em> and <em>Vertical</em>. As with the other labels before we create a new <code>Dynamic Font</code> in <em>Theme Overrides</em> &gt; <em>Fonts</em> &gt; <em>Font</em>. Again we fill <em>res://assets/Font/Kenney Future.ttf</em> into <em>Font</em> &gt; _ Font Data_ and give the font an <em>Outline Size</em> of 1 and a black <em>Outline Color</em>. I probably should have created a font resource for this, but how else should you learn from my mistakes.</p>
<p>Now, let&rsquo;s start with the code. Create a script on the root <strong>MenuButton</strong> code, and save it at <em>res://src/UI_Elements/MenuButton.gd</em>. Here&rsquo;s the top part of the script.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span>tool
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">MarginContainer</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">signal</span> <span style="color:#a6e22e">button_pressed</span>(menu, button)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> fade_duration: <span style="color:#66d9ef">float</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.8</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export <span style="color:#66d9ef">var</span> text: <span style="color:#a6e22e">String</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&lt;Button&gt;&#34;</span> setget set_text
</span></span><span style="display:flex;"><span>export <span style="color:#66d9ef">var</span> menu_id: <span style="color:#a6e22e">String</span>
</span></span><span style="display:flex;"><span>export (<span style="color:#a6e22e">Array</span>, <span style="color:#a6e22e">Resource</span>) <span style="color:#66d9ef">var</span> menu_options
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> highlight: <span style="color:#a6e22e">Panel</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$Highlight</span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> label: <span style="color:#a6e22e">Label</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$MarginContainer/Label</span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> tween: <span style="color:#a6e22e">Tween</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$Tween</span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> menu_container: MenuContainer <span style="color:#f92672">=</span> <span style="color:#a6e22e">$MenuContainer</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> spawn_y: <span style="color:#66d9ef">float</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> _is_open: <span style="color:#66d9ef">bool</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>
</span></span></code></pre></div><p>Here we create a tool script. We want to see the text in the editor, so we need it to be able to update within the editor. Also note that we are not setting a <code>class_name</code>. This is because on the one hand we won&rsquo;t be referring to this class in code, and on the other hand <code>MenuButton</code> is already a builtin type, so we wouldn&rsquo;t be able to overload it. Next you&rsquo;ll see a continuation of the system that relays our signals, with a <em>button_pressed()</em> signal that will relay both the <strong>MenuItem</strong> that was clicked as well as the <strong>MenuButton</strong> it belongs to (I do realize that <em>button_pressed</em> is a bit of a misnomer when the signal is reall concerned about <strong>MenuItems</strong>, but I created it early on and changing it would require changes in a lot of different places, so that&rsquo;s how it&rsquo;s called now). We again have a <em>fade_duration</em> constant, again for the highlight animation. We export three variables. The <em>text</em> we&rsquo;ll use for our label (which also has an associated setter function <code>set_text()</code>), a <em>menu_id</em> that&rsquo;ll be emitted so we&rsquo;ll know which item in which menu was pressed, and an <code>Array</code> of <code>Resources</code> called <em>menu_options</em>. We will fill this array with <code>MenuItemConfig</code> <code>Resources</code>, and it will define what items are in the menu. We also get references to a few nodes. Lastly, we have a <em>_is_open</em> variable that stores whether the menu is open or closed, as well as a <em>spawn_y</em> variable that we&rsquo;ll use to position the menu (we&rsquo;ll get to where we set that variable later).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_ready</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">set_text</span>(text)
</span></span><span style="display:flex;"><span>	highlight<span style="color:#f92672">.</span>modulate<span style="color:#f92672">.</span>a <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	menu_container<span style="color:#f92672">.</span><span style="color:#a6e22e">fill</span>(menu_options)
</span></span></code></pre></div><p>Next up is the <code>_ready()</code> function. We call the <code>set_text()</code> function once (we&rsquo;ll write it in a bit). We also make the <strong>Highlight</strong> <code>Panel</code> transparent, because the button should start out not highlighted. Lastly, we pass the array of <code>MenuItemConfig</code>s to the <strong>MenuContainer</strong>&rsquo;s <code>fill()</code> function to populate it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">set_text</span>(value: <span style="color:#a6e22e">String</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	text <span style="color:#f92672">=</span> value
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> <span style="color:#a6e22e">is_inside_tree</span>():
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">yield</span>(self, <span style="color:#e6db74">&#34;ready&#34;</span>)
</span></span><span style="display:flex;"><span>	label<span style="color:#f92672">.</span>text <span style="color:#f92672">=</span> text
</span></span></code></pre></div><p>Now for the aforementioned <code>set_text()</code> function. We set the <em>text</em> variable itself to the new value. Then, in case we aren&rsquo;t inside the scene tree, we wait for that, so we have access to the label. Once we are sure we can access the label, we set its text as well. This makes sure the scene will work properly in the editor as well.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fade</span>(fade_in: <span style="color:#66d9ef">bool</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">remove_all</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> target <span style="color:#f92672">:=</span> <span style="color:#66d9ef">float</span>(fade_in)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> duration <span style="color:#f92672">:=</span> fade_duration <span style="color:#f92672">*</span> inverse_lerp(target, <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">-</span> target, highlight<span style="color:#f92672">.</span>modulate<span style="color:#f92672">.</span>a)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">interpolate_property</span>(
</span></span><span style="display:flex;"><span>		highlight,
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;modulate:a&#34;</span>,
</span></span><span style="display:flex;"><span>		highlight<span style="color:#f92672">.</span>modulate<span style="color:#f92672">.</span>a,
</span></span><span style="display:flex;"><span>		<span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> fade_in <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>		duration
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span>()
</span></span></code></pre></div><p>Now we&rsquo;ll handle the <code>fade()</code> function. This function is almost identical to the <strong>MenuItem</strong>&rsquo;s <code>_highlight()</code> function, except that we animate the alpha value of the <strong>Highlight</strong> node, thereby animating it between transparent and opague (furthermore this function is evidence that I really need to work on more consistent naming).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">spawn_menu</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> menu_pos <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Vector2</span>(rect_global_position<span style="color:#f92672">.</span>x, spawn_y)
</span></span><span style="display:flex;"><span>	menu_container<span style="color:#f92672">.</span><span style="color:#a6e22e">set_menu_position</span>(menu_pos)
</span></span><span style="display:flex;"><span>	menu_container<span style="color:#f92672">.</span><span style="color:#a6e22e">open</span>()
</span></span><span style="display:flex;"><span>	_is_open <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
</span></span></code></pre></div><p>Here we spawn the menu. We first calculate it&rsquo;s position. In this example the position will be static, but if there is chance the <strong>MenuButton</strong> could move this makes sure the menu will always be right below it. The (global) x coordinates of the <strong>MenuButton</strong> and the <strong>MenuContainer</strong> should be identical, and the (global) y should be just below the <strong>MenuButton</strong>, which is stored in <em>spawn_y</em>. Once that&rsquo;s taken care of we call <code>open()</code> on the **MenuContainer` and keep track of that state by saving it in <em>_is_open</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_on_Button_pressed</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> _is_open:
</span></span><span style="display:flex;"><span>		menu_container<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span>()
</span></span><span style="display:flex;"><span>		_is_open <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">spawn_menu</span>()
</span></span></code></pre></div><p>We need a function we can later hook up to the <strong>Button</strong>&rsquo;s <em>pressed()</em> signal. The button should work differently depending on whether the menu currently is open or closed. If it is open we close it (and store that state). If it is not, we call <code>spawn_menu()</code>, which will open the menu for us.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">has_position</span>(global_position: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">bool</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">get_global_rect</span>()<span style="color:#f92672">.</span><span style="color:#a6e22e">has_point</span>(global_position):
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> menu_container<span style="color:#f92672">.</span><span style="color:#a6e22e">has_position</span>(global_position)
</span></span></code></pre></div><p>We will want the menu to close when we click outside the button or the menu. For this we&rsquo;ll need a function that checks if an event is inside the button or its child menu.  We already have a <code>has_position()</code> function on the <strong>MenuContainer</strong>. First we check whether the event is in the button. If it is, we return <code>true</code>, if it isn&rsquo;t we check with the <strong>MenuContainer</strong> if the event happened in its rectangle.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_input</span>(event: <span style="color:#a6e22e">InputEvent</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">not</span> event<span style="color:#f92672">.</span><span style="color:#a6e22e">is_echo</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">and</span> event<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;position&#34;</span>) <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">and</span> event<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;pressed&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">and</span> <span style="color:#f92672">not</span> <span style="color:#a6e22e">has_position</span>(event<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;position&#34;</span>))):
</span></span><span style="display:flex;"><span>		menu_container<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span>()
</span></span><span style="display:flex;"><span>		_is_open <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>
</span></span></code></pre></div><p>Here we check any input that occurred, and filter for the ones that interest us. We check if the event isn&rsquo;t an echo, as we don&rsquo;t want to react to continued presses. Then we check if the event has a <em>position</em> property by using <code>get()</code>, and if the event has that property the value will not be <code>null</code>. Then we check if the <em>pressed</em> property is true. This works similar to the check above, so if the event does not have a <em>pressed</em> property, this check will be false. Then we check whether the position is outside the button or the menu. Then if all these checks are satisfied we close the menu (and store that state).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_on_MenuContainer_button_pressed</span>(button_id) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">emit_signal</span>(<span style="color:#e6db74">&#34;button_pressed&#34;</span>, menu_id, button_id)
</span></span><span style="display:flex;"><span>	menu_container<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span>()
</span></span><span style="display:flex;"><span>	_is_open <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>
</span></span></code></pre></div><p>As the last function we have the function that will relay the signal from the menu. Also, when a button in the menu is clicked we close it.</p>
<p>What&rsquo;s left now is to connect all the signals. We need to connect the <em>button_pressed()</em> signal of the <strong>MenuContainer</strong> to <code>\_on_MenuContainer_button_pressed()</code>, as well as the <em>pressed()</em> signal of the <strong>Button</strong> to <code>\_on_Button_pressed()</code>. We also need to connect the <em>mouse_entered()</em> signal on the <strong>Button</strong> to the <strong>MenuButton</strong>&rsquo;s <code>fade()</code> function, and bind a <code>true</code> boolean argument to it, same as we did above with the <code>highlight()</code> above in the <strong>MenuItem</strong>. We connect the <em>mouse_exited()</em> signal of the <strong>Button</strong> to the <strong>MenuButton</strong>&rsquo;s <code>fade()</code> as well, but this time bind <code>false</code> as argument.</p>
<p>We only need one further piece to the puzzle, which is a place to put one or more <strong>MenuButton</strong>s. I won&rsquo;t create a whole scene for that. Instead it will be part of a test stage that I will use to demonstrate the functionality. That test scene will have a menu bar at the top with one <strong>MenuButton</strong> which we will label &ldquo;Roll a Die&rdquo;. Once clicked it will show the menu, which we will populate with options for different dice. To make the example complete we will actuall roll that dice and display the result. So let&rsquo;s get to creating our test stage.</p>
<h2 id="test-stage">Test Stage</h2>
<p>Create a new scene with a <code>Control</code> root and call that node <strong>Stage</strong>. Save the scene under <em>res://src/Stage.tscn</em>. Now we add a <code>PanelContainer</code> and call it <strong>MenuBar</strong>. Add an <code>HBoxContainer</code> as a child of that. Add an instance of the <strong>MenuButton</strong> to the <code>HBoxContainer</code>. Now add a <code>Label</code> as a second child of the <strong>Stage</strong> node, and call it <strong>DemoLabel</strong>. Add a <code>Tween</code> and a <code>Timer</code> as children of the <strong>DemoLabel</strong>.</p>
<p><img src="TestStage_SceneTree.png" alt="Test Stage Scene Tree"></p>
<p>Now for configuring everything. For the <strong>Stage</strong> set the <em>Layout</em> to <em>Full Rect</em> (in the main panel). Set the <strong>MenuBar</strong> <em>Layout</em> to <em>Top Wide</em>. Also in the <em>Theme Overrides</em>, <em>Styles</em> create a new &lsquo;StyleBoxTexture&rsquo; in the <em>Panel</em> property. Add <em>res://assets/UI/buttonSquare_brown_pressed.png</em> as its <em>Texture</em> Then, set all the _Margin_s to 7. Moving on to the <strong>DemoLabel</strong> we set the <em>Layout</em> to <em>Full Rect</em>, and then set both <em>Align</em> and <em>V Align</em> to <em>Center</em>. Under <em>Theme Overrides &gt; Fonts</em> we create a new &lsquo;DynamicFont&rsquo; resource for the <em>Font</em>. Set its <em>Size</em> to 65, its <em>Outline</em> to 2, and its <em>Outline Color</em> to black. Then drag <em>res://assets/Font/Kenney Future.ttf</em> into the <em>Font Data</em> slot. Lastly, we set the <strong>Timer</strong>&rsquo;s <em>Wait Time</em> to 2, and check the <em>One Shot</em> property.</p>
<p>Now we can move our attention to configuring the <strong>MenuButton</strong>. Set its <em>Text</em> to <em>&ldquo;Roll a Die&rdquo;</em>, and its <em>Menu ID</em> to <em>&ldquo;dice&rdquo;</em>. Click on the <em>Menu Options</em> and increase its <em>Size</em> to 6. Now we have six empty slots, numbered 0 to 5. Click into the 0 slot and find and click <em>&ldquo;New MenuItemConfig&rdquo;</em>. Configure this <code>MenuItemConfig</code> by setting its <em>Text</em> to <em>&ldquo;Roll a D4&rdquo;</em>, the <em>Button ID</em> to <em>&ldquo;d4&rdquo;</em>, and by dragging <em>res://assets/Icons/d4_outline_number.png</em> into the <em>Icon</em> slot. Lastly, choose a color you like for <em>Icon Color</em> (preferrably something that contrasts the brown button backgrounds we use). For the other 6 dice you can drag the resource we just created into the other slots in the array. Then, before you modify them right click each resource, scroll down all the way to the bottom and click <em>Make Unique</em>. By default the resources would be the same, i.e., their data would be linked. By making them unique we effectively create copies we can independently edit, which is what we do next. Go through all of them, and edit the <em>Text</em>, <em>Button ID</em>, and <em>Icon</em> to reflect our different dice. After the d4, we want a d6, then a d8, a d10, a d12, and finally a d20. You can change the colors to something you like. Now that everything is set up as we need it, we will move to the code.</p>
<p>I&rsquo;ll start with the code of out text display, so you know what we&rsquo;ll be showing. Add a script to <strong>DemoLabel</strong>, and save it under <em>res://src/TestLabel.gd</em>. Let&rsquo;s look at the top of the script.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Label</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> fade_duration: <span style="color:#66d9ef">float</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> tween: <span style="color:#a6e22e">Tween</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$Tween</span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> timer: <span style="color:#a6e22e">Timer</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$Timer</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> rng <span style="color:#f92672">:=</span> <span style="color:#a6e22e">RandomNumberGenerator</span><span style="color:#f92672">.</span><span style="color:#a6e22e">new</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_ready</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	modulate <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>transparent
</span></span><span style="display:flex;"><span>	rng<span style="color:#f92672">.</span>randomize()
</span></span></code></pre></div><p>As we&rsquo;ve done a few time now, we first set a <code>fade_duration</code>. We also need access to both the <strong>Timer</strong> and the <strong>Tween</strong> child nodes, so we reference them as <code>onready</code> variables. As this display will show dice rolls, we need a random number generator, which we call <em>rng</em>. Then in the <code>_ready()</code> function we make the node initially invisible by setting its <em>modulate</em> to be transparent, and also we randomize our <code>RandomNumberGenerator</code>. Next up is the function the displays the results.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">show_result</span>(die: <span style="color:#a6e22e">String</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> dice_number <span style="color:#f92672">:=</span> <span style="color:#66d9ef">int</span>(die<span style="color:#f92672">.</span><span style="color:#a6e22e">substr</span>(<span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> result <span style="color:#f92672">=</span> rng<span style="color:#f92672">.</span>randi_range(<span style="color:#ae81ff">1</span>, dice_number)
</span></span><span style="display:flex;"><span>	text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Rolled a </span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Rusult: </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> [die, result]
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">remove_all</span>()
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">interpolate_property</span>(
</span></span><span style="display:flex;"><span>		self, 
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;modulate:a&#34;</span>, 
</span></span><span style="display:flex;"><span>		modulate<span style="color:#f92672">.</span>a,
</span></span><span style="display:flex;"><span>		<span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>		fade_duration <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>modulate<span style="color:#f92672">.</span>a)
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span>()
</span></span><span style="display:flex;"><span>	timer<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span>()
</span></span></code></pre></div><p>This is a bit hacky, but it works for the purpose of this tutorial. Remember how we&rsquo;ve set all the _Button ID_s to <em>&ldquo;d4&rdquo;</em>, <em>&ldquo;d6&rdquo;</em> and so on previously? That ID is what will be passed into this function. In the first line we extract the number of sides of the die. We do this by first extracting a substring. <code>die.substring(1)</code> will give us a substring starting from index 1, i.e., the second letter, directly after the <a href="https://www.youtube.com/watch?v=dv13gl0a-FA">initial d</a> all the way to the end. We wrap this in a call to ìnt()`, which will convert it to the number we want. Next we let the <em>rng</em> generate a <em>result</em> which is drawn from a uniform distribution ranging from 1 to the number of sides on the die. We then generate a string detailing what die was rolled and what the result was. The rest of the function which fades in the text from transparent to opaque shoudl be familar by now. We close the function by starting the timer which will trigger the fade out.</p>
<p>We need one more function which will trigger said fade out from the <em>timeout()</em> signal of the <strong>Timer</strong> node. So from the <strong>Timer</strong> node connect this signal to a <code>_on_Timer_timeout</code> method on the <strong>DemoLabel</strong>. We will the created function with the following.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_on_Timer_timeout</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">interpolate_property</span>(
</span></span><span style="display:flex;"><span>		self,
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;modulate:a&#34;</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#ae81ff">0</span>, 
</span></span><span style="display:flex;"><span>		fade_duration
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span>()
</span></span></code></pre></div><p>So two seconds after the <strong>Timer</strong> times out, we fade the <strong>DemoLabel</strong> to transparent again. The neat thing of doing it this way is that even if we are quick and trigger the <code>show_result()</code> method multiple times, that method will simply reset the <strong>Timer</strong>, meaning the label will only fade out two seconds after the last <code>show_result()</code>.</p>
<p>Now let us move on to the <strong>MenuBar</strong>, which is actually the last missing piece of the puzzle for our system.</p>
<p>extends PanelContainer</p>
<p>signal button_pressed(menu, button)</p>
<p>onready var h_box: HBoxContainer = $HBoxContainer</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">PanelContainer</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">signal</span> <span style="color:#a6e22e">button_pressed</span>(menu, button)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> h_box: <span style="color:#a6e22e">HBoxContainer</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$HBoxContainer</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_ready</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> spawn_y: <span style="color:#66d9ef">float</span> <span style="color:#f92672">=</span> rect_global_position<span style="color:#f92672">.</span>y <span style="color:#f92672">+</span> rect_size<span style="color:#f92672">.</span>y
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> menu_button <span style="color:#f92672">in</span> h_box<span style="color:#f92672">.</span><span style="color:#a6e22e">get_children</span>():
</span></span><span style="display:flex;"><span>		menu_button<span style="color:#f92672">.</span>spawn_y <span style="color:#f92672">=</span> spawn_y
</span></span><span style="display:flex;"><span>		menu_button<span style="color:#f92672">.</span><span style="color:#a6e22e">connect</span>(<span style="color:#e6db74">&#34;button_pressed&#34;</span>, self, <span style="color:#e6db74">&#34;_on_MenuButton_button_pressed&#34;</span>)
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_on_MenuButton_button_pressed</span>(menu: <span style="color:#a6e22e">String</span>, button: <span style="color:#a6e22e">String</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">emit_signal</span>(<span style="color:#e6db74">&#34;button_pressed&#34;</span>, menu, button)
</span></span></code></pre></div><p>This is pretty straight forward. The most interesting thing to point out here is how we get the lower bound of the <strong>MenuBar</strong> itself and use it as the <em>spawn_y</em> variable we introduced earlier. The <strong>MenuBar</strong> acts as a root for multiple <strong>MenuButton</strong> menus (even though in this demo we only use one). To manage them automatically it iterates over all the children of the <code>HBoxContainer</code>, sets their <em>spawn_y</em> and connects them to <code>_on_MenuButton_button_pressed()</code>. This mentioned function simply relays the signal and thereby bundles it. We can have multiple menus with multiple items each and we will only need to listen to the <strong>MenuBar</strong>&rsquo;s <em>button_pressed()</em> signal to handle all these events. Note here that iterating in this way could be made safer. My intent is that the <strong>MenuBar</strong> (or more specifically its <code>HBoxContainer</code> child) will only be filled with <strong>MenuButton</strong> nodes. If you intend to mix and match here, then please make sure you check that what you&rsquo;re iterating over actually is a <strong>MenuButton</strong>.</p>
<p>We now need to connect the menu and the label. Intuitively you&rsquo;d thing we could just connect <em>button_pressed()</em> signal from the <strong>MenuBar</strong> to the <strong>DemoLabel</strong>&rsquo;s <code>show_result()</code> function. However, the arguments we have set up for that signal does not match the expected arguments of that function. So we&rsquo;ll choose a different route. Add a new script to the <strong>Stage</strong> root node and save it as <em>res://src/Stage.gd</em>. Add the following code.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gd" data-lang="gd"><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Control</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>onready <span style="color:#66d9ef">var</span> demo_label: <span style="color:#a6e22e">Label</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">$DemoLabel</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">_on_MenuBar_button_pressed</span>(_menu, button) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span>:
</span></span><span style="display:flex;"><span>	demo_label<span style="color:#f92672">.</span><span style="color:#a6e22e">show_result</span>(button)
</span></span></code></pre></div><p>This function wraps the function call how we need it. I also don&rsquo;t believe this is superflous, because once we have multiple menus we might also want to do the filtering here to make sure the button-press came from the right menu. All that&rsquo;s left to do is to connect the <em>button_pressed()</em> signal from the <strong>MenuBar</strong> to the <code>_on_MenuBar_button_pressed()</code> function on the <strong>Stage</strong> node via the editor. Once you have done that you can run the scene and look at the result.</p>
<h2 id="running-the-project">Running the Project</h2>
<p>In the running project you can hover over the button and click it, which will cause the menu to appear. You can quickly move the mouse over the menu items and see how their highlight reacts. If you click outside the menu it will close. And finally if you click on one of the menu entries you can see a message with the result of the dice throw appearing.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This was a slightly longer tutorial. I hope you could follow it. If there have been problems at any point, and your project is not doing what it should, check out my complete project in its GitHub repository. <a href="https://github.com/SelinaDev/03_Drop_Down_Menus">https://github.com/SelinaDev/03_Drop_Down_Menus</a>.</p>
<p>I hope I got the most important points across here, which is how to combine <code>Container</code> and non-<code>Container</code> <code>Control</code> nodes by breaking the nesting of <code>Containers</code> and manuall/procedually adjusting their position. I believe this is a very important trick for making interesting and slightly more complex UIs in Godot.</p>
<p>If you notice and bugs or mistakes, either in the code or here in the text, feel free to contact me. You can find me on Twitter as <a href="https://twitter.com/SelinaDev">@SelinaDev</a> (and probably soon on Mastodon).</p>




      </main>
  </div>
  </body>
</html>
