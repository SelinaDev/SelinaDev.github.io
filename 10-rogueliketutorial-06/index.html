<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="generator" content="Hugo 0.92.2" />
  <link rel="canonical" href="https://selinadev.github.io/10-rogueliketutorial-06/">

  
    
    <meta name="description" content="Part 6: Doing (and taking) some damage Welcome back to the roguelike tutorial series. This tutorial will continue from where the last one left off. You can find the previous tutorial here: https://selinadev.github.io/09-rogueliketutorial-05/
Refactoring At this point the original tutorial refactors some code, and we will do so as well. Some things will turn out cleaner this way (and I will have to keep less differences in mind when converting the code).">
  

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#000000">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" type="text/css" href="/css/paper.css">

  
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css">
  
  
    
  

  
  
  <title>Yet Another Roguelike Tutorial, Part 6 | SelinaDev</title>
</head>

  <body>
    <div class="container paper">
      <nav class="border split-nav">
  <div class="nav-brand">
    <h3><a href="/">SelinaDev</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
    <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
      
        <li><a href="/">Blog</a></li>
      
        <li><a href="/tags/">Tags</a></li>
      
        <li><a href="/about/">About</a></li>
      
      </ul>
    </div>
  </div>
</nav>
      <main>
        

<h1 class="post-title">Yet Another Roguelike Tutorial, Part 6</h1>


<strong>Publish date: </strong>Jul 28, 2023
<br>

  <strong>Tags: </strong>
  
    <a href="/tags/godot4">godot4</a>
  
    <a href="/tags/tutorial">tutorial</a>
  
    <a href="/tags/roguelike">roguelike</a>
  



  

<div class="child-borders">
  <div class="toc border" aria-labelledby="toc-heading">
    <h2 id="toc-heading">Table of contents</h2>
    <ol>
      
        <li>
          
          
          
          
          <a href="#refactoring">
            Refactoring
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#part-6">
            Part 6
          </a>
        </li>
      
    </ol>
  </div>
</div>



<h1 id="part-6-doing-and-taking-some-damage">Part 6: Doing (and taking) some damage</h1>
<p>Welcome back to the roguelike tutorial series. This tutorial will continue from where the last one left off. You can find the previous tutorial here: <a href="https://selinadev.github.io/09-rogueliketutorial-05/">https://selinadev.github.io/09-rogueliketutorial-05/</a></p>
<h2 id="refactoring">Refactoring</h2>
<p>At this point the original tutorial refactors some code, and we will do so as well. Some things will turn out cleaner this way (and I will have to keep less differences in mind when converting the code).</p>
<p>First, let&rsquo;s start with the action system. We won&rsquo;t really change how we use it now, but in principle the Command Pattern allows delaying a command (or <em>action</em> as we call it here). We only delay it very little, creating an action in one function and executing it once it&rsquo;s returned. That&rsquo;s why we can easily keep track of the entity associated with that action, and therefore can pass it once we call <code>perform()</code>. But a better way would be to encode the entity right in the action, so once we have the action we only need to call <code>perform()</code>, without any arguments, and whatever action we encoded before just happens.</p>
<p>Now, we passed a <code>Game</code> argument into actions before. That was easy, as the <strong>Game</strong> node was the one executing the actions. However, getting that at the time of construction would be a bit wonky. Sure, we could pass a reference to the game to the <strong>EventHandler</strong> node. However, we only really needed the game to get access to the <code>map_data</code>. So the simplest way forward is to give entities a reference to the map data. We need to know the entity anyway for the action, so that&rsquo;s a good place to put that information. So let&rsquo;s adapt <em>entity.gd</em> a bit:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">var</span> _definition: EntityDefinition
<span style="color:#66d9ef">var</span> map_data: MapData

<span style="color:#66d9ef">func</span> _init(map_data: MapData, start_position: Vector2i, entity_definition: EntityDefinition) <span style="color:#f92672">-&gt;</span> void:
	centered <span style="color:#f92672">=</span> false
	grid_position <span style="color:#f92672">=</span> start_position
	self<span style="color:#f92672">.</span>map_data <span style="color:#f92672">=</span> map_data
	set_entity_type(entity_definition)
</code></pre></div><p>In our variables we simply create a new variable to hold the <code>map_data</code>, which is filled in the constructor. The first entity created is the player, and we need to handle them a bit separately. We change how the player is created in <em>game.gd</em> in the <code>_ready()</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _ready() <span style="color:#f92672">-&gt;</span> void:
	player <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(null, Vector2i<span style="color:#f92672">.</span>ZERO, player_definition)
	remove_child(camera)
	player<span style="color:#f92672">.</span>add_child(camera)
	map<span style="color:#f92672">.</span>generate(player)
	map<span style="color:#f92672">.</span>update_fov(player<span style="color:#f92672">.</span>grid_position)
</code></pre></div><p>The player is a bit of an odd case, as we create it before we create the map. We therefore pass <code>null</code> here, and set the <code>map_data</code> manually later. We do so in <em>dungeon_generator.gd</em>, when we place the player in <code>generate_dungeon()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">if</span> rooms<span style="color:#f92672">.</span>is_empty():
    player<span style="color:#f92672">.</span>grid_position <span style="color:#f92672">=</span> new_room<span style="color:#f92672">.</span>get_center()
    player<span style="color:#f92672">.</span>map_data <span style="color:#f92672">=</span> dungeon
<span style="color:#66d9ef">else</span>:
    _tunnel_between(dungeon, rooms<span style="color:#f92672">.</span>back()<span style="color:#f92672">.</span>get_center(), new_room<span style="color:#f92672">.</span>get_center())
</code></pre></div><p>Here we simply add a line where we set the player&rsquo;s <code>map_data</code> to <code>dungeon</code>, which is the <code>MapData</code> object the game will use. In the same script we also modify <code>_place_entities()</code> which is responsible for instantiating new enemies:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">if</span> can_place:
			<span style="color:#66d9ef">var</span> new_entity: Entity
			<span style="color:#66d9ef">if</span> _rng<span style="color:#f92672">.</span>randf() <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.8</span>:
				new_entity <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(dungeon, new_entity_position, entity_types<span style="color:#f92672">.</span>orc)
			<span style="color:#66d9ef">else</span>:
				new_entity <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(dungeon, new_entity_position, entity_types<span style="color:#f92672">.</span>troll)
			dungeon<span style="color:#f92672">.</span>entities<span style="color:#f92672">.</span>append(new_entity)
</code></pre></div><p>Here we just modified the calls to <code>Entity.new()</code> to also pass <code>dungeon</code>. With that out of the way we can get to the actual actions we wanted to modify. Go into <em>action.gd</em> and replace it with the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name Action
<span style="color:#66d9ef">extends</span> RefCounted

<span style="color:#66d9ef">var</span> entity: Entity


<span style="color:#66d9ef">func</span> _init(entity: Entity) <span style="color:#f92672">-&gt;</span> void:
	self<span style="color:#f92672">.</span>entity <span style="color:#f92672">=</span> entity


<span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">pass</span>


<span style="color:#66d9ef">func</span> get_map_data() <span style="color:#f92672">-&gt;</span> MapData:
	<span style="color:#66d9ef">return</span> entity<span style="color:#f92672">.</span>map_data

</code></pre></div><p>We add a new variable to hold the <code>entity</code> performing the action. We pass this entity during the creation of the action, in the new <code>_init()</code> function. <code>perform()</code>, however, now loses all its arguments. Lastly, we create a convenient way to get the <code>map_data</code> from the <code>entity</code>, by creating the <code>get_map_data()</code> function. Next we have to go over all the actions we have and modify them to this new interface. Here&rsquo;s <em>escape_action.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name EscapeAction
<span style="color:#66d9ef">extends</span> Action


<span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> void:
	entity<span style="color:#f92672">.</span>get_tree()<span style="color:#f92672">.</span>quit()
</code></pre></div><p>As mentioned, we remove the arguments and simply call <code>get_tree().quit()</code> from the <code>entity</code>. Here is the new <em>action_with_direction.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name ActionWithDirection
<span style="color:#66d9ef">extends</span> Action

<span style="color:#66d9ef">var</span> offset: Vector2i


<span style="color:#66d9ef">func</span> _init(entity: Entity, dx: <span style="color:#a6e22e">int</span>, dy: <span style="color:#a6e22e">int</span>) <span style="color:#f92672">-&gt;</span> void:
	super<span style="color:#f92672">.</span>_init(entity)
	offset <span style="color:#f92672">=</span> Vector2i(dx, dy)


<span style="color:#66d9ef">func</span> get_destination() <span style="color:#f92672">-&gt;</span> Vector2i:
	<span style="color:#66d9ef">return</span> entity<span style="color:#f92672">.</span>grid_position <span style="color:#f92672">+</span> offset


<span style="color:#66d9ef">func</span> get_blocking_entity_at_destination() <span style="color:#f92672">-&gt;</span> Entity:
	<span style="color:#66d9ef">return</span> get_map_data()<span style="color:#f92672">.</span>get_blocking_entity_at_location(get_destination())
</code></pre></div><p>Here, we modify the <code>_init()</code> function to also take in the <code>entity</code> as an argument. As we overload the <code>Action</code> constructor here, we must explicitly call <code>super._init(entity)</code>. Beyond that we create two more convenience functions, one to calculate the destination coordinates, and one to get a blocking entity from that destination. Next, <em>melee_action.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name MeleeAction
<span style="color:#66d9ef">extends</span> ActionWithDirection


<span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> target: Entity <span style="color:#f92672">=</span> get_blocking_entity_at_destination()
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> target:
		<span style="color:#66d9ef">return</span>
		
	print(<span style="color:#e6db74">&#34;You kick the </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">, much to it&#39;s annoyance!&#34;</span> <span style="color:#f92672">%</span> target<span style="color:#f92672">.</span>get_entity_name())
</code></pre></div><p>Here we get to use <code>get_blocking_entity_at_location()</code> to write our code a bit more concisely. We do a similar thing in <em>movement_action.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name MovementAction
<span style="color:#66d9ef">extends</span> ActionWithDirection


<span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> map_data: MapData <span style="color:#f92672">=</span> get_map_data()
	<span style="color:#66d9ef">var</span> destination_tile: Tile <span style="color:#f92672">=</span> map_data<span style="color:#f92672">.</span>get_tile(get_destination())
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> destination_tile <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> destination_tile<span style="color:#f92672">.</span>is_walkable():
		<span style="color:#66d9ef">return</span>
	<span style="color:#66d9ef">if</span> get_blocking_entity_at_destination():
		<span style="color:#66d9ef">return</span>
	entity<span style="color:#f92672">.</span>move(offset)
</code></pre></div><p>A bit different, but ultimately nothing special here. Lastly, <em>bump_action.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name BumpAction
<span style="color:#66d9ef">extends</span> ActionWithDirection


<span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">if</span> get_target_actor():
		MeleeAction<span style="color:#f92672">.</span>new(entity, offset<span style="color:#f92672">.</span>x, offset<span style="color:#f92672">.</span>y)<span style="color:#f92672">.</span>perform()
	<span style="color:#66d9ef">else</span>:
		MovementAction<span style="color:#f92672">.</span>new(entity, offset<span style="color:#f92672">.</span>x, offset<span style="color:#f92672">.</span>y)<span style="color:#f92672">.</span>perform()
</code></pre></div><p>With our actions modified, let&rsquo;s now modify <em>EventHandler.gd</em> where the actions are generated. The first thing we will do is rename it. It took me until now to notice that the <code>EventHandler</code> class name is overloading an internal class of Godot. Also, I messed up when creating the file, and used the wrong capitalization. So first let&rsquo;s rename the file to <em>input_handler.gd</em>. Then, modify that script as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name InputHandler
<span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Node</span>


<span style="color:#66d9ef">func</span> get_action(player: Entity) <span style="color:#f92672">-&gt;</span> Action:
	<span style="color:#66d9ef">var</span> action: Action <span style="color:#f92672">=</span> null
	
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;ui_up&#34;</span>):
		action <span style="color:#f92672">=</span> BumpAction<span style="color:#f92672">.</span>new(player, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
	<span style="color:#66d9ef">elif</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;ui_down&#34;</span>):
		action <span style="color:#f92672">=</span> BumpAction<span style="color:#f92672">.</span>new(player, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>)
	<span style="color:#66d9ef">elif</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;ui_left&#34;</span>):
		action <span style="color:#f92672">=</span> BumpAction<span style="color:#f92672">.</span>new(player, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>)
	<span style="color:#66d9ef">elif</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;ui_right&#34;</span>):
		action <span style="color:#f92672">=</span> BumpAction<span style="color:#f92672">.</span>new(player, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>)
	
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;ui_cancel&#34;</span>):
		action <span style="color:#f92672">=</span> EscapeAction<span style="color:#f92672">.</span>new(player)
	
	<span style="color:#66d9ef">return</span> action
</code></pre></div><p>Now that we changed the <code>class_name</code> we no longer have that name collision. Now, in our our main scene also change the name of the <strong>EventHandler</strong> node to <strong>InputHandler</strong>. Also, we now pass the <code>player</code> into <code>get_action()</code> and use it to create our actions. The last piece to this puzzle is to modify <em>game.gd</em>. First, we need to reflect the changed class name where we type the variables:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> player: Entity
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> input_handler: InputHandler <span style="color:#f92672">=</span> <span style="color:#f92672">$</span>InputHandler
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> map: Map <span style="color:#f92672">=</span> <span style="color:#f92672">$</span>Map
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> camera: <span style="color:#a6e22e">Camera2D</span> <span style="color:#f92672">=</span> <span style="color:#f92672">$</span><span style="color:#a6e22e">Camera2D</span>
</code></pre></div><p>Here we change all the event handler naming to input handler. Now we need to modify <code>_physics_process()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _physics_process(_delta: <span style="color:#a6e22e">float</span>) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> action: Action <span style="color:#f92672">=</span> event_handler<span style="color:#f92672">.</span>get_action()
	<span style="color:#66d9ef">if</span> action:
		<span style="color:#66d9ef">var</span> previous_player_position: Vector2i <span style="color:#f92672">=</span> player<span style="color:#f92672">.</span>grid_position
		action<span style="color:#f92672">.</span>perform()
		<span style="color:#66d9ef">if</span> player<span style="color:#f92672">.</span>grid_position <span style="color:#f92672">!=</span> previous_player_position:
			map<span style="color:#f92672">.</span>update_fov(player<span style="color:#f92672">.</span>grid_position)
		_handle_enemy_turns()
</code></pre></div><p>Here we change <code>action.perform(self, player)</code> to <code>action.perform()</code>, as the action already knows everything it needs to perform itself. Now that we have the refactoring out of the way we can move on to &hellip;</p>
<h2 id="part-6">Part 6</h2>
<p>In this tutorial we will create our combat system. This will include things like health and dealing damage. This also includes a (very simple) enemy AI. We will do this by composition. Entities will be able to hold several components that extend their functionality. A <em>Fighter</em> component will hold health and similar. And an <em>AI</em> component will handle the actions the enemies will perform.</p>
<p>One deviation from the original tutorial will be that I will omit the <code>Actor</code> class. I wasn&rsquo;t sure which approach I preferred, because the other option is to extend our <code>Entity</code> class by some functions that don&rsquo;t really make sense for non-actors. However, strict inheritance is also limiting. A fighter component allows an entity to have a health stat, allows it to be attacked by other entities, and allows it to be destroyed. If we wanted to have, say, an obstacle like a barrel, or a door, then that&rsquo;s just what we would want of this. If we were to go the inheritance route we would need to make that barrel an actor, even though it won&rsquo;t act. We won&rsquo;t create things like barrels or doors in this tutorial series, but extensibility is still something I want to consider. Therefore I prefer to just use composition, to give every entity the option to have any component. This means we have to give things like the <code>is_alive()</code> function to all entities, but technically we can ask if, for example a barrel, is alive. You notice though that I still use the actor terminology in the directory structure though, just to organize things a bit better.</p>
<p>So let&rsquo;s start with components. We will start with a simple base component. Create a new script extending <code>Node</code> at <em>res://src/Entities/Actors/Components/base_component.gd</em>. It&rsquo;ll look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name Component
<span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Node</span>

<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> entity: Entity <span style="color:#f92672">=</span> get_parent() as Entity


<span style="color:#66d9ef">func</span> get_map_data() <span style="color:#f92672">-&gt;</span> MapData:
	<span style="color:#66d9ef">return</span> entity<span style="color:#f92672">.</span>map_data
</code></pre></div><p>We use an <code>@onready</code> variable to get the entity the component will be attached to. The components will be attached directly to entities, so we can just get the parent. We will also very often need access to the <code>map_data</code>, so we again create our familiar convenience function. Now let&rsquo;s create an actually useful component. Create a new script extending <code>Component</code> at <em>res://src/Entity/Actors/Components/fighter_component.gd</em>. Here&rsquo;s the code for that component:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name FighterComponent
<span style="color:#66d9ef">extends</span> Component

<span style="color:#66d9ef">var</span> max_hp: <span style="color:#a6e22e">int</span>
<span style="color:#66d9ef">var</span> hp: <span style="color:#a6e22e">int</span>:
	set(value):
		hp <span style="color:#f92672">=</span> clampi(value, <span style="color:#ae81ff">0</span>, max_hp)
<span style="color:#66d9ef">var</span> defense: <span style="color:#a6e22e">int</span>
<span style="color:#66d9ef">var</span> power: <span style="color:#a6e22e">int</span>


<span style="color:#66d9ef">func</span> _init(definition: FighterComponentDefinition) <span style="color:#f92672">-&gt;</span> void:
	max_hp <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>max_hp
	hp <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>max_hp
	defense <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>defense
	power <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>power
</code></pre></div><p>A fighter component holds the maximum health points, current health points, defense, and power of the entity. The <code>hp</code> variable representing the current health points has a setter that ensures that health point values stay between 0 and <code>max_hp</code>. You also see that all these values are initialized from a <code>FighterComponentDefinition</code>, an approach we already used for entities, as well as tiles. You will soon see why using this resource-driven approach is especially useful, but first we need to create that resource type. Create a new script extending <code>Resource</code> at <em>res://src/Entities/Actors/Components/ComponentDefinitions/fighter_component_definition.gd</em>. It will hold the initial values for a <code>FighterComponent</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name FighterComponentDefinition
<span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Resource</span>

<span style="color:#960050;background-color:#1e0010">@</span>export_category(<span style="color:#e6db74">&#34;Stats&#34;</span>)
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> max_hp: <span style="color:#a6e22e">int</span>
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> power: <span style="color:#a6e22e">int</span>
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> defense: <span style="color:#a6e22e">int</span>
</code></pre></div><p>Before we attach things to our entities, let&rsquo;s handle the AI. However, there are a few prerequisites for that as well. The AI will use pathfinding, so we want a system for that. Pathfinding will be the responsibility of the <code>MapData</code> class. So let&rsquo;s modify <em>map_data.gd</em> a bit:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">const</span> entity_pathfinding_weight <span style="color:#f92672">=</span> <span style="color:#ae81ff">10.0</span>

<span style="color:#66d9ef">var</span> width: <span style="color:#a6e22e">int</span>
<span style="color:#66d9ef">var</span> height: <span style="color:#a6e22e">int</span>
<span style="color:#66d9ef">var</span> tiles: <span style="color:#a6e22e">Array</span>[Tile]
<span style="color:#66d9ef">var</span> entities: <span style="color:#a6e22e">Array</span>[Entity]
<span style="color:#66d9ef">var</span> player: Entity
<span style="color:#66d9ef">var</span> pathfinder: AStarGrid2D
</code></pre></div><p>We add two things at the start of the script. We create a new constant called <code>entity_pathfinding_weight</code>. This is the weight we use for blocking entities. These entities block actual movement, and we want other entities to try pathfinding around them wherever possible, but we don&rsquo;t actually want to block pathfinding through them. Suppose a player flees into a corridor, followed by two orcs. If the orc closer to the player would block the other orc&rsquo;s pathfinding, that other orc would seemingly run away from the action while he tries to find a way to the players position through any other corridor and room. By blocking entities just increasing the weight for the pathfinding, the orc will go around the other orc when it can, but queue up nicely behind the other orc if other paths would be too long. Apart from the pathfinding weight we also add a <code>pathfinder</code> variable of type <code>AStarGrid2D</code>. This version of the A* algorithm makes pathfinding on a grid pretty easy. Now let&rsquo;s add some functions to manage the pathfinder:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> register_blocking_entity(entity: Entity) <span style="color:#f92672">-&gt;</span> void:
	pathfinder<span style="color:#f92672">.</span>set_point_weight_scale(entity<span style="color:#f92672">.</span>grid_position, entity_pathfinding_weight)


<span style="color:#66d9ef">func</span> unregister_blocking_entity(entity: Entity) <span style="color:#f92672">-&gt;</span> void:
	pathfinder<span style="color:#f92672">.</span>set_point_weight_scale(entity<span style="color:#f92672">.</span>grid_position, <span style="color:#ae81ff">0</span>)
</code></pre></div><p>We have two functions to register and unregister blocking entities on the pathfinder. The register function tells the pathfinder that the entity is there by setting the pathfinding weight on the entities position to <code>entity_pathfinding_weight</code>, just as we described above. To tell the pathfinder the entity isn&rsquo;t there anymore, we use the unregister function, which sets the weight back to 0. However, we still need to setup the pathfinder properly, so it knows which tiles are walkable and which are not.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> setup_pathfinding() <span style="color:#f92672">-&gt;</span> void:
	pathfinder <span style="color:#f92672">=</span> AStarGrid2D<span style="color:#f92672">.</span>new()
	pathfinder<span style="color:#f92672">.</span>region <span style="color:#f92672">=</span> Rect2i(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, width, height)
	pathfinder<span style="color:#f92672">.</span>update()
	<span style="color:#66d9ef">for</span> y <span style="color:#f92672">in</span> height:
		<span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> width:
			<span style="color:#66d9ef">var</span> grid_position :<span style="color:#f92672">=</span> Vector2i(x, y)
			<span style="color:#66d9ef">var</span> tile: Tile <span style="color:#f92672">=</span> get_tile(grid_position)
			pathfinder<span style="color:#f92672">.</span>set_point_solid(grid_position, <span style="color:#f92672">not</span> tile<span style="color:#f92672">.</span>is_walkable())
	<span style="color:#66d9ef">for</span> entity <span style="color:#f92672">in</span> entities:
		<span style="color:#66d9ef">if</span> entity<span style="color:#f92672">.</span>is_blocking_movement():
			register_blocking_entity(entity)
</code></pre></div><p>Here we first create a new <code>AStarGrid2D</code> instance and set it to the dimensions of the map (which requires us to call <code>update()</code>). We then go through the whole map. Unfortunately we can&rsquo;t just loop through the <code>tiles</code>, which is why we have nested loops for y and x. We then have a position, we retrieve a tile, and subsequently set the set that point in the pathfinder to solid if the tile is walkable. After that we go through all the entities and register them if they are blocking entities. You see that this kind of setup requires a finished dungeon. That&rsquo;s why we need to call it in <em>dungeon_generator.gd</em>, at the end just before the <code>return</code> statement of <code>generate_dungeon()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">    <span style="color:#66d9ef">if</span> rooms<span style="color:#f92672">.</span>is_empty():
        player<span style="color:#f92672">.</span>grid_position <span style="color:#f92672">=</span> new_room<span style="color:#f92672">.</span>get_center()
        player<span style="color:#f92672">.</span>map_data <span style="color:#f92672">=</span> dungeon
    <span style="color:#66d9ef">else</span>:
        _tunnel_between(dungeon, rooms<span style="color:#f92672">.</span>back()<span style="color:#f92672">.</span>get_center(), new_room<span style="color:#f92672">.</span>get_center())
    
    _place_entities(dungeon, new_room)
    
    rooms<span style="color:#f92672">.</span>append(new_room)

dungeon<span style="color:#f92672">.</span>setup_pathfinding()
<span style="color:#66d9ef">return</span> dungeon
</code></pre></div><p>The last thing we need to do is some management of reflecting moving entities in the pathfinder. We can do this in <em>entity.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> move(move_offset: Vector2i) <span style="color:#f92672">-&gt;</span> void:
	map_data<span style="color:#f92672">.</span>unregister_blocking_entity(self)
	grid_position <span style="color:#f92672">+=</span> move_offset
	map_data<span style="color:#f92672">.</span>register_blocking_entity(self)
</code></pre></div><p>Now we unregister the entity from its current position before it moves, then we actually move it, followed by registering it at the new position. Now the pathfinder will properly be updated to the current state of the game. With all that in place, we can now move to the AI.</p>
<p>We start with a base AI by creating a new script extending <code>Component</code> at <em>res://src/Entities/Actors/Components/base_ai_component.gd</em>. It will simply define the functions all AIs will have:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name BaseAIComponent
<span style="color:#66d9ef">extends</span> Component


<span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">pass</span>


<span style="color:#66d9ef">func</span> get_point_path_to(destination: Vector2i) <span style="color:#f92672">-&gt;</span> PackedVector2Array:
	<span style="color:#66d9ef">return</span> get_map_data()<span style="color:#f92672">.</span>pathfinder<span style="color:#f92672">.</span>get_point_path(entity<span style="color:#f92672">.</span>grid_position, destination)
</code></pre></div><p>We will have a <code>perform()</code> function that will work similar to actions (the original tutorial actually uses multiple inheritance to have the AI also extend the <code>Action</code> class, but this will work just as well). We also have a <code>get_point_path_to()</code> function which gives us a path from one point on the map to another, using our new pathfinding functionality. With all the work we already did this is thankfully just a one-liner. This isn&rsquo;t an exciting AI yet, so let&rsquo;s make an actually useful one. Create a new script extending <code>BaseAIComponent</code> at <em>res://src/Entities/Actors/Components/hostile_enemy_ai_component.gd</em>. The AI will look as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name HostileEnemyAIComponent
<span style="color:#66d9ef">extends</span> BaseAIComponent


<span style="color:#66d9ef">var</span> path: <span style="color:#a6e22e">Array</span> <span style="color:#f92672">=</span> []

<span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> target: Entity <span style="color:#f92672">=</span> get_map_data()<span style="color:#f92672">.</span>player
	<span style="color:#66d9ef">var</span> target_grid_position: Vector2i <span style="color:#f92672">=</span> target<span style="color:#f92672">.</span>grid_position
	<span style="color:#66d9ef">var</span> offset: Vector2i <span style="color:#f92672">=</span> target_grid_position <span style="color:#f92672">-</span> entity<span style="color:#f92672">.</span>grid_position
	<span style="color:#66d9ef">var</span> distance: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> max(abs(offset<span style="color:#f92672">.</span>x), abs(offset<span style="color:#f92672">.</span>y))
	
	<span style="color:#66d9ef">if</span> get_map_data()<span style="color:#f92672">.</span>get_tile(entity<span style="color:#f92672">.</span>grid_position)<span style="color:#f92672">.</span>is_in_view:
		<span style="color:#66d9ef">if</span> distance <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>:
			<span style="color:#66d9ef">return</span> MeleeAction<span style="color:#f92672">.</span>new(entity, offset<span style="color:#f92672">.</span>x, offset<span style="color:#f92672">.</span>y)<span style="color:#f92672">.</span>perform()
		
		path <span style="color:#f92672">=</span> get_point_path_to(target_grid_position)
		path<span style="color:#f92672">.</span>pop_front()
	
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> path<span style="color:#f92672">.</span>is_empty():
		<span style="color:#66d9ef">var</span> destination :<span style="color:#f92672">=</span> Vector2i(path<span style="color:#f92672">.</span>pop_front())
		<span style="color:#66d9ef">var</span> move_offset: Vector2i <span style="color:#f92672">=</span> destination <span style="color:#f92672">-</span> entity<span style="color:#f92672">.</span>grid_position
		<span style="color:#66d9ef">return</span> MovementAction<span style="color:#f92672">.</span>new(entity, move_offset<span style="color:#f92672">.</span>x, move_offset<span style="color:#f92672">.</span>y)<span style="color:#f92672">.</span>perform()
	
	<span style="color:#66d9ef">return</span> WaitAction<span style="color:#f92672">.</span>new(entity)<span style="color:#f92672">.</span>perform()
</code></pre></div><p>We first need to store a path. This is kind of the memory of the entity. If the player is in view it will update the <code>path</code> variable, but if it looses sight it will follow its current path to the position it last saw the player. Let&rsquo;s look at perform in detail:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">var</span> target: Entity <span style="color:#f92672">=</span> get_map_data()<span style="color:#f92672">.</span>player
<span style="color:#66d9ef">var</span> target_grid_position: Vector2i <span style="color:#f92672">=</span> target<span style="color:#f92672">.</span>grid_position
<span style="color:#66d9ef">var</span> offset: Vector2i <span style="color:#f92672">=</span> target_grid_position <span style="color:#f92672">-</span> entity<span style="color:#f92672">.</span>grid_position
<span style="color:#66d9ef">var</span> distance: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> max(abs(offset<span style="color:#f92672">.</span>x), abs(offset<span style="color:#f92672">.</span>y))
</code></pre></div><p>Our target will always be the player. We retrieve it and get its position. We then calculate the offset, i.e. the relative position from the entity to the player, and the distance between them (here as Chebyeshev distance, i.e., moving horizontally, vertically, or diagonally all takes one step).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">if</span> get_map_data()<span style="color:#f92672">.</span>get_tile(entity<span style="color:#f92672">.</span>grid_position)<span style="color:#f92672">.</span>is_in_view:
    <span style="color:#66d9ef">if</span> distance <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>:
        <span style="color:#66d9ef">return</span> MeleeAction<span style="color:#f92672">.</span>new(entity, offset<span style="color:#f92672">.</span>x, offset<span style="color:#f92672">.</span>y)<span style="color:#f92672">.</span>perform()
    
    path <span style="color:#f92672">=</span> get_point_path_to(target_grid_position)
    path<span style="color:#f92672">.</span>pop_front()
</code></pre></div><p>We then check if the entity is in view of the player. If the player can see the enemy, the enemy also can see the player, so in that case we want to act accordingly. If the distance is 1 or less, meaning the enemy is standing right next to the player, it will hit the player by creating a new <code>MeleeAction</code> and perform it. If we are further away than that, we request a new path from the pathfinder. We then need to remove the first element of that path, because that is the tile the enemy already stands on, and we only want the next tiles we need to go to.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> path<span style="color:#f92672">.</span>is_empty():
		<span style="color:#66d9ef">var</span> destination :<span style="color:#f92672">=</span> Vector2i(path<span style="color:#f92672">.</span>pop_front())
		<span style="color:#66d9ef">var</span> move_offset: Vector2i <span style="color:#f92672">=</span> destination <span style="color:#f92672">-</span> entity<span style="color:#f92672">.</span>grid_position
		<span style="color:#66d9ef">return</span> MovementAction<span style="color:#f92672">.</span>new(entity, move_offset<span style="color:#f92672">.</span>x, move_offset<span style="color:#f92672">.</span>y)<span style="color:#f92672">.</span>perform()
	
	<span style="color:#66d9ef">return</span> WaitAction<span style="color:#f92672">.</span>new(entity)<span style="color:#f92672">.</span>perform()
</code></pre></div><p>Then, regardless of whether or not the enemy sees the player, it will try moving along the path. If the path isn&rsquo;t empty, we get the next tile to move to from it. We calculate how we need to move, i.e., the <code>move_offset</code>, and then create and perform the corresponding <code>MovementAction</code>. Lastly, if we have not returned yet by either attacking or moving we create and perform a <code>WaitAction</code>. We haven&rsquo;t created that one yet, so let&rsquo;s do so now. Create a new script extending <code>Action</code> at <em>res://src/Entities/Actors/Actions/wait_action.gd</em>, and fill it with this very simple code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name WaitAction
<span style="color:#66d9ef">extends</span> Action

<span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">pass</span>
</code></pre></div><p>Unsurprisingly the <code>WaitAction</code> causes the entity to do nothing. Let&rsquo;s now turn our attention to the <code>Entity</code> so it can hold and manage those components. For that we start by expanding <em>entity_definition.gd</em> a bit:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#960050;background-color:#1e0010">@</span>export_category(<span style="color:#e6db74">&#34;Components&#34;</span>)
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> fighter_definition: FighterComponentDefinition
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> ai_type: Entity<span style="color:#f92672">.</span>AIType
</code></pre></div><p>We create a new category for components. The <code>fighter_definition</code> will be a <code>FighterComponentDefinition</code>. The neat thing I mentioned earlier is that this now can be a sub-resource. Whenever we create an entity definition we can fill this variable with a new resource we can edit right in that same inspector window. And if we don&rsquo;t want the entity to have such a component we leave that field empty. This makes this very flexible. We also have an <code>ai_type</code> variable. This variable refers to an enum we will create shortly. The reason we don&rsquo;t have a <code>AiComponentDefinition</code> is that we will only a small number of fixed AIs, so we just need a way to know which of these to instantiate. Now to <em>entity.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name Entity
<span style="color:#66d9ef">extends</span> Sprite2D

<span style="color:#66d9ef">enum</span> AIType {NONE, HOSTILE}
</code></pre></div><p>Create a new enum at the start. We will have two types of AI for now. Either None or the hostile AI. We also need references to the components:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">var</span> fighter_component: FighterComponent
<span style="color:#66d9ef">var</span> ai_component: BaseAIComponent
</code></pre></div><p>We then use <code>set_entity_type()</code> to extract the component information from the <code>entity_definition</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> set_entity_type(entity_definition: EntityDefinition) <span style="color:#f92672">-&gt;</span> void:
	_definition <span style="color:#f92672">=</span> entity_definition
	texture <span style="color:#f92672">=</span> entity_definition<span style="color:#f92672">.</span>texture
	modulate <span style="color:#f92672">=</span> entity_definition<span style="color:#f92672">.</span>color
	
	match entity_definition<span style="color:#f92672">.</span>ai_type:
		AIType<span style="color:#f92672">.</span>HOSTILE:
			ai_component <span style="color:#f92672">=</span> HostileEnemyAIComponent<span style="color:#f92672">.</span>new()
			add_child(ai_component)
	
	<span style="color:#66d9ef">if</span> entity_definition<span style="color:#f92672">.</span>fighter_definition:
		fighter_component <span style="color:#f92672">=</span> FighterComponent<span style="color:#f92672">.</span>new(entity_definition<span style="color:#f92672">.</span>fighter_definition)
		add_child(fighter_component)
</code></pre></div><p>The <code>match</code> block is new. We check which type of AI it should be. If it should be the hostile ai we create a new <code>HostileEnemyAIComponent</code> and add it as a child. We don&rsquo;t handle the <em>none</em> type, because in that case nothing will happen with the <code>ai_component</code> anyway. Then we check if the <code>entity_definition</code> has a <code>fighter_definition</code> sub-resource. If so, we take that info and create a new <code>FighterComponent</code> from it, and add that as a child. Last thing for now is one more function in this script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> is_alive() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">return</span> ai_component <span style="color:#f92672">!=</span> null
</code></pre></div><p>We have the aforementioned <code>is_alive()</code> function, which simply checks if we have anything in the <code>ai_component</code> variable or not. By removing the AI component when an entity dies we can both stop it from doing any more actions and we can mark it as a dead entity.</p>
<p>We now can have entities with components, but to actually do so we need to add these options to our existing entity definition resources. So go into <em>entity_definition_orc.tres</em> and you will see our new <em>Components</em> category. The easy thing first, set <em>Ai Type</em> to <em>Hostile</em>. Now click into the slot for the <em>Fighter Definition</em> and create a new <em>FighterComponentDefinition</em>. You can now click on the sub resource in that slot to expand and collapse it. Set the <em>Max Hp</em> to 10, the <em>Power</em> to 3, and the <em>Defense</em> to 0. Next, open <em>entity_definition_troll.tres</em>, and set the <em>Ai Type</em> to <em>Hostile</em> as well. Create another sub resource in <em>Fighter Definition</em> and fill it with a <em>Max Hp</em> of 16, <em>Power</em> of 4, and <em>Defense</em> of 1.</p>
<p>Lastly, we do the same with the <em>entity_definition_player.tres</em>. Create a <em>Fighter Definition</em> and set the <em>Max Hp</em> to 30, the <em>Power</em> to 5, and the <em>Defense</em> to 2. You might expect that we leave <em>Ai Type</em> as <em>None</em>, because the player is not controlled by an ai. But remember our <code>is_alive()</code> function. If the player had no <code>ai_component</code>, the game would treat it as dead. However, we will handle the player separately anyway, so we set <em>Ai Type</em> to <em>Hostile</em>. This will give the player a <code>HostileEnemyAiComponent</code>, but that AI simply won&rsquo;t do anything. Let me show you what I mean. In <em>game.gd</em> we change the <code>_handle_enemy_turns()</code> function as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _handle_enemy_turns() <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">for</span> entity <span style="color:#f92672">in</span> get_map_data()<span style="color:#f92672">.</span>get_actors():
		<span style="color:#66d9ef">if</span> entity<span style="color:#f92672">.</span>is_alive() <span style="color:#f92672">and</span> entity <span style="color:#f92672">!=</span> player:
			entity<span style="color:#f92672">.</span>ai_component<span style="color:#f92672">.</span>perform()
</code></pre></div><p>We loop through all actors, and we check for two conditions. First, the entity has to be alive, i.e., have an <code>ai_component</code>, and second the entity mustn&rsquo;t be the player. That way we know we have an alive enemy, and we call it&rsquo;s <code>ai_component.perform()</code> function to have it choose and perform an action. We don&rsquo;t have the function to get the array of actors yet. While I did explain that I do not want to make that distinction here in terms of class hierarchy, we can create something similar by just returning an array of all alive entities. If then seems redundant to check <code>is_alive()</code> here, and in our current game it is. But imagine if we extended the game in a way that would allow an enemy further back in the list to die during the earlier enemy turns. It would still be in that array, but when we get to it it won&rsquo;t be alive anymore. So just to make sure, we check again here. So let&rsquo;s now create that <code>get_actors()</code> function in <em>map_data.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_actors() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Array</span>[Entity]:
	<span style="color:#66d9ef">var</span> actors: <span style="color:#a6e22e">Array</span>[Entity] <span style="color:#f92672">=</span> []
	<span style="color:#66d9ef">for</span> entity <span style="color:#f92672">in</span> entities:
		<span style="color:#66d9ef">if</span> entity<span style="color:#f92672">.</span>is_alive():
			actors<span style="color:#f92672">.</span>append(entity)
	<span style="color:#66d9ef">return</span> actors


<span style="color:#66d9ef">func</span> get_actor_at_location(location: Vector2i) <span style="color:#f92672">-&gt;</span> Entity:
	<span style="color:#66d9ef">for</span> actor <span style="color:#f92672">in</span> get_actors():
		<span style="color:#66d9ef">if</span> actor<span style="color:#f92672">.</span>grid_position <span style="color:#f92672">==</span> location:
			<span style="color:#66d9ef">return</span> actor
	<span style="color:#66d9ef">return</span> null
</code></pre></div><p>In <code>get_actors()</code> we just create an array and filter for all the alive entities. We also create a function to <code>get_actor_at_location()</code> which works very similarly to <code>get_blocking entity_at_location()</code>, just for actors.</p>
<p>Now, the way we set up our AI pathfinding allows enemies to move diagonally. The player can&rsquo;t at the moment, as there&rsquo;s no input that creates a diagonal <code>BumpAction</code>. So let us now expand our input system a bit. We&rsquo;ll have three ways to move the player. The first is the arrow keys, a before, but we&rsquo;ll extend those by some special keys we use for diagonals. Not the most intuitive, so we&rsquo;ll also use my favorite method, the numpad. Not everyone has a numpad on their keyboard though, so we&rsquo;ll also implement the classic vim-style direction keys on the right side of the home row.</p>
<p>To do all this, go to <em>Project</em> &gt; <em>Settings</em> in the menu bar, and there select the tab reading <em>Input Map</em>. Type <em>move_up</em> in the field reading <em>Add New Action</em> then click the <em>Add</em> button to the right of this. You should now see the <em>move_up</em> action in the list, and a plus sign all the way to the right. Click that, and assign the keys you want for moving up. You can add multiple keys after one another. Keep it at physical keycode, that way the layout will stay the same, even for people using another keyboard layout. Here&rsquo;s the actions and corresponding keys we&rsquo;ll use (use the ones that make sens in your keyboard layout):</p>
<table>
<thead>
<tr>
<th>Action</th>
<th>Arrow Keys</th>
<th>Numpad</th>
<th>Vim keys</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>move_up</em></td>
<td>Up arrow key</td>
<td>NumPad 8</td>
<td>K</td>
</tr>
<tr>
<td><em>move_down</em></td>
<td>Down arrow key</td>
<td>NumPad 2</td>
<td>J</td>
</tr>
<tr>
<td><em>move_left</em></td>
<td>Left arrow key</td>
<td>NumPad 4</td>
<td>H</td>
</tr>
<tr>
<td><em>move_right</em></td>
<td>Right arrow key</td>
<td>NumPad 6</td>
<td>L</td>
</tr>
<tr>
<td><em>move_up_left</em></td>
<td>Home</td>
<td>NumPad 7</td>
<td>Y</td>
</tr>
<tr>
<td><em>move_up_right</em></td>
<td>End</td>
<td>NumPad 9</td>
<td>U</td>
</tr>
<tr>
<td><em>move_down_left</em></td>
<td>Page Up</td>
<td>NumPad 1</td>
<td>B</td>
</tr>
<tr>
<td>_move_down_right</td>
<td>Page Down</td>
<td>NumPad 3</td>
<td>N</td>
</tr>
<tr>
<td><em>wait</em></td>
<td>Delete</td>
<td>NumPad 5</td>
<td>Period</td>
</tr>
<tr>
<td><em>quit</em></td>
<td>ESC</td>
<td>(also uses ESC)</td>
<td>(also uses ESC)</td>
</tr>
</tbody>
</table>
<p>With our actions defined, let&rsquo;s rewrite <em>input_handler.gd</em>. Replace the code with the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name InputHandler

<span style="color:#66d9ef">const</span> directions <span style="color:#f92672">=</span> {
	<span style="color:#e6db74">&#34;move_up&#34;</span>: Vector2i<span style="color:#f92672">.</span>UP,
	<span style="color:#e6db74">&#34;move_down&#34;</span>: Vector2i<span style="color:#f92672">.</span>DOWN,
	<span style="color:#e6db74">&#34;move_left&#34;</span>: Vector2i<span style="color:#f92672">.</span>LEFT,
	<span style="color:#e6db74">&#34;move_right&#34;</span>: Vector2i<span style="color:#f92672">.</span>RIGHT,
	<span style="color:#e6db74">&#34;move_up_left&#34;</span>: Vector2i<span style="color:#f92672">.</span>UP <span style="color:#f92672">+</span> Vector2i<span style="color:#f92672">.</span>LEFT,
	<span style="color:#e6db74">&#34;move_up_right&#34;</span>: Vector2i<span style="color:#f92672">.</span>UP <span style="color:#f92672">+</span> Vector2i<span style="color:#f92672">.</span>RIGHT,
	<span style="color:#e6db74">&#34;move_down_left&#34;</span>: Vector2i<span style="color:#f92672">.</span>DOWN <span style="color:#f92672">+</span> Vector2i<span style="color:#f92672">.</span>LEFT,
	<span style="color:#e6db74">&#34;move_down_right&#34;</span>: Vector2i<span style="color:#f92672">.</span>DOWN <span style="color:#f92672">+</span> Vector2i<span style="color:#f92672">.</span>RIGHT,
}


<span style="color:#66d9ef">func</span> get_action(player: Entity) <span style="color:#f92672">-&gt;</span> Action:
	<span style="color:#66d9ef">var</span> action: Action <span style="color:#f92672">=</span> null
	
	<span style="color:#66d9ef">for</span> direction <span style="color:#f92672">in</span> directions:
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(direction):
			<span style="color:#66d9ef">var</span> offset: Vector2i <span style="color:#f92672">=</span> directions[direction]
			action <span style="color:#f92672">=</span> BumpAction<span style="color:#f92672">.</span>new(player, offset<span style="color:#f92672">.</span>x, offset<span style="color:#f92672">.</span>y)
	
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;wait&#34;</span>):
		action <span style="color:#f92672">=</span> WaitAction<span style="color:#f92672">.</span>new(player)
	
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;quit&#34;</span>):
		action <span style="color:#f92672">=</span> EscapeAction<span style="color:#f92672">.</span>new(player)
	
	<span style="color:#66d9ef">return</span> action
</code></pre></div><p>Here we create an array that associates the names of the action strings with the desired move direction. That way we don&rsquo;t need four more if checks, we can simply loop through the keys of our dictionary of directions, and if that action is pressed, we create a <code>BumpAction</code> with the corresponding offset. We also added a <code>WaitAction</code> for the player, and changed the code for the <code>EscapeAction</code> to use our new actions.</p>
<p>Now that both the player and the enemies can move around freely, let&rsquo;s have them do some actual damage. First, we only want to hit living things (in this tutorial anyway), so to make that easier we add the following function to <em>action_with_direction.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_target_actor() <span style="color:#f92672">-&gt;</span> Entity:
	<span style="color:#66d9ef">return</span> get_map_data()<span style="color:#f92672">.</span>get_actor_at_location(get_destination())
</code></pre></div><p>Let&rsquo;s use that function right away in <em>bump_action.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">if</span> get_target_actor():
		MeleeAction<span style="color:#f92672">.</span>new(entity, offset<span style="color:#f92672">.</span>x, offset<span style="color:#f92672">.</span>y)<span style="color:#f92672">.</span>perform()
	<span style="color:#66d9ef">else</span>:
		MovementAction<span style="color:#f92672">.</span>new(entity, offset<span style="color:#f92672">.</span>x, offset<span style="color:#f92672">.</span>y)<span style="color:#f92672">.</span>perform()
</code></pre></div><p>Next we rewrite the <code>MeleeAction</code>. So far that action has only printed a little statement. We will still print a statement so we know what happened, but now we will also do damage. Change the <code>perform()</code> function in <em>melee_action.gd</em> as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> target: Entity <span style="color:#f92672">=</span> get_target_actor()
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> target:
		<span style="color:#66d9ef">return</span>
	
	<span style="color:#66d9ef">var</span> damage: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> entity<span style="color:#f92672">.</span>fighter_component<span style="color:#f92672">.</span>power <span style="color:#f92672">-</span> target<span style="color:#f92672">.</span>fighter_component<span style="color:#f92672">.</span>defense
	
	<span style="color:#66d9ef">var</span> attack_description: <span style="color:#a6e22e">String</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> attacks </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> [entity<span style="color:#f92672">.</span>get_entity_name(), target<span style="color:#f92672">.</span>get_entity_name()]
	<span style="color:#66d9ef">if</span> damage <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
		attack_description <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34; for </span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> hit points.&#34;</span> <span style="color:#f92672">%</span> damage
		target<span style="color:#f92672">.</span>fighter_component<span style="color:#f92672">.</span>hp <span style="color:#f92672">-=</span> damage
	<span style="color:#66d9ef">else</span>:
		attack_description <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34; but does no damage.&#34;</span>
	print(attack_description)
</code></pre></div><p>The top of the function is the same as before, with the exception that we now use the <code>get_target_actor()</code> function instead of <code>get_blocking_entity()</code>. Then we calculate the damage. A more exciting game would have damage ranges, maybe some simulated dice throws, but here we will just take the attacker&rsquo;s power and subtract the defender&rsquo;s defense from it, and that&rsquo;s our damage. Next, we cobble together an attack description. The description starts with who is hitting who. Then it either tells us how much damage it did, or that it did not do any damage. In case we do damage, we also subtract that damage from the target&rsquo;s health points.</p>
<p>Now that entities can take damage, they should also have a way to die. Here we come to a bit of an issue. Where I previously though it would be a nice trick to have values like <code>is_blocking_movement</code> just refer to the entity type definition, we now will want to change that value for individual entities when they die. Therefore we need to go back and modify <em>entity.gd</em> a bit:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">var</span> _definition: EntityDefinition
<span style="color:#66d9ef">var</span> entity_name: <span style="color:#a6e22e">String</span>
<span style="color:#66d9ef">var</span> blocks_movement: <span style="color:#a6e22e">bool</span>
<span style="color:#66d9ef">var</span> map_data: MapData
</code></pre></div><p>We now have a variable for the name and for blocking movement. I would have preferred if I could have followed the convention to name it <code>is_blocking_movement</code>, but that would have collided with the function of that name. We initialize these values in <code>set_entity_type()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> set_entity_type(entity_definition: EntityDefinition) <span style="color:#f92672">-&gt;</span> void:
	_definition <span style="color:#f92672">=</span> entity_definition
	blocks_movement <span style="color:#f92672">=</span> _definition<span style="color:#f92672">.</span>is_blocking_movement
	entity_name <span style="color:#f92672">=</span> _definition<span style="color:#f92672">.</span>name
	texture <span style="color:#f92672">=</span> entity_definition<span style="color:#f92672">.</span>texture
	modulate <span style="color:#f92672">=</span> entity_definition<span style="color:#f92672">.</span>color
	
	match entity_definition<span style="color:#f92672">.</span>ai_type:
		AIType<span style="color:#f92672">.</span>HOSTILE:
			ai_component <span style="color:#f92672">=</span> HostileEnemyAIComponent<span style="color:#f92672">.</span>new()
			add_child(ai_component)
	
	<span style="color:#66d9ef">if</span> entity_definition<span style="color:#f92672">.</span>fighter_definition:
		fighter_component <span style="color:#f92672">=</span> FighterComponent<span style="color:#f92672">.</span>new(entity_definition<span style="color:#f92672">.</span>fighter_definition)
		add_child(fighter_component)
</code></pre></div><p>All our code so far has referred to the functions we wrote to retrieve these values from the definition, so in order to keep all that other code without the need for any further changes we modify these function to now give us the values directly:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> is_blocking_movement() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">return</span> blocks_movement


<span style="color:#66d9ef">func</span> get_entity_name() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">String</span>:
	<span style="color:#66d9ef">return</span> entity_name
</code></pre></div><p>That&rsquo;s it for the entity refactor. Next, we need a visual representation for a corpse. For that create a new resource of type <code>AtlasTexture</code> at <em>res://assets/resources/default_death_texture.tres</em>. Fill it with our sprite sheet as the atlas and select an appropriate icon, such as the bone. We will now use this to add the following to <em>fighter_component_definition.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#960050;background-color:#1e0010">@</span>export_category(<span style="color:#e6db74">&#34;Visuals&#34;</span>)
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> death_texture: <span style="color:#a6e22e">AtlasTexture</span> <span style="color:#f92672">=</span> preload(<span style="color:#e6db74">&#34;res://assets/resources/default_death_texture.tres&#34;</span>)
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> death_color: <span style="color:#a6e22e">Color</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>DARK_RED
</code></pre></div><p>This will allow us to customize what the remains of monsters will look like, while also having a good default. With that, everything is in place to let our entities die. Let&rsquo;s write a function for that in <em>fighter_component.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> die() <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> death_message: <span style="color:#a6e22e">String</span>
	
	<span style="color:#66d9ef">if</span> get_map_data()<span style="color:#f92672">.</span>player <span style="color:#f92672">==</span> entity:
		death_message <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;You died!&#34;</span>
	<span style="color:#66d9ef">else</span>:
		death_message <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> is dead!&#34;</span> <span style="color:#f92672">%</span> entity<span style="color:#f92672">.</span>get_entity_name()
	
	print(death_message)
	entity<span style="color:#f92672">.</span>texture <span style="color:#f92672">=</span> death_texture
	entity<span style="color:#f92672">.</span>modulate <span style="color:#f92672">=</span> death_color
	entity<span style="color:#f92672">.</span>ai_component<span style="color:#f92672">.</span>queue_free()
	entity<span style="color:#f92672">.</span>ai_component <span style="color:#f92672">=</span> null
	entity<span style="color:#f92672">.</span>entity_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Remains of </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> entity<span style="color:#f92672">.</span>entity_name
	entity<span style="color:#f92672">.</span>blocks_movement <span style="color:#f92672">=</span> false
	get_map_data()<span style="color:#f92672">.</span>unregister_blocking_entity(entity)
</code></pre></div><p>Here we start piecing a death message together again. This is all leading up to the next part, where we will create a message log. For now we print to the console. We differentiate here whether the player or an enemy died, and create an appropriate message. After printing that message comes the housekeeping. We set the entity texture to the death texture, and it&rsquo;s modulate to the death color. Both these we&rsquo;ll have to add to the fighter component in a moment. We delete the AI component and remove the reference to it. We change the name of the entity to reflect that it&rsquo;s dead. And lastly, we set it to not block movement, which also implies unregistering it from the pathfinder. Now, modify the top of the script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">var</span> max_hp: <span style="color:#a6e22e">int</span>
<span style="color:#66d9ef">var</span> hp: <span style="color:#a6e22e">int</span>:
	set(value):
		hp <span style="color:#f92672">=</span> clampi(value, <span style="color:#ae81ff">0</span>, max_hp)
		<span style="color:#66d9ef">if</span> hp <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>:
			die()
<span style="color:#66d9ef">var</span> defense: <span style="color:#a6e22e">int</span>
<span style="color:#66d9ef">var</span> power: <span style="color:#a6e22e">int</span>

<span style="color:#66d9ef">var</span> death_texture: <span style="color:#a6e22e">Texture</span>
<span style="color:#66d9ef">var</span> death_color: <span style="color:#a6e22e">Color</span>


<span style="color:#66d9ef">func</span> _init(definition: FighterComponentDefinition) <span style="color:#f92672">-&gt;</span> void:
	max_hp <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>max_hp
	hp <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>max_hp
	defense <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>defense
	power <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>power
	death_texture <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>death_texture
	death_color <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>death_color
</code></pre></div><p>Firstly, we add a line to the hp setter that calls <code>die()</code> when the hp are changed to 0. Secondly, we add the aforementioned death texture and color. And thirdly, we set those in the <code>_init()</code> function.</p>
<p>And just like that, things can die. If you run the project now, however, you would notice two problems. The first is that alive entities might be drawn behind alive entities, which we don&rsquo;t want. The second is that when the player dies, nothing much changes apart from their appearance and name. <em>&ldquo;Remains of Player&rdquo;</em> can still happily run around through the dungeon and hit the other entities. Let&rsquo;s start with the first problem, as that&rsquo;s a bit easier to solve.</p>
<p>To do that, we will a bit of code to <em>entity.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">enum</span> EntityType {CORPSE, ITEM, ACTOR}

<span style="color:#66d9ef">var</span> type: EntityType:
	set(value):
		type <span style="color:#f92672">=</span> value
		z_index <span style="color:#f92672">=</span> type
</code></pre></div><p>We add both an enum <code>EntityType</code> and a variable type. In the setter we set the <code>z_index</code> to the type. As the enum is actually an integer value, entity types further to the end of the list will be drawn above those at the beginning of the list. So if an entity is set to the type <code>ACTOR</code> it will be drawn above one that is set to <code>CORPSE</code>. To make use of this edit <code>set_entity_type()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> set_entity_type(entity_definition: EntityDefinition) <span style="color:#f92672">-&gt;</span> void:
	_definition <span style="color:#f92672">=</span> entity_definition
	type <span style="color:#f92672">=</span> _definition<span style="color:#f92672">.</span>type
	<span style="color:#f92672">...</span>
</code></pre></div><p>You see we need to get that from the definition. We add a line for that to <em>entity_definition.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#960050;background-color:#1e0010">@</span>export_category(<span style="color:#e6db74">&#34;Mechanics&#34;</span>)
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> is_blocking_movement: <span style="color:#a6e22e">bool</span> <span style="color:#f92672">=</span> true
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> type: Entity<span style="color:#f92672">.</span>EntityType <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>EntityType<span style="color:#f92672">.</span>ACTOR
</code></pre></div><p>The default value is <code>ACTOR</code> here, as all the entities we have so far that use an entity definition are actors, meaning we don&rsquo;t have to update them manually. Lastly, at the end of the <code>die()</code> function in <em>fighter_component.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">	print(death_message)
	entity<span style="color:#f92672">.</span>texture <span style="color:#f92672">=</span> death_texture
	entity<span style="color:#f92672">.</span>modulate <span style="color:#f92672">=</span> death_color
	entity<span style="color:#f92672">.</span>ai_component<span style="color:#f92672">.</span>queue_free()
	entity<span style="color:#f92672">.</span>ai_component <span style="color:#f92672">=</span> null
	entity<span style="color:#f92672">.</span>entity_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Remains of </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> entity<span style="color:#f92672">.</span>entity_name
	entity<span style="color:#f92672">.</span>blocks_movement <span style="color:#f92672">=</span> false
	get_map_data()<span style="color:#f92672">.</span>unregister_blocking_entity(entity)
	entity<span style="color:#f92672">.</span>type <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>EntityType<span style="color:#f92672">.</span>CORPSE
</code></pre></div><p>We simply add one line at the end, to set the entity type to <code>CORPSE</code>. Now the player or living enemies should never be drawn behind a dead enemy.</p>
<p>Now for the last problem, taking control away from the player when their character dies. To do that we will expand our system for input handling a bit. We will create a state machine that defers the call to an action to the currently active child. Create a new script extending <code>Node</code> at <em>res://src/res://src/Game/EventHandlers/base_input_handler.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name BaseInputHandler
<span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Node</span>


<span style="color:#66d9ef">func</span> get_action(player: Entity) <span style="color:#f92672">-&gt;</span> Action:
	<span style="color:#66d9ef">return</span> null
</code></pre></div><p>It only has a <code>get_action()</code> method. Now rename the file <em>input_handler.gd</em> to <em>main_game_input_handler.gd</em>, and change the first line to <code>extends BaseInputHandler </code>. Now in the main game scene remove the script from the <strong>InputHandler</strong> node. Create a new script at <em>res://src/Game/EventHandlers/input_handler.gd</em>. This process might seem to be a bit confusing, but what we do here is to change how input handling works while preserving how it&rsquo;s called. The <strong>Game</strong> node will now call the new input handler and just request an action from the new input handler, which will in turn request it from the <strong>MainGameInputHandler</strong>, which has all the old code. But let&rsquo;s first write the new top-level <em>input_handler.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name InputHandler
<span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Node</span>

<span style="color:#66d9ef">enum</span> InputHandlers {MAIN_GAME, GAME_OVER}

<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> start_input_handler: InputHandlers

<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> input_handler_nodes :<span style="color:#f92672">=</span> {
	InputHandlers<span style="color:#f92672">.</span>MAIN_GAME: <span style="color:#f92672">$</span>MainGameInputHandler,
	InputHandlers<span style="color:#f92672">.</span>GAME_OVER: <span style="color:#f92672">$</span>GameOverInputHandler,
}

<span style="color:#66d9ef">var</span> current_input_handler: BaseInputHandler


<span style="color:#66d9ef">func</span> _ready() <span style="color:#f92672">-&gt;</span> void:
	transition_to(start_input_handler)


<span style="color:#66d9ef">func</span> get_action(player: Entity) <span style="color:#f92672">-&gt;</span> Action:
	<span style="color:#66d9ef">return</span> current_input_handler<span style="color:#f92672">.</span>get_action(player)


<span style="color:#66d9ef">func</span> transition_to(input_handler: InputHandlers) <span style="color:#f92672">-&gt;</span> void:
	current_input_handler <span style="color:#f92672">=</span> input_handler_nodes[input_handler]

</code></pre></div><p>Here we first define a range of enums that represent the different input handlers we will have. We also have an exported variable that lets us select with which one we should start. We create an <code>@onready</code> dictionary associating the enum values with the available child nodes, which we&rsquo;ll create in a minute. The variable <code>current_input_handler</code> remembers which child input handler we&rsquo;re currently using.</p>
<p>In the <code>_ready()</code> function we call <code>transition_to()</code> with the starting handler. Transition to simply retrieves the appropriate node and stores it in <code>current_input_handler</code>. This then allows us to define <code>get_action()</code> as simply in turn calling <code>get_action()</code> on the current input handler.</p>
<p>To make this actually work, let&rsquo;s add two new <code>Node</code>s as children of <strong>InputHandler</strong>. Call the first one <strong>MainGameInputHendler</strong> and the second one <strong>GameOverInputHandler</strong>. Now attach <em>main_game_input_handler.gd</em> to <strong>MainGameInputHanlder</strong>. Let&rsquo;s also create a new script on <strong>GameOverInputHandler</strong>, have it extend <code>BaseInputHandler</code> and save it at <em>res://src/Game/EventHandlers/game_over_input_handler.gd</em>. Here&rsquo;s its contents:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">extends</span> BaseInputHandler

<span style="color:#66d9ef">func</span> get_action(player: Entity) <span style="color:#f92672">-&gt;</span> Action:
	<span style="color:#66d9ef">var</span> action: Action
	
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;quit&#34;</span>):
		action <span style="color:#f92672">=</span> EscapeAction<span style="color:#f92672">.</span>new(player)
	
	<span style="color:#66d9ef">return</span> action
</code></pre></div><p>Once the player is dead, the only thing we allow it for now is quitting the game. Now that that&rsquo;s in place we need a way to trigger the transition from one input handler to the other. For that we&rsquo;ll introduce a signal bus. That way, if the player dies we can emit a signal that automatically triggers that change. Create a new script extending <code>Node</code> at <em>res://src/Utils/signal_bus.gd</em>. For now it only defines a single signal:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Node</span>

<span style="color:#66d9ef">signal</span> player_died
</code></pre></div><p>Now we need to make the signal bus an Autoload. Go to <em>Project</em> &gt; <em>Settings</em> again, this time into the <em>Autoload</em> tab. Click on the folder icon next to <em>Path</em> and navigate to <em>signal_bus.gd</em>. Set the <em>Node_Name</em> to <em>SignalBus</em> and click add. Now you should see the signal bus entered into the list below.</p>
<p>We will emit this new signal in <em>fighter_component.gd</em>, in the <code>die()</code> function, when we determine that it was the player that died:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">if</span> get_map_data()<span style="color:#f92672">.</span>player <span style="color:#f92672">==</span> entity:
	death_message <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;You died!&#34;</span>
	SignalBus<span style="color:#f92672">.</span>player_died<span style="color:#f92672">.</span>emit()
<span style="color:#66d9ef">else</span>:
	death_message <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> is dead!&#34;</span> <span style="color:#f92672">%</span> entity<span style="color:#f92672">.</span>get_entity_name()
</code></pre></div><p>To catch that signal we add one line to the <code>_ready()</code> function of <em>input_handler.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _ready() <span style="color:#f92672">-&gt;</span> void:
	transition_to(start_input_handler)
	SignalBus<span style="color:#f92672">.</span>player_died<span style="color:#f92672">.</span>connect(transition_to<span style="color:#f92672">.</span>bind(InputHandlers<span style="color:#f92672">.</span>GAME_OVER))
</code></pre></div><p>This connects the <code>player_died</code> signal in the <code>SignalBus</code> directly to <code>transition_to</code>, and will bind the value <code>InputHandlers.GAME_OVER</code>, meaning that value will be used as an argument. That way, when the player dies and that signal is emitted, we automatically transition to the game over input handler, which will prevent the player from doing anything further than quit the game.</p>
<p>And with that, I declare this part of the tutorial complete. The original tutorial also adds a little display for the player&rsquo;s hp, but in our setup that&rsquo;s slightly more involved, so I&rsquo;ll save this for the next part, when we will tackle the interface anyway.</p>
<p>This part has been very long with a lot of changes, and I hope you could follow. If there is anything that&rsquo;s not working for you with this code, remember that you can find the working code on this tutorial&rsquo;s GitHub repository: <a href="https://github.com/SelinaDev/Godot-Roguelike-Tutorial">https://github.com/SelinaDev/Godot-Roguelike-Tutorial</a>. Once everything is working, you can move on to the next part: <a href="https://selinadev.github.io/11-rogueliketutorial-07/">https://selinadev.github.io/11-rogueliketutorial-07/</a></p>




      </main>
  </div>
  </body>
</html>
