<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="generator" content="Hugo 0.92.2" />
  <link rel="canonical" href="https://selinadev.github.io/12-rogueliketutorial-08/">

  
    
    <meta name="description" content="Part 8: Items and Inventory Welcome back to the roguelike tutorial series. This tutorial will continue from where the last one left off. You can find the previous tutorial here: https://selinadev.github.io/11-rogueliketutorial-07/
This part will tackle items, as well as inventory. As you might expect this will involve some (basic) inventory UI. As such we will get a lot of use out of Godotâ€™s UI system. We will depart from the way the original python tutorial does things, as we did in the last part, and I will show you some more Godot tricks you may or may not be familiar with.">
  

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#000000">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" type="text/css" href="/css/paper.css">

  
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css">
  
  
    
  

  
  
  <title>Yet Another Roguelike Tutorial, Part 8 | SelinaDev</title>
</head>

  <body>
    <div class="container paper">
      <nav class="border split-nav">
  <div class="nav-brand">
    <h3><a href="/">SelinaDev</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
    <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
      
        <li><a href="/">Blog</a></li>
      
        <li><a href="/tags/">Tags</a></li>
      
        <li><a href="/about/">About</a></li>
      
      </ul>
    </div>
  </div>
</nav>
      <main>
        

<h1 class="post-title">Yet Another Roguelike Tutorial, Part 8</h1>


<strong>Publish date: </strong>Aug 10, 2023
<br>

  <strong>Tags: </strong>
  
    <a href="/tags/godot4">godot4</a>
  
    <a href="/tags/tutorial">tutorial</a>
  
    <a href="/tags/roguelike">roguelike</a>
  



  



<h1 id="part-8-items-and-inventory">Part 8: Items and Inventory</h1>
<p>Welcome back to the roguelike tutorial series. This tutorial will continue from where the last one left off. You can find the previous tutorial here: <a href="https://selinadev.github.io/11-rogueliketutorial-07/">https://selinadev.github.io/11-rogueliketutorial-07/</a></p>
<p>This part will tackle items, as well as inventory. As you might expect this will involve some (basic) inventory UI. As such we will get a lot of use out of Godot&rsquo;s UI system. We will depart from the way the original python tutorial does things, as we did in the last part, and I will show you some more Godot tricks you may or may not be familiar with. I do have to admit, however, that what I present is at some points not the cleanest solution, but in fact quite hacky. Still, it gets you a working game, and maybe you can take it as an example of how to take a shortcut. Anyway, let&rsquo;s get into the tutorial.</p>
<p>The first thing we need to do is define some more colors our message log. So in <em>colors.gd</em> add the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">const</span> INVALID <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span>(<span style="color:#e6db74">&#34;ffff00&#34;</span>)
<span style="color:#66d9ef">const</span> IMPOSSIBLE <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span>(<span style="color:#e6db74">&#34;808080&#34;</span>)
<span style="color:#66d9ef">const</span> ERROR <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span>(<span style="color:#e6db74">&#34;ff4040&#34;</span>)

<span style="color:#66d9ef">const</span> WELCOME_TEXT <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span>(<span style="color:#e6db74">&#34;20a0ff&#34;</span>)
<span style="color:#66d9ef">const</span> HEALTH_RECOVERED <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span>(<span style="color:#e6db74">&#34;00ff00&#34;</span>)
</code></pre></div><p>This shows us two things. First, we have some colors for impossible actions, meaning we will create a system to check if an action is possible at all, and if not we tell the player, and do not consume their turn. We will start with that right away and integrate that with all the actions we have had so far. You also see a color for the recovery of health. The item we will create and handle throughout this part will be a health potion, allowing the player to recover hp they have lost in a fight.</p>
<p>First, we prepare the fighter to heal. We will later need information how much hp were recovered, so we will expand <em>fighter_component.gd</em> by the following two functions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> heal(amount: <span style="color:#a6e22e">int</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">int</span>:
	<span style="color:#66d9ef">if</span> hp <span style="color:#f92672">==</span> max_hp:
		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
	
	<span style="color:#66d9ef">var</span> new_hp_value: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> hp <span style="color:#f92672">+</span> amount
	
	<span style="color:#66d9ef">if</span> new_hp_value <span style="color:#f92672">&gt;</span> max_hp:
		new_hp_value <span style="color:#f92672">=</span> max_hp
		
	<span style="color:#66d9ef">var</span> amount_recovered: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> new_hp_value <span style="color:#f92672">-</span> hp
	hp <span style="color:#f92672">=</span> new_hp_value
	<span style="color:#66d9ef">return</span> amount_recovered


<span style="color:#66d9ef">func</span> take_damage(amount: <span style="color:#a6e22e">int</span>) <span style="color:#f92672">-&gt;</span> void:
	hp <span style="color:#f92672">-=</span> amount
</code></pre></div><p>The <code>take_damage()</code> function is pretty self explanatory, it just makes how the fighter component works more explicit. The <code>heal()</code> function first calculates how many hp are recovered, then sets the hp to the new values, after which it returns the calculated value.</p>
<p>Now we tackle the system of reporting impossible actions and preventing them from taking a turn. If you would start the game now and find an enemy, then run against the a wall, the enemy would receive a turn each time. We want to change our system so impossible actions are ignored by the turn order. Running against a wall is a free action, so to speak. This will be another point where we diverge from the original tutorial. That tutorial uses exceptions to handle such actions, which Godot does not have. So we need to improvise. The solution actually isn&rsquo;t even that complicated, it just needs a (slightly tedious) refactor. First, in <em>game.gd</em> we change the <code>_physics_process()</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _physics_process(_delta: <span style="color:#a6e22e">float</span>) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> action: Action <span style="color:#f92672">=</span> await input_handler<span style="color:#f92672">.</span>get_action(player)
	<span style="color:#66d9ef">if</span> action:
		<span style="color:#66d9ef">var</span> previous_player_position: Vector2i <span style="color:#f92672">=</span> player<span style="color:#f92672">.</span>grid_position
		<span style="color:#66d9ef">if</span> action<span style="color:#f92672">.</span>perform():
			<span style="color:#66d9ef">if</span> player<span style="color:#f92672">.</span>grid_position <span style="color:#f92672">!=</span> previous_player_position:
				map<span style="color:#f92672">.</span>update_fov(player<span style="color:#f92672">.</span>grid_position)
			_handle_enemy_turns()
</code></pre></div><p>What we will do in a moment is give the actions' <code>perform()</code> function a boolean return value. We check that, and then only update the fov or handle enemy turns if it&rsquo;s true. That means that we need to change <em>action.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">return</span> false
</code></pre></div><p>As mentioned, the perform function now reports a bool value back, which will tell us if the action should consume a turn. If it didn&rsquo;t happen (or if we decide to include some actions that don&rsquo;t consume a turn by default), we return false, but if it should cost a turn we return true. Unfortunately this means we need to update all the actions we already have, which are a few at this point. Let&rsquo;s start with <em>melee_action.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">var</span> target: Entity <span style="color:#f92672">=</span> get_target_actor()
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> target:
		<span style="color:#66d9ef">if</span> entity <span style="color:#f92672">==</span> get_map_data()<span style="color:#f92672">.</span>player:
			MessageLog<span style="color:#f92672">.</span>send_message(<span style="color:#e6db74">&#34;Nothing to attack.&#34;</span>, GameColors<span style="color:#f92672">.</span>IMPOSSIBLE)
		<span style="color:#66d9ef">return</span> false
	
	<span style="color:#66d9ef">var</span> damage: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> entity<span style="color:#f92672">.</span>fighter_component<span style="color:#f92672">.</span>power <span style="color:#f92672">-</span> target<span style="color:#f92672">.</span>fighter_component<span style="color:#f92672">.</span>defense
	<span style="color:#66d9ef">var</span> attack_color: <span style="color:#a6e22e">Color</span>
	<span style="color:#66d9ef">if</span> entity <span style="color:#f92672">==</span> get_map_data()<span style="color:#f92672">.</span>player:
		attack_color <span style="color:#f92672">=</span> GameColors<span style="color:#f92672">.</span>PLAYER_ATTACK
	<span style="color:#66d9ef">else</span>:
		attack_color <span style="color:#f92672">=</span> GameColors<span style="color:#f92672">.</span>ENEMY_ATTACK
	<span style="color:#66d9ef">var</span> attack_description: <span style="color:#a6e22e">String</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> attacks </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> [entity<span style="color:#f92672">.</span>get_entity_name(), target<span style="color:#f92672">.</span>get_entity_name()]
	<span style="color:#66d9ef">if</span> damage <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
		attack_description <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34; for </span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> hit points.&#34;</span> <span style="color:#f92672">%</span> damage
		MessageLog<span style="color:#f92672">.</span>send_message(attack_description, attack_color)
		target<span style="color:#f92672">.</span>fighter_component<span style="color:#f92672">.</span>hp <span style="color:#f92672">-=</span> damage
	<span style="color:#66d9ef">else</span>:
		attack_description <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34; but does no damage.&#34;</span>
		MessageLog<span style="color:#f92672">.</span>send_message(attack_description, attack_color)
	<span style="color:#66d9ef">return</span> true
</code></pre></div><p>Here we added some code right at the top. If we don&rsquo;t have a target, we log a message that says so. However, our enemies also use the <code>MeleeAction</code>, and we don&rsquo;t want to log messages for them, which is why we need to check if the player is the entity performing the action. If so, we can log it. Afterwards we return false. The only other change is that we appended <code>return true</code> to the end of the function. Moving on to <em>movement_action.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">var</span> destination: Vector2i <span style="color:#f92672">=</span> get_destination()
	
	<span style="color:#66d9ef">var</span> map_data: MapData <span style="color:#f92672">=</span> get_map_data()
	<span style="color:#66d9ef">var</span> destination_tile: Tile <span style="color:#f92672">=</span> map_data<span style="color:#f92672">.</span>get_tile(destination)
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> destination_tile <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> destination_tile<span style="color:#f92672">.</span>is_walkable() <span style="color:#f92672">or</span> get_blocking_entity_at_destination():
		<span style="color:#66d9ef">if</span> entity <span style="color:#f92672">==</span> get_map_data()<span style="color:#f92672">.</span>player:
			MessageLog<span style="color:#f92672">.</span>send_message(<span style="color:#e6db74">&#34;That way is blocked.&#34;</span>, GameColors<span style="color:#f92672">.</span>IMPOSSIBLE)
		<span style="color:#66d9ef">return</span> false
	entity<span style="color:#f92672">.</span>move(offset)
	<span style="color:#66d9ef">return</span> true
</code></pre></div><p>We had the checks for exit early before, and here I combined all three into a single check. Again, the enemies move as well, so we need to check if the player is doing the action. If so, and if the action cannot be performed for any of the reasons we check for, we log a message telling the player that the way is blocked. Again, we return false in the abort path and return true at the end of function. Now for the <em>wait_action.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">return</span> true
</code></pre></div><p>This one is easy. We just return true. The entire purpose of this action is to explicitly consume a turn without doing anything. We also need to handle the <em>bump_action.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">if</span> get_target_actor():
		<span style="color:#66d9ef">return</span> MeleeAction<span style="color:#f92672">.</span>new(entity, offset<span style="color:#f92672">.</span>x, offset<span style="color:#f92672">.</span>y)<span style="color:#f92672">.</span>perform()
	<span style="color:#66d9ef">else</span>:
		<span style="color:#66d9ef">return</span> MovementAction<span style="color:#f92672">.</span>new(entity, offset<span style="color:#f92672">.</span>x, offset<span style="color:#f92672">.</span>y)<span style="color:#f92672">.</span>perform()
</code></pre></div><p>We simply have to return the return value of the sub-actions we perform. Lastly, the <em>escape_action.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	entity<span style="color:#f92672">.</span>get_tree()<span style="color:#f92672">.</span>quit()
	<span style="color:#66d9ef">return</span> false
</code></pre></div><p>This is an odd one. The return statement is of no consequence here, because the game will stop running before there is another turn. Still, the function needs the return statement. With that change in place you should now be able to try that same thing from before, running into a wall in front of an enemy, and now you should see a message but not much else happening. And just like that we handled impossible actions, all without the need for exceptions. And with that we can get into starting with items. For now we will start with implementing consumables. We will tackle equipment in the last part of this series.</p>
<p>I mentioned before how I don&rsquo;t make a clear distinction between different kinds of entities. For now, we&rsquo;ll be able to pick up and consume everything that has a consumable component attached to it. Want to introduce an enemy made of cheese that can be eaten after it has been slain? Sure, just give it both the AI component and fighter component necessary for an enemy, as well as the healing consumable we&rsquo;ll shortly make.</p>
<p>First, we need a base class for consumables. Create a new script extending <code>Component</code> at <em>res://src/Entities/Actors/Components/consumable_component.gd</em>. This is just a basic base class for extending later:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name ConsumableComponent
<span style="color:#66d9ef">extends</span> Component


<span style="color:#66d9ef">func</span> get_action(consumer: Entity) <span style="color:#f92672">-&gt;</span> Action:
	<span style="color:#66d9ef">return</span> ItemAction<span style="color:#f92672">.</span>new(consumer, entity)


<span style="color:#66d9ef">func</span> activate(action: ItemAction) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">return</span> false
</code></pre></div><p>The <code>get_action()</code> method will certainly give you an error. We create the <code>ItemAction</code> in a moment. I&rsquo;ll explain that more when we get to it. The <code>activate()</code> method will be used to do whatever the item can do. There&rsquo;s a chance the item can&rsquo;t (or shouldn&rsquo;t) be used, like using a health potion when you&rsquo;re at full hp. That&rsquo;s why we have a boolean return value, which will integrate in the system that checks if an action has been performed. Now, how does the <code>ItemAction</code> look like? Create a new script extending <code>Action</code> at <em>res://src/Entities/Actors/Actions/item_action.gd</em>. Here&rsquo;s the top of that script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name ItemAction
<span style="color:#66d9ef">extends</span> Action

<span style="color:#66d9ef">var</span> item: Entity
<span style="color:#66d9ef">var</span> target_position: Vector2i
</code></pre></div><p>As you can see we store more than just the entity here. We also need to know the item we&rsquo;re interacting with. Some items will also require a target position, which we&rsquo;ll look at more in the next part.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _init(entity: Entity, item: Entity, target_position <span style="color:#f92672">=</span> null) <span style="color:#f92672">-&gt;</span> void:
	super<span style="color:#f92672">.</span>_init(entity)
	self<span style="color:#f92672">.</span>item <span style="color:#f92672">=</span> item
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> target_position is Vector2i:
		target_position <span style="color:#f92672">=</span> entity<span style="color:#f92672">.</span>grid_position
	self<span style="color:#f92672">.</span>target_position <span style="color:#f92672">=</span> target_position
</code></pre></div><p>Here you see that we give the additional parameters. Unfortunately, <code>Vector2i</code> is not nullable, so in order to be able to use null as a default argument we have to omit the type of <code>target_position</code> here. We set up the entity by invoking <code>super._init(entity)</code>, then setting up the item ourselves here. If we didn&rsquo;t pass in any target_position, we set it to the entities current position.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_target_actor() <span style="color:#f92672">-&gt;</span> Entity:
	<span style="color:#66d9ef">return</span> get_map_data()<span style="color:#f92672">.</span>get_actor_at_location(target_position)


<span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">if</span> item <span style="color:#f92672">==</span> null:
		<span style="color:#66d9ef">return</span> false
	<span style="color:#66d9ef">return</span> item<span style="color:#f92672">.</span>consumable_component<span style="color:#f92672">.</span>activate(self)
</code></pre></div><p>The <code>get_target_actor()</code> function is the same as we had in other classes before. <code>perform()</code> here checks if the item is not null, which should not happen in theory anyway. Then we call the <code>activate()</code> function on the item&rsquo;s consumable component, and return whatever that returns. Here we also have a bit of a circular dependency (which makes deciding the order in which I write the tutorial pretty difficult). We call that on the <code>consumable_component</code> variable of <code>item</code>. We still have to create that. So in <em>entity.gd</em> add the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">var</span> fighter_component: FighterComponent
<span style="color:#66d9ef">var</span> ai_component: BaseAIComponent
<span style="color:#66d9ef">var</span> consumable_component: ConsumableComponent
</code></pre></div><p>We can now turn our attention to implementing a more useful variant of the consumable, one for healing. However, we will configure it with a configuration resource, as we did the other components, so we need two of those first. Create a new script extending <code>Resource</code> at <em>res://src/Entities/Actors/Components/ComponentDefinitions/consumable_component_definition.gd</em>. Here is the contents of that file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name ConsumableComponentDefinition
<span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Resource</span>
</code></pre></div><p>Not very exciting, and you might wonder why we need that at all. Why not implement the healing consumable directly. The reason is polymorphism. In a bit we will add a field for a consumable definition to the entity definition. We want to be able to fill that field with any type of consumable definition. So we will define that field of this base type, which will allow us to fill it with all the various (actually useful) sub types. If you&rsquo;re not getting it now, don&rsquo;t worry. What I mean should become apparent once we actually define our healing potion. For now create another script, this time extenting <code>ConsumableComponentDefinition</code> at <em>res://src/Entities/Actors/Components/ComponentDefinitions/healing_consumable_component_definition.gd</em>. This will define a single variable storing the amount of healing:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name HealingConsumableComponentDefinition
<span style="color:#66d9ef">extends</span> ConsumableComponentDefinition

<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> healing_amount: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</code></pre></div><p>Now we&rsquo;re ready to create the healing consumable. Create yet another new script, this time extending <code>ConsumableComponent</code> at <em>res://src/Entities/Actors/Components/healing_consumable_component.gd</em>. Here&rsquo;s the top of the script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name HealingConsumableComponent
<span style="color:#66d9ef">extends</span> ConsumableComponent

<span style="color:#66d9ef">var</span> amount: <span style="color:#a6e22e">int</span>


<span style="color:#66d9ef">func</span> _init(definition: HealingConsumableComponentDefinition) <span style="color:#f92672">-&gt;</span> void:
	amount <span style="color:#f92672">=</span> definition<span style="color:#f92672">.</span>healing_amount
</code></pre></div><p>Pretty straight forward, we have an amount of healing we store, which we set from the definition we just created, which is passed into the <code>_init()</code> function. Now for the more interesting part:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> activate(action: ItemAction) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">var</span> consumer: Entity <span style="color:#f92672">=</span> action<span style="color:#f92672">.</span>entity
	<span style="color:#66d9ef">var</span> amount_recovered: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> consumer<span style="color:#f92672">.</span>fighter_component<span style="color:#f92672">.</span>heal(amount)
	<span style="color:#66d9ef">if</span> amount_recovered <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
		MessageLog<span style="color:#f92672">.</span>send_message(
			<span style="color:#e6db74">&#34;You consume the </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">, and recover </span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> HP!&#34;</span> <span style="color:#f92672">%</span> [entity<span style="color:#f92672">.</span>get_entity_name(), amount_recovered],
			GameColors<span style="color:#f92672">.</span>HEALTH_RECOVERED
		)
		<span style="color:#66d9ef">return</span> true
	MessageLog<span style="color:#f92672">.</span>send_message(<span style="color:#e6db74">&#34;Your health is already full.&#34;</span>, GameColors<span style="color:#f92672">.</span>IMPOSSIBLE)
	<span style="color:#66d9ef">return</span> false
</code></pre></div><p>We take the consumer from the action that&rsquo;s passed in. We then do the healing, and check how much we&rsquo;ve healed for. If we actually did some healing, we create an appropriate log message and return true. Otherwise we create a log message noting that we&rsquo;re at full health already, and return false, not consuming the item. You might notice that we did not actually consume the item in the other path either. That&rsquo;s because that requires us to manipulate the inventory, which we haven&rsquo;t created yet. But first, we need to make sure that consumable components are actually created on the entities. So first go into <em>entity_definition.gd</em>, to append our component definitions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#960050;background-color:#1e0010">@</span>export_category(<span style="color:#e6db74">&#34;Components&#34;</span>)
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> fighter_definition: FighterComponentDefinition
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> ai_type: Entity<span style="color:#f92672">.</span>AIType
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> consumable_definition: ConsumableComponentDefinition
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> inventory_capacity: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</code></pre></div><p>We&rsquo;ll only get to the inventory later, but it doesn&rsquo;t hurt to include the inventory capacity here as well. Now, in <code>set_entity_type()</code> in <em>entity.gd</em> we add the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">	<span style="color:#66d9ef">if</span> entity_definition<span style="color:#f92672">.</span>fighter_definition:
		fighter_component <span style="color:#f92672">=</span> FighterComponent<span style="color:#f92672">.</span>new(entity_definition<span style="color:#f92672">.</span>fighter_definition)
		add_child(fighter_component)
		
	<span style="color:#66d9ef">if</span> entity_definition<span style="color:#f92672">.</span>consumable_definition:
		<span style="color:#66d9ef">if</span> entity_definition<span style="color:#f92672">.</span>consumable_definition is HealingConsumableComponentDefinition:
			consumable_component <span style="color:#f92672">=</span> HealingConsumableComponent<span style="color:#f92672">.</span>new(entity_definition<span style="color:#f92672">.</span>consumable_definition)
			add_child(consumable_component)
</code></pre></div><p>After the chunk handling the fighter definition we add one for consumables. First we check if we have a consumable definition. Then we check if that definition is of type <code>HealingConsumableComponentDefinition</code>. If so, we use that to fill our consumable component variable with a new <code>HealingConsumableComponent</code>. Once we have more types of consumables we can expand this to check for the other types as well.</p>
<p>With all that in place we are actually ready to create our health potions. Create a new resource of type <code>EntityDefinition</code> at <em>res://assets/definitions/entities/items/health_potion_definition.tres</em>. Give it the <em>Name</em> &ldquo;<em>Health Potion</em>&rdquo;. Use the process we used before to select one of the flask icons as the <em>Texture</em>. As <em>Color</em> I used &ldquo;#7f00ff&rdquo;. Of course uncheck <em>Is Blocking Movement</em>, and set the <em>Type</em> to <em>Item</em>. Leave the <em>Fighter Definition</em> and <em>AI Type</em> alone, but click on the empty slot next to <em>Consumable Definition</em>. Here&rsquo;s what I meant before. You now have the option to create a new <code>ConsumableComponentDefinition</code>, but you also have the option to create a new <code>HealingConsumableComponentDefinition</code>. That way we can fill this slot with the definition we need (we will get more in the next part), and have all these options presented to us in the editor. Do now create a new <code>HealingConsumableComponentDefinition</code> and set the <em>Healing Amount</em> to 4.</p>
<p>Now we can move to placing these items. So in <em>dungeon_generator.gd</em> expand the <code>entity_types</code> constant to include the definition of the health potion:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">const</span> entity_types <span style="color:#f92672">=</span> {
	<span style="color:#e6db74">&#34;orc&#34;</span>: preload(<span style="color:#e6db74">&#34;res://assets/definitions/entities/actors/entity_definition_orc.tres&#34;</span>),
	<span style="color:#e6db74">&#34;troll&#34;</span>: preload(<span style="color:#e6db74">&#34;res://assets/definitions/entities/actors/entity_definition_troll.tres&#34;</span>),
	<span style="color:#e6db74">&#34;health_potion&#34;</span>: preload(<span style="color:#e6db74">&#34;res://assets/definitions/entities/items/health_potion_definition.tres&#34;</span>)
}
</code></pre></div><p>Then add the following line for a new exported variable:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#960050;background-color:#1e0010">@</span>export_category(<span style="color:#e6db74">&#34;Entities RNG&#34;</span>)
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> max_monsters_per_room: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> max_items_per_room: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</code></pre></div><p>Then we expand <code>_place_entities()</code>. We need to do the same thing as we did with the monsters, just a different number of times and with placing different things. There is probably a clever way to do this, but I just copy pasted most of the function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _place_entities(dungeon: MapData, room: Rect2i) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> number_of_monsters: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> _rng<span style="color:#f92672">.</span>randi_range(<span style="color:#ae81ff">0</span>, max_monsters_per_room)
	<span style="color:#66d9ef">var</span> number_of_items: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> _rng<span style="color:#f92672">.</span>randi_range(<span style="color:#ae81ff">0</span>, max_items_per_room)
	
	<span style="color:#66d9ef">for</span> _i <span style="color:#f92672">in</span> number_of_monsters:
		<span style="color:#66d9ef">var</span> x: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> _rng<span style="color:#f92672">.</span>randi_range(room<span style="color:#f92672">.</span>position<span style="color:#f92672">.</span>x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, room<span style="color:#f92672">.</span>end<span style="color:#f92672">.</span>x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">var</span> y: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> _rng<span style="color:#f92672">.</span>randi_range(room<span style="color:#f92672">.</span>position<span style="color:#f92672">.</span>y <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, room<span style="color:#f92672">.</span>end<span style="color:#f92672">.</span>y <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">var</span> new_entity_position :<span style="color:#f92672">=</span> Vector2i(x, y)
		
		<span style="color:#66d9ef">var</span> can_place <span style="color:#f92672">=</span> true
		<span style="color:#66d9ef">for</span> entity <span style="color:#f92672">in</span> dungeon<span style="color:#f92672">.</span>entities:
			<span style="color:#66d9ef">if</span> entity<span style="color:#f92672">.</span>grid_position <span style="color:#f92672">==</span> new_entity_position:
				can_place <span style="color:#f92672">=</span> false
				<span style="color:#66d9ef">break</span>
		
		<span style="color:#66d9ef">if</span> can_place:
			<span style="color:#66d9ef">var</span> new_entity: Entity
			<span style="color:#66d9ef">if</span> _rng<span style="color:#f92672">.</span>randf() <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.8</span>:
				new_entity <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(dungeon, new_entity_position, entity_types<span style="color:#f92672">.</span>orc)
			<span style="color:#66d9ef">else</span>:
				new_entity <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(dungeon, new_entity_position, entity_types<span style="color:#f92672">.</span>troll)
			dungeon<span style="color:#f92672">.</span>entities<span style="color:#f92672">.</span>append(new_entity)
	
	<span style="color:#66d9ef">for</span> _i <span style="color:#f92672">in</span> number_of_items:
		<span style="color:#66d9ef">var</span> x: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> _rng<span style="color:#f92672">.</span>randi_range(room<span style="color:#f92672">.</span>position<span style="color:#f92672">.</span>x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, room<span style="color:#f92672">.</span>end<span style="color:#f92672">.</span>x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">var</span> y: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> _rng<span style="color:#f92672">.</span>randi_range(room<span style="color:#f92672">.</span>position<span style="color:#f92672">.</span>y <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, room<span style="color:#f92672">.</span>end<span style="color:#f92672">.</span>y <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">var</span> new_entity_position :<span style="color:#f92672">=</span> Vector2i(x, y)
		
		<span style="color:#66d9ef">var</span> can_place <span style="color:#f92672">=</span> true
		<span style="color:#66d9ef">for</span> entity <span style="color:#f92672">in</span> dungeon<span style="color:#f92672">.</span>entities:
			<span style="color:#66d9ef">if</span> entity<span style="color:#f92672">.</span>grid_position <span style="color:#f92672">==</span> new_entity_position:
				can_place <span style="color:#f92672">=</span> false
				<span style="color:#66d9ef">break</span>
		
		<span style="color:#66d9ef">if</span> can_place:
			<span style="color:#66d9ef">var</span> new_entity: Entity <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(dungeon, new_entity_position, entity_types<span style="color:#f92672">.</span>health_potion)
			dungeon<span style="color:#f92672">.</span>entities<span style="color:#f92672">.</span>append(new_entity)
</code></pre></div><p>If you run the game now you should find up to two health potions per room. However, we can&rsquo;t even pick them up. But how could we we don&rsquo;t have anywhere to put them. So let&rsquo;s start with the inventory. This is another component, so create a new script extending <code>Component</code> at <em>res://src/Entities/Actors/Components/inventory_component.gd</em>. Here&rsquo;s the first half of the script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name InventoryComponent
<span style="color:#66d9ef">extends</span> Component

<span style="color:#66d9ef">var</span> items: <span style="color:#a6e22e">Array</span>[Entity]
<span style="color:#66d9ef">var</span> capacity: <span style="color:#a6e22e">int</span>


<span style="color:#66d9ef">func</span> _init(capacity: <span style="color:#a6e22e">int</span>) <span style="color:#f92672">-&gt;</span> void:
	items <span style="color:#f92672">=</span> []
	self<span style="color:#f92672">.</span>capacity <span style="color:#f92672">=</span> capacity
</code></pre></div><p>Pretty simple. We have an array that can hold entities, and a capacity telling us how much entities it can hold. We also create a <code>drop()</code> function right away:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> drop(item: Entity) <span style="color:#f92672">-&gt;</span> void:
	items<span style="color:#f92672">.</span>erase(item)
	<span style="color:#66d9ef">var</span> map_data: MapData <span style="color:#f92672">=</span> get_map_data()
	map_data<span style="color:#f92672">.</span>entities<span style="color:#f92672">.</span>append(item)
	map_data<span style="color:#f92672">.</span>entity_placed<span style="color:#f92672">.</span>emit(item)
	item<span style="color:#f92672">.</span>map_data <span style="color:#f92672">=</span> map_data
	item<span style="color:#f92672">.</span>grid_position <span style="color:#f92672">=</span> entity<span style="color:#f92672">.</span>grid_position
	MessageLog<span style="color:#f92672">.</span>send_message(<span style="color:#e6db74">&#34;You dropped the </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">.&#34;</span> <span style="color:#f92672">%</span> item<span style="color:#f92672">.</span>get_entity_name(), <span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>WHITE)
</code></pre></div><p>In this function, we first remove the item we want to remove from our <code>items</code> array. We obtain a reference to <code>map_data</code>. We add the item back into the <code>entities</code> array of our <code>map_data</code>. After the initial dungeon generation the map goes through all the entities and places them. If we drop an item now it won&rsquo;t be attached to the <strong>Map</strong> note. Therefore we will have to create a signal on <code>map_data</code> that tells the <strong>Map</strong> node when entities are placed at a later time. Here we emit that signal. We also set the item&rsquo;s map data reference to that of the entity that dropped it. This might seem irrelevant now, but later when we have multiple levels we will be able to take items from one level to the next, and drop them into a different map data than they originally are. We also set the position of the item to the position of the entity dropping it, so it&rsquo;s dropped just below that entity. Lastly, we create a log message detailing what happened. Now, as mentioned we have to create a new signal in <em>map_data.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name MapData
<span style="color:#66d9ef">extends</span> RefCounted

<span style="color:#66d9ef">signal</span> entity_placed(entity)
</code></pre></div><p>Then in <em>map.gd</em> we modify the <code>generate()</code> function as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> generate(player: Entity) <span style="color:#f92672">-&gt;</span> void:
	map_data <span style="color:#f92672">=</span> dungeon_generator<span style="color:#f92672">.</span>generate_dungeon(player)
	map_data<span style="color:#f92672">.</span>entity_placed<span style="color:#f92672">.</span>connect(entities<span style="color:#f92672">.</span>add_child)
	_place_tiles()
	_place_entities()
</code></pre></div><p>Here, once we have the <code>map_data</code> we connect that <code>entity_placed</code> signal to the <strong>Entities</strong> node&rsquo;s <code>add_child()</code> function. The signal also has the entity as an argument, which it will pass into <code>add_child()</code>. This means by simply emitting that signal, the entity will be added onto the map.</p>
<p>Let&rsquo;s integrate the inventory into the entity. In <em>entity.gd</em> add a variable for a new component:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">var</span> fighter_component: FighterComponent
<span style="color:#66d9ef">var</span> ai_component: BaseAIComponent
<span style="color:#66d9ef">var</span> consumable_component: ConsumableComponent
<span style="color:#66d9ef">var</span> inventory_component: InventoryComponent
</code></pre></div><p>Again, we will handle this in <code>set_entity_type()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">	<span style="color:#66d9ef">if</span> entity_definition<span style="color:#f92672">.</span>consumable_definition:
		<span style="color:#66d9ef">if</span> entity_definition<span style="color:#f92672">.</span>consumable_definition is HealingConsumableComponentDefinition:
			consumable_component <span style="color:#f92672">=</span> HealingConsumableComponent<span style="color:#f92672">.</span>new(entity_definition<span style="color:#f92672">.</span>consumable_definition)
			add_child(consumable_component)
	
	<span style="color:#66d9ef">if</span> entity_definition<span style="color:#f92672">.</span>inventory_capacity <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
		inventory_component <span style="color:#f92672">=</span> InventoryComponent<span style="color:#f92672">.</span>new(entity_definition<span style="color:#f92672">.</span>inventory_capacity)
		add_child(inventory_component)
</code></pre></div><p>After the code we have created for the consumable above, we add a check to see if our inventory capacity is more than 0. If it isn&rsquo;t it doesn&rsquo;t make much sense to even give the entity an inventory, so we don&rsquo;t. To make the player have an inventory, go into <em>entity_definition_player.tres</em> and set the <em>Inventory Capacity</em> to 26. We will have a system where we access the items in the inventory by assigning them letters, so with 26 letters in the English alphabet we have 26 spots in the inventory.</p>
<p>For picking up we want an array that&rsquo;s filtered for things we can pick up, just like we had for actors. That&rsquo;s why we add the following function to <em>map_data.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_items() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Array</span>[Entity]:
	<span style="color:#66d9ef">var</span> items: <span style="color:#a6e22e">Array</span>[Entity] <span style="color:#f92672">=</span> []
	<span style="color:#66d9ef">for</span> entity <span style="color:#f92672">in</span> entities:
		<span style="color:#66d9ef">if</span> entity<span style="color:#f92672">.</span>consumable_component <span style="color:#f92672">!=</span> null:
			items<span style="color:#f92672">.</span>append(entity)
	<span style="color:#66d9ef">return</span> items
</code></pre></div><p>This is similar to how we did the actors array. We create a new array and fill it with all the entities from the entities array that do have a consumable component attached. With the inventory in place, we can start work on the item interactions. The first thing we need for that are some new input actions. We&rsquo;ll just create all the ones we need right now. Go into <em>Project</em> &gt; <em>Project Settings</em> and select the <em>Input Map</em> tab. Create tree new actions with the following names and associated keys:</p>
<table>
<thead>
<tr>
<th>Action</th>
<th>Key</th>
</tr>
</thead>
<tbody>
<tr>
<td>pickup</td>
<td>G</td>
</tr>
<tr>
<td>drop</td>
<td>D</td>
</tr>
<tr>
<td>activate</td>
<td>I</td>
</tr>
</tbody>
</table>
<p>Here it might be useful to not use the physical key code, i.e., the position on a US keyboard, but the equivalent key code, as these are mnemonics. So we remember that <em>dropping</em> is done with <em>d</em>, and while the key arrangement was more important for the directional keys, here it might be more important to remember which key it is. However, there are quite a few key arrangements out there, and because we are using the vim style direction keys (using the letter keys), we can&rsquo;t rule out that there won&rsquo;t be collisions in certain layouts. If we wouldn&rsquo;t use those I would actually recommend using the key codes directly, but we don&rsquo;t know if the <em>d</em> key is in the place of the <em>h</em> key in some language, which would result in a drop action every time a player using the vim direction keys would want to go left. So keep that option in mind for your own projects.</p>
<p>But now let&rsquo;s turn our attention to an action for picking up all the potions we have laying around. Create a new script extending <code>Action</code> at <em>res://src/Entities/Actors/Actions/pickup_action.gd</em>. Here is the code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name PickupAction
<span style="color:#66d9ef">extends</span> Action


<span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">var</span> inventory: InventoryComponent <span style="color:#f92672">=</span> entity<span style="color:#f92672">.</span>inventory_component
	<span style="color:#66d9ef">var</span> map_data: MapData <span style="color:#f92672">=</span> get_map_data()
	
	<span style="color:#66d9ef">for</span> item <span style="color:#f92672">in</span> map_data<span style="color:#f92672">.</span>get_items():
		<span style="color:#66d9ef">if</span> entity<span style="color:#f92672">.</span>grid_position <span style="color:#f92672">==</span> item<span style="color:#f92672">.</span>grid_position:
			<span style="color:#66d9ef">if</span> inventory<span style="color:#f92672">.</span>items<span style="color:#f92672">.</span>size() <span style="color:#f92672">&gt;=</span> inventory<span style="color:#f92672">.</span>capacity:
				MessageLog<span style="color:#f92672">.</span>send_message(<span style="color:#e6db74">&#34;Your inventory is full.&#34;</span>, GameColors<span style="color:#f92672">.</span>IMPOSSIBLE)
				<span style="color:#66d9ef">return</span> false
			
			map_data<span style="color:#f92672">.</span>entities<span style="color:#f92672">.</span>erase(item)
			item<span style="color:#f92672">.</span>get_parent()<span style="color:#f92672">.</span>remove_child(item)
			inventory<span style="color:#f92672">.</span>items<span style="color:#f92672">.</span>append(item)
			MessageLog<span style="color:#f92672">.</span>send_message(
				<span style="color:#e6db74">&#34;You picked up the </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">!&#34;</span> <span style="color:#f92672">%</span> item<span style="color:#f92672">.</span>get_entity_name(),
				<span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>WHITE
			)
			<span style="color:#66d9ef">return</span> true
	
	MessageLog<span style="color:#f92672">.</span>send_message(<span style="color:#e6db74">&#34;There is nothing here to pick up.&#34;</span>, GameColors<span style="color:#f92672">.</span>IMPOSSIBLE)
	<span style="color:#66d9ef">return</span> false
</code></pre></div><p>In the action we first get the inventory of the entity performing the action. The player is the only entity with an inventory, and also the only entity that will be able to perform this action, so we expect this code to work. In a more complex game however we might want to check if there actually is an inventory component. (This is true for a lot of code here, but I wanted to note it here.) We then use our new <code>map_data.get_items()</code> function to loop through all the items. If we find one on the position of the performing entity, we next need to check if there is space in the inventory. If not, we note that in the message log and return false. Otherwise we remove the entity from the <code>map_data</code>, and also remove it as a child from the <strong>Map</strong> node. That way it will appear neither in our map data nor on the screen. We then just have to append it to the inventory&rsquo;s <code>items</code> array, note the pickup in the message log and return true (because that is a successful action). Lastly, if we go through the whole loop without finding an item (and therefore returning early), we create a message that there is nothing to pick up, and then return false. Let&rsquo;s now make use of that action. Go into <em>main_game_input_handler.gd</em> and insert a check for that in <code>get_action()</code> as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;view_history&#34;</span>):
		get_parent()<span style="color:#f92672">.</span>transition_to(InputHandler<span style="color:#f92672">.</span>InputHandlers<span style="color:#f92672">.</span>HISTORY_VIEWER)
	
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;pickup&#34;</span>):
		action <span style="color:#f92672">=</span> PickupAction<span style="color:#f92672">.</span>new(player)	
	
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;quit&#34;</span>) <span style="color:#f92672">or</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;ui_back&#34;</span>):
		action <span style="color:#f92672">=</span> EscapeAction<span style="color:#f92672">.</span>new(player)
</code></pre></div><p>If the <em>pickup</em> action is pressed we return a <code>PickupAction</code>, simple as that. You should now be able to run the game and move around the dungeon to find some health potions. Once you&rsquo;re standing on a health potion you should be able to pick it up. You won&rsquo;t be able to do anything with it, or even view the inventory. But that will require a new way to display and interact with items in the inventory. What we will do is to create a new UI element that we can populate with the items from our inventory, and that allows us to select one.</p>
<p>Create an new scene with a <code>CanvasLayer</code> as root node. Rename that node <strong>InventoryMenu</strong>, then save it at <em>res://src/GUI/InventorMenu/inventory_menu.tscn</em>. Add a <code>CenterContainer</code> as it&rsquo;s child. Set that node to use the <em>Full Rect</em>. Add a <code>PanelContainer</code> as a child to it. Add a <code>VBoxContainer</code> as a child of the <strong>PanelContainer</strong>. To that we add three children: A <code>Label</code> node we will name <strong>TitleLabel</strong>, an <code>HSeparator</code>, and another <code>VBoxContainer</code> we call <strong>InventoryList</strong>. Set both the <strong>Title Label</strong> as well as the <strong>InventoryList</strong> to be accessible via unique names.</p>
<p>Now to the configuration. Go back into the <em>game</em> scene and select the <strong>StatsPanel</strong>. Scroll down to <em>Theme Overrides</em> &gt; <em>Styles</em> &gt; <em>Panel</em>, right click the <code>StyleBoxTexture</code> resource we have created there and click <em>Copy</em>. Then, back in our <em>Inventory Menu</em> scene, select the <strong>PanelContainer</strong>. Go to <em>Theme Overrides</em> &gt; <em>Styles</em> &gt; <em>Panel</em> on that node, click into the empty slot and select <em>Paste</em>. Now we have reused the panel border we already have.</p>
<p>For the <strong>TitleLabel</strong> create a new <em>LabelSetting</em> and fill it with &ldquo;<em>Kenney Pixel.ttf</em>&rdquo; again. Set both <em>Horizontal</em> and <em>Vertical Alignment</em> to <em>Center</em>. On the <strong>HSeparator</strong> go down to <em>Theme Overrides</em> &gt; <em>Styles</em> &gt; <em>Separator</em>, and create a new <code>StyleBoxLine</code> in that slot, and set its <em>Color</em> to white, to fit with the rest of our UI.</p>
<p>To create a list of items we will have to instantiate a ui element. We could do labels, but if we do buttons we can get a lot of the functionality we need for free. For these list items I often like to create a separate scene and configure them there, even if it&rsquo;s just a single node, as I feel it&rsquo;s easier to configure it in the editor than doing everything in code. So let&rsquo;s do that. Create a new scene with a <code>Button</code> as root node. Rename that button to <strong>InventoryMenuButton</strong> and save it next to the other scene at <em>res://src/GUI/InventorMenu/inventory_menu_item.tscn</em>. Set <em>Alignment</em> to <em>Left</em>. Set <em>Action Mode</em> to <em>Button Press</em>. Then uncheck <em>Shortcut Feedback</em>. Under <em>Container Sizing</em> check the <em>Horizontal Expand</em>.</p>
<p>Now to the visuals. Scroll down to <em>Theme Overrides</em>. Change all the <em>Font</em> related colors to white. Set the <em>Font</em> to use &ldquo;<em>Kenney Pixel.ttf</em>&rdquo;. Under Style create a new <code>StyleBoxEmpty</code> in the <em>Normal</em> slot. Copy it to the <em>Disabled</em> Style by dragging and dropping. Then create a new <code>StyleBoxFlat</code> in the <em>Hover</em> slot. Uncheck <em>Draw Center</em>, set all the <em>Border Width</em> values to 1 px, and set the <em>Border Color</em> to white. Once all that&rsquo;s configured copy that style box into the <em>Pressed</em> and <em>Focussed</em> slots. And that&rsquo;s it, we can now proceed to code that interface.</p>
<p>I mentioned the inventory corresponding to letters before. What we will do is to associate each inventory item with a letter, which will be displayed next to the item name. We can then select an item we want to interact with by pressing that letter. We do that by defining that letter&rsquo;s key as shortcut key for the button. However, as the items are represented by buttons, we can also use the mouse to select them, and it will work just the same. Even better, as the buttons are within a <code>VBoxContainer</code> godot automatically knows that the buttons are above one another, and as we have defined the focussed state of the buttons to be indicated with a border, we can even use the arrow keys or the tab key to go through that list, and Godot will automatically focus and thereby highlight the next item, and we can confirm our choice with the enter key. In the <em>Inventory Menu</em> scene attach a new script to <strong>InventoryMenu</strong> and save it at <em>res://src/GUI/InventorMenu/inventory_menu.gd</em>. Let&rsquo;s start with that script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name InventoryMenu
<span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">CanvasLayer</span>

<span style="color:#66d9ef">signal</span> item_selected(item)

<span style="color:#66d9ef">const</span> inventory_menu_item_scene :<span style="color:#f92672">=</span> preload(<span style="color:#e6db74">&#34;res://src/GUI/InventorMenu/inventory_menu_item.tscn&#34;</span>)

<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> inventory_list: <span style="color:#a6e22e">VBoxContainer</span> <span style="color:#f92672">=</span> <span style="color:#f92672">$</span><span style="color:#e6db74">&#34;%InventoryList&#34;</span>
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> title_label: <span style="color:#a6e22e">Label</span> <span style="color:#f92672">=</span> <span style="color:#f92672">$</span><span style="color:#e6db74">&#34;%TitleLabel&#34;</span>
</code></pre></div><p>As you can see we will emit a signal to report which item was selected. We also get a reference to the packed scene of the button we just configured, as well as references to the two nodes we will interact with, the <code>title_label</code>, as we will be able to configure that, as well as the <code>inventory_list</code>, which is just the <code>VBoxContainer</code> we drop all the buttons into.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _ready() <span style="color:#f92672">-&gt;</span> void:
	hide()
</code></pre></div><p>This scene will need to be configured before it&rsquo;s used, so initially we hide it. The configuration should usually happen in the same frame as we instantiate this scene, so it&rsquo;s probably not strictly necessary, but it doesn&rsquo;t hurt to put this here either.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> button_pressed(item: Entity <span style="color:#f92672">=</span> null) <span style="color:#f92672">-&gt;</span> void:
	item_selected<span style="color:#f92672">.</span>emit(item)
	queue_free()
</code></pre></div><p>This function will be called when a button is pressed. It will emit the associated item, then delete the item menu. We will spawn a new item menu every time we go into the inventory, so we need to get rid of it again.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _register_item(index: <span style="color:#a6e22e">int</span>, item: Entity) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> item_button: <span style="color:#a6e22e">Button</span> <span style="color:#f92672">=</span> inventory_menu_item_scene<span style="color:#f92672">.</span>instantiate()
	<span style="color:#66d9ef">var</span> char: <span style="color:#a6e22e">String</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">String</span><span style="color:#f92672">.</span>chr(<span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">.</span>unicode_at(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> index)
	item_button<span style="color:#f92672">.</span>text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;( </span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> ) </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> [char, item<span style="color:#f92672">.</span>get_entity_name()]
	<span style="color:#66d9ef">var</span> shortcut_event :<span style="color:#f92672">=</span> <span style="color:#a6e22e">InputEventKey</span><span style="color:#f92672">.</span>new()
	shortcut_event<span style="color:#f92672">.</span>keycode <span style="color:#f92672">=</span> KEY_A <span style="color:#f92672">+</span> index
	item_button<span style="color:#f92672">.</span>shortcut <span style="color:#f92672">=</span> Shortcut<span style="color:#f92672">.</span>new()
	item_button<span style="color:#f92672">.</span>shortcut<span style="color:#f92672">.</span>events <span style="color:#f92672">=</span> [shortcut_event]
	item_button<span style="color:#f92672">.</span>pressed<span style="color:#f92672">.</span>connect(button_pressed<span style="color:#f92672">.</span>bind(item))
	inventory_list<span style="color:#f92672">.</span>add_child(item_button)
</code></pre></div><p>In order to fill our list with items, we create a helper function for individual items. <code>_register_item()</code> takes an integer index (the position in the list/inventory), as well as the item itself as arguments. First, we instantiate a button. Then we calculate a <code>char</code> variable. That&rsquo;s the letter associated with the item. Unfortunately Godot doesn&rsquo;t have a character type, so this looks a bit messy (the alternative would be to have a constant array containing the alphabet). What happens here is that we take the unicode representation of the letter &ldquo;a&rdquo;, then add the index to it. Within unicode the letter codes are sorted alphabetically, so by transforming that back into a string we get the appropriate letter (&ldquo;a&rdquo; + 0 is &ldquo;a&rdquo;, &ldquo;a&rdquo; + 1 is &ldquo;b&rdquo;, and so forth). Next we set the text of the button, by putting the <code>char</code> in parenthesis and appending the item name.</p>
<p>Then we handle setting up the shortcut. We create a new input event, whose <code>keycode</code> we set to <code>KEY_A + index</code>. The keycode enums are sorted alphabetically as well, so by adding the index to <code>KEY_A</code> we do in fact get the appropriate key code. We then create a shortcut resource and set the input event we created as the single event the shortcut will listen to.</p>
<p>Then we connect the button&rsquo;s <code>pressed</code> signal to our <code>button_pressed()</code> function. That function expects an item argument, so we bind the item to that signal. That way all the information we need is encoded, no need to manually handle items later. Lastly, we add the button to the <code>inventory_list</code>. Now to building the complete list:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> build(title_text: <span style="color:#a6e22e">String</span>, inventory: InventoryComponent) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">if</span> inventory<span style="color:#f92672">.</span>items<span style="color:#f92672">.</span>is_empty():
		button_pressed<span style="color:#f92672">.</span>call_deferred()
		MessageLog<span style="color:#f92672">.</span>send_message(<span style="color:#e6db74">&#34;No items in inventory.&#34;</span>, GameColors<span style="color:#f92672">.</span>IMPOSSIBLE)
		<span style="color:#66d9ef">return</span>
	title_label<span style="color:#f92672">.</span>text <span style="color:#f92672">=</span> title_text
	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> inventory<span style="color:#f92672">.</span>items<span style="color:#f92672">.</span>size():
		_register_item(i, inventory<span style="color:#f92672">.</span>items[i])
	inventory_list<span style="color:#f92672">.</span>get_child(<span style="color:#ae81ff">0</span>)<span style="color:#f92672">.</span>grab_focus()
	show()
</code></pre></div><p>The <code>build()</code> function takes a text for the title, and of course the inventory it should display. Of course, the inventory could be empty. In that case we defer a call to <code>button_pressed()</code>. We need to use <code>call_deferred()</code> instead of calling it directly, because of how we call this function. Otherwise we would lock the game. I will come back to that when it becomes relevant. We also log a message telling the player why we won&rsquo;t show an inventory. Then we simply return. The <code>button_pressed()</code> call will take care of freeing the menu.</p>
<p>If we do have stuff in the inventory, we set the <code>title_label</code>&rsquo;s text, and then loop over all the indices of the <code>items</code> array, then call <code>_register_item()</code> for each of the items. We loop over the indices rather than the items directly, as we need to know them for registering the item. Then we have the first item grab the focus, which will make it highlighted. Lastly, we show the menu. So far we can select an item, but we need a way to not select an item and get back to the game.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _physics_process(_delta: <span style="color:#a6e22e">float</span>) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;ui_back&#34;</span>):
		item_selected<span style="color:#f92672">.</span>emit(null)
		queue_free()
</code></pre></div><p>In <code>_physics_process()</code> we check if a &ldquo;ui_back&rdquo; action was pressed, and if so we emit <code>item_selected</code> with <code>null</code> and queue_free() the menu. We do have a menu that can let us select items, but before we get to implement it, we need to take care of a few other things first. We need to create the actions that will make use of the selected items, and after that we will put everything together. Create a new script extending <code>ItemAction</code> at <em>res://src/Entities/Actors/Actions/drop_item_action.gd</em>. Here&rsquo;s its contents:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name DropItemAction
<span style="color:#66d9ef">extends</span> ItemAction


<span style="color:#66d9ef">func</span> perform() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">if</span> item <span style="color:#f92672">==</span> null:
		<span style="color:#66d9ef">return</span> false
	entity<span style="color:#f92672">.</span>inventory_component<span style="color:#f92672">.</span>drop(item)
	<span style="color:#66d9ef">return</span> true
</code></pre></div><p>In perform we actually have an item. We had our selection process return <code>null</code> if we didn&rsquo;t or couldn&rsquo;t select something, so we&rsquo;re handling it here. If we do have an item, we call <code>inventory_component.drop()</code>, which we already implemented. That&rsquo;s a proper action performed, so we return true.</p>
<p>Let us look at how to put this together before we move to using items. In the <strong>MainGameInputHandler</strong>, when the <em>drop</em> action is pressed, we will create our item selection menu and wait for it to report the selected item back. However, using this approach has a slight problem. We will use <code>await</code>, and while we await the item, the engine still happily calls <code>_physics_process()</code> on all other nodes, including our game which will try to fetch more actions from the <strong>MainGameInputHandler</strong>. That means without taking care of that the player could move their character while the item selection menu is open. There are several ways to circumvent this. We will exploit our state machine a bit, by creating a dummy input handler that does nothing, and which is active during this process.</p>
<p>So, create a new <code>Node</code> as a child of <strong>InputHandler</strong> and rename that node to <strong>DummyInputHandler</strong>. Take <em>base_input_handler.gd</em> and drag it onto the node, attaching that script. The base input handler does not really do anything, which is just what we want from our dummy. However, we need to account for it in our state machine. Modify the top of <em>input_handler.gd</em> as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">enum</span> InputHandlers {MAIN_GAME, GAME_OVER, HISTORY_VIEWER, DUMMY}

<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> start_input_handler: InputHandlers

<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> input_handler_nodes :<span style="color:#f92672">=</span> {
	InputHandlers<span style="color:#f92672">.</span>MAIN_GAME: <span style="color:#f92672">$</span>MainGameInputHandler,
	InputHandlers<span style="color:#f92672">.</span>GAME_OVER: <span style="color:#f92672">$</span>GameOverInputHandler,
	InputHandlers<span style="color:#f92672">.</span>HISTORY_VIEWER: <span style="color:#f92672">$</span>HistoryViewerInputHandler,
	InputHandlers<span style="color:#f92672">.</span>DUMMY: <span style="color:#f92672">$</span>DummyInputHandler,
}
</code></pre></div><p>Now we can integrate that action in <em>main_game_input_handler.gd</em>. To spawn the inventory menu, we need a reference to the scene:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">
</code></pre></div><p>We need a helper function for that:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">const</span> directions <span style="color:#f92672">=</span> {
	<span style="color:#e6db74">&#34;move_up&#34;</span>: Vector2i<span style="color:#f92672">.</span>UP,
	<span style="color:#e6db74">&#34;move_down&#34;</span>: Vector2i<span style="color:#f92672">.</span>DOWN,
	<span style="color:#e6db74">&#34;move_left&#34;</span>: Vector2i<span style="color:#f92672">.</span>LEFT,
	<span style="color:#e6db74">&#34;move_right&#34;</span>: Vector2i<span style="color:#f92672">.</span>RIGHT,
	<span style="color:#e6db74">&#34;move_up_left&#34;</span>: Vector2i<span style="color:#f92672">.</span>UP <span style="color:#f92672">+</span> Vector2i<span style="color:#f92672">.</span>LEFT,
	<span style="color:#e6db74">&#34;move_up_right&#34;</span>: Vector2i<span style="color:#f92672">.</span>UP <span style="color:#f92672">+</span> Vector2i<span style="color:#f92672">.</span>RIGHT,
	<span style="color:#e6db74">&#34;move_down_left&#34;</span>: Vector2i<span style="color:#f92672">.</span>DOWN <span style="color:#f92672">+</span> Vector2i<span style="color:#f92672">.</span>LEFT,
	<span style="color:#e6db74">&#34;move_down_right&#34;</span>: Vector2i<span style="color:#f92672">.</span>DOWN <span style="color:#f92672">+</span> Vector2i<span style="color:#f92672">.</span>RIGHT,
}

<span style="color:#66d9ef">const</span> inventory_menu_scene <span style="color:#f92672">=</span> preload(<span style="color:#e6db74">&#34;res://src/GUI/InventorMenu/inventory_menu.tscn&#34;</span>)
</code></pre></div><p>Next, we need a helper function that asynchronously can get us a selected item:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_item(window_title: <span style="color:#a6e22e">String</span>, inventory: InventoryComponent) <span style="color:#f92672">-&gt;</span> Entity:
	<span style="color:#66d9ef">var</span> inventory_menu: InventoryMenu <span style="color:#f92672">=</span> inventory_menu_scene<span style="color:#f92672">.</span>instantiate()
	add_child(inventory_menu)
	inventory_menu<span style="color:#f92672">.</span>build(window_title, inventory)
	get_parent()<span style="color:#f92672">.</span>transition_to(InputHandler<span style="color:#f92672">.</span>InputHandlers<span style="color:#f92672">.</span>DUMMY)
	<span style="color:#66d9ef">var</span> selected_item: Entity <span style="color:#f92672">=</span> await inventory_menu<span style="color:#f92672">.</span>item_selected
	await get_tree()<span style="color:#f92672">.</span>physics_frame
	get_parent()<span style="color:#f92672">.</span>call_deferred(<span style="color:#e6db74">&#34;transition_to&#34;</span>, InputHandler<span style="color:#f92672">.</span>InputHandlers<span style="color:#f92672">.</span>MAIN_GAME)
	<span style="color:#66d9ef">return</span> selected_item
</code></pre></div><p>First, we instantiate our inventory menu, and add it as a child. Then we call <code>build()</code> to initialize it with the proper title and the inventory. After that we switch to the dummy input handler. Then we get the selected item with <code>await</code>. This will stop this function&rsquo;s execution until <code>inventory_menu</code> emits the <code>item_selected</code> signal. Note how we only start listening for that signal two lines after building the menu. That is the reason why we used <code>call_deferred()</code> in the <code>build()</code> function. If we didn&rsquo;t the inventory menu would emit that signal and only then would we stop everything until we get that signal. If we weren&rsquo;t careful here an empty inventory could lock our game.</p>
<p>When the player selects an item or even when they exit the inventory menu they will press a button. So that button is in the <em>just pressed</em> state, meaning if we switch back to main game input handler right away, it could register those buttons as action inputs. To prevent that we wait for a frame using <code>await get_tree().physics_frame</code>, and then defer the transition back to the main game input handler. I can&rsquo;t really explain why we need to wait and then call the transition deferred, but I had problems with these double inputs otherwise. Lastly, we return the selected item. With that helper function in place we can now expand <code>get_action()</code> with the code for our drop action:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;pickup&#34;</span>):
		action <span style="color:#f92672">=</span> PickupAction<span style="color:#f92672">.</span>new(player)
	
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;drop&#34;</span>):
		<span style="color:#66d9ef">var</span> selected_item: Entity <span style="color:#f92672">=</span> await get_item(<span style="color:#e6db74">&#34;Select an item to drop&#34;</span>, player<span style="color:#f92672">.</span>inventory_component)
		action <span style="color:#f92672">=</span> DropItemAction<span style="color:#f92672">.</span>new(player, selected_item)
</code></pre></div><p>You see we call <code>get_item()</code> with <code>await</code>. That stops us the function execution here until we get a return value. Once we have a return value, i.e., the selected item, we will continue by assigning a new <code>DropItemAction</code> with the selected item to our <code>action</code>. And with that, dropping should work. Run the project and try it out. You can now run around, collect health potions and then drop them again. That&rsquo;s nice and all, but if you get hit by enemies while collecting the health potions, it would be nice if you could also use them.</p>
<p>But first, we need to modify our consumable a bit. Remember how our code wouldn&rsquo;t get rid of a used health potion? We couldn&rsquo;t do that when we implemented that, because there wasn&rsquo;t an inventory yet from which to remove the consumed consumable. But now we can do that. Go to <em>consumable_component.gd</em> and add the following function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> consume(consumer: Entity) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> inventory: InventoryComponent <span style="color:#f92672">=</span> consumer<span style="color:#f92672">.</span>inventory_component
	inventory<span style="color:#f92672">.</span>items<span style="color:#f92672">.</span>erase(entity)
	entity<span style="color:#f92672">.</span>queue_free()
</code></pre></div><p>We simply get the consumer&rsquo;s inventory, remove the item from the <code>items</code> array and then queue it free. Remember, entities are nodes, they are not <code>RefCounted</code> so we need to manage their lifetime ourselves. Now that we can consume consumables, let&rsquo;s do so in <em>healing_consumable_component.gd</em>. Add a call to <code>consume()</code> as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> activate(action: ItemAction) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">var</span> consumer: Entity <span style="color:#f92672">=</span> action<span style="color:#f92672">.</span>entity
	<span style="color:#66d9ef">var</span> amount_recovered: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> consumer<span style="color:#f92672">.</span>fighter_component<span style="color:#f92672">.</span>heal(amount)
	<span style="color:#66d9ef">if</span> amount_recovered <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
		MessageLog<span style="color:#f92672">.</span>send_message(
			<span style="color:#e6db74">&#34;You consume the </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">, and recover </span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> HP!&#34;</span> <span style="color:#f92672">%</span> [entity<span style="color:#f92672">.</span>get_entity_name(), amount_recovered],
			GameColors<span style="color:#f92672">.</span>HEALTH_RECOVERED
		)
		consume(consumer)
		<span style="color:#66d9ef">return</span> true
	MessageLog<span style="color:#f92672">.</span>send_message(<span style="color:#e6db74">&#34;Your health is already full.&#34;</span>, GameColors<span style="color:#f92672">.</span>IMPOSSIBLE)
	<span style="color:#66d9ef">return</span> false
</code></pre></div><p>Back in <em>main_game_input_handler.gd</em> we can now add the following check to <code>get_action()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;drop&#34;</span>):
		<span style="color:#66d9ef">var</span> selected_item: Entity <span style="color:#f92672">=</span> await get_item(<span style="color:#e6db74">&#34;Select an item to drop&#34;</span>, player<span style="color:#f92672">.</span>inventory_component)
		action <span style="color:#f92672">=</span> DropItemAction<span style="color:#f92672">.</span>new(player, selected_item)
	
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;activate&#34;</span>):
		<span style="color:#66d9ef">var</span> selected_item: Entity <span style="color:#f92672">=</span> await get_item(<span style="color:#e6db74">&#34;Select an item to use&#34;</span>, player<span style="color:#f92672">.</span>inventory_component)
		action <span style="color:#f92672">=</span> ItemAction<span style="color:#f92672">.</span>new(player, selected_item)
</code></pre></div><p>Everything else was already in place, so we just need to select the item, like we did for the drop action, and then create an <code>ItemAction</code>. The basic item action already is set up to activate the consumable component of the item. If you run the game now, you should be able to go into your inventory with <em>i</em>. Once you have health potions they should show up there, and once you have sustained some damage you should be able to use them to heal some of that lost hp.</p>
<p>That concludes this part of the tutorial. Next time we will expand on our consumables with some magic scrolls.</p>




      </main>
  </div>
  </body>
</html>
