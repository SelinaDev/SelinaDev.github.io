<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="generator" content="Hugo 0.92.2" />
  <link rel="canonical" href="https://selinadev.github.io/06-rogueliketutorial-02/">

  
    
    <meta name="description" content="Part 2: Generic Entity and the Map Continuing from the last tutorial ( https://selinadev.github.io/05-rogueliketutorial-01/ ), we will now move to creating a more generic entity, and then start on the structure of our map.
So letâ€™s start with creating out entity class. I want to point out that my approach differs a bit from the original tutorial. In that tutorial all properties of an entity are set in its constructor. A later part eventually uses a factory pattern to create a few prototype entities in code and then spawn copies of them.">
  

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#000000">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" type="text/css" href="/css/paper.css">

  
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css">
  
  
    
  

  
  
  <title>Yet Another Roguelike Tutorial, Part 2 | SelinaDev</title>
</head>

  <body>
    <div class="container paper">
      <nav class="border split-nav">
  <div class="nav-brand">
    <h3><a href="/">SelinaDev</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
    <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
      
        <li><a href="/">Blog</a></li>
      
        <li><a href="/tags/">Tags</a></li>
      
        <li><a href="/about/">About</a></li>
      
      </ul>
    </div>
  </div>
</nav>
      <main>
        

<h1 class="post-title">Yet Another Roguelike Tutorial, Part 2</h1>


<strong>Publish date: </strong>Jul 11, 2023
<br>

  <strong>Tags: </strong>
  
    <a href="/tags/godot4">godot4</a>
  
    <a href="/tags/tutorial">tutorial</a>
  
    <a href="/tags/roguelike">roguelike</a>
  



  



<h1 id="part-2-generic-entity-and-the-map">Part 2: Generic Entity and the Map</h1>
<p>Continuing from the last tutorial ( <a href="https://selinadev.github.io/05-rogueliketutorial-01/">https://selinadev.github.io/05-rogueliketutorial-01/</a> ), we will now move to creating a more generic entity, and then start on the structure of our map.</p>
<p>So let&rsquo;s start with creating out entity class. I want to point out that my approach differs a bit from the original tutorial. In that tutorial all properties of an entity are set in its constructor. A later part eventually uses a factory pattern to create a few prototype entities in code and then spawn copies of them. However, if we have a range of properties that we want to slot into entities the common approach in Godot is to use resources. So what we&rsquo;ll do is we&rsquo;ll create an <code>EntityDefinition</code> resource and set all the properties there. We only have the player to define at the moment, so right now this might feel like unnecessary extra work, but the payoff should become apparent in Part 5. For now, let&rsquo;s create a new script under <em>res://src/Entities/entity_definition.gd</em>. It will have the following contents:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name EntityDefinition
<span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Resource</span>

<span style="color:#960050;background-color:#1e0010">@</span>export_category(<span style="color:#e6db74">&#34;Visuals&#34;</span>)
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> texture: <span style="color:#a6e22e">AtlasTexture</span>
<span style="color:#960050;background-color:#1e0010">@</span>export_color_no_alpha <span style="color:#66d9ef">var</span> color: <span style="color:#a6e22e">Color</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>WHITE
</code></pre></div><p>We give it the name &ldquo;EntityDefinition&rdquo;, so we have a type and can easily find it, and we also have it extend <code>Resource</code>. The <code>@export_category(&quot;Visuals&quot;)</code> might be unfamiliar if you come from Godot 3. This is a new annotation that lets us group exported properties in the editor, making things more organized. We only have a <em>Visuals</em> category for now, but in later parts we will expand this class with properties fitting in other categories. The properties we export are a <em>texture</em> of type <code>AtlasTexture</code> and a <em>color</em> (without alpha, to prevent us from accidentally creating transparent entities). I&rsquo;ve used <code>Atlas Texture</code> in this case as we have a single sprite sheet as source for all our graphics. If you use a different graphics pack with individual image files I&rsquo;d recommend changing this to just <code>Texture</code>. Using <code>Atlas Texture</code> simply saves us the effort of going through the list of options every time and selecting the <code>Atlas Texture</code> option.</p>
<p>Let&rsquo;s move on to the actual entity class. Create a file next to the entity definition at <em>res://src/Entities/entity.gd</em>. Here&rsquo;s the top of the script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name Entity
<span style="color:#66d9ef">extends</span> Sprite2D

<span style="color:#66d9ef">var</span> grid_position: Vector2i:
	set(value):
		grid_position <span style="color:#f92672">=</span> value
		position <span style="color:#f92672">=</span> Grid<span style="color:#f92672">.</span>grid_to_world(grid_position)

</code></pre></div><p>It will extend <code>Sprite2D</code>, just like the player we already have (and will soon replace with an instance of this class). As explained in the previous part we have a discrepancy between screen/world coordinates and coordinates on the grid. To solve this issue we create a <code>grid_position</code> property with a setter that takes care of updating the world position whenever we change the position on the grid. Just by using this simple setter everything is taken care of. Now the second part of the script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _init(start_position: Vector2i, entity_definition: EntityDefinition) <span style="color:#f92672">-&gt;</span> void:
	centered <span style="color:#f92672">=</span> false
	grid_position <span style="color:#f92672">=</span> start_position
	texture <span style="color:#f92672">=</span> entity_definition<span style="color:#f92672">.</span>texture
	modulate <span style="color:#f92672">=</span> entity_definition<span style="color:#f92672">.</span>color


<span style="color:#66d9ef">func</span> move(move_offset: Vector2i) <span style="color:#f92672">-&gt;</span> void:
	grid_position <span style="color:#f92672">+=</span> move_offset
</code></pre></div><p>First, we have a constructor that takes a start position (in grid coordinates) and an entity definition. The start position will be different from entity to entity, even if they are the same entity type. Within the <code>_init()</code> function we first set centered to false. That way the position describes the position of the top left corner of the sprite, rather than its center. It should not make too much difference in our case, but I feel this is good form, as it would make adding multi-cell sprites a bit easier (by just assigning them the position of their top left cell). Next we set the grid position to the start position, spawning the sprite wherever we define. Then we take the <em>texture</em> and <em>color</em> from the entity definition and assign it to the <em>texture</em> and <em>modulate</em> of the sprite. Note that in order for coloring via the <em>modulate</em> property to work properly we need to have white on black or white on transparent sprites. We do, so this works out nicely, but keep this in mind if you want to use different assets. If you have colored assets you probably won&rsquo;t need to touch the modulate at all.</p>
<p>Lastly, we give the entity the ability to move by an offset. The <code>move()</code> function just takes such a <em>move_offset</em> and adds it to the <em>grid_position</em>.</p>
<p>Let&rsquo;s now see how we can use this entity class to spawn a player and an NPC. For this we first need to create a new resource of our custom <code>EntityDefinition</code> type. Create one as <em>res://assets/definitions/entities/actors/entity_definition_player.tres</em>. In the inspector click on the <em>texture</em> slot and create a new <code>AtlasTexture</code>. Fill its <em>Atlas</em> property with our sprite sheet and use the <em>Edit Region</em> interface to select the icon that you want for our player. Select a color for the player. I&rsquo;ve left it at our default white, so the icon stands out against the black background, but you can choose whatever you like. Make sure that resource is saved, and we&rsquo;ll move on to modify the <em>game.dg</em> script of our main <strong>Game</strong> node. Modify the top of the script to read as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name Game
<span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Node2D</span>

<span style="color:#66d9ef">const</span> player_definition: EntityDefinition <span style="color:#f92672">=</span> preload(<span style="color:#e6db74">&#34;res://assets/definitions/entities/actors/entity_definition_player.tres&#34;</span>)

<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> player: Entity
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> event_handler: EventHandler <span style="color:#f92672">=</span> <span style="color:#f92672">$</span>EventHandler
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> entities: <span style="color:#a6e22e">Node2D</span> <span style="color:#f92672">=</span> <span style="color:#f92672">$</span>Entities


<span style="color:#66d9ef">func</span> _ready() <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> player_start_pos: Vector2i <span style="color:#f92672">=</span> Grid<span style="color:#f92672">.</span>world_to_grid(get_viewport_rect()<span style="color:#f92672">.</span>size<span style="color:#f92672">.</span>floor() <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)
	player <span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(player_start_pos, player_definition)
	entities<span style="color:#f92672">.</span>add_child(player)
	<span style="color:#66d9ef">var</span> npc :<span style="color:#f92672">=</span> Entity<span style="color:#f92672">.</span>new(player_start_pos <span style="color:#f92672">+</span> Vector2i<span style="color:#f92672">.</span>RIGHT, player_definition)
	npc<span style="color:#f92672">.</span>modulate <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>ORANGE_RED
	entities<span style="color:#f92672">.</span>add_child(npc)
</code></pre></div><p>The first important change is a new constant holding the player definition. We preload it so we can easily use it later in the <code>_ready()</code> function. The player entity will keep track of it&rsquo;s own position, so we can get rid of the <code>player_grid_pos</code> variable we previously had. Speaking of the player entity, we modify the <code>player</code> variable to now be of the type <code>Entity</code> rather than <code>Sprite2D</code>. Also, we get rid of the reference to <em>$Player</em>. While we&rsquo;re at it, delete the <strong>Player</strong> node from the scene tree as well, we&rsquo;ll be spawning our own player in code in a moment. To logically group them we will spawn our entities into a node, which we will call <strong>Entities</strong>. In the code you can see us obtaining a reference to that node, so now is also the time to create a new <code>Node2D</code> as a child of <strong>Game</strong> and call it <strong>Entities</strong>.</p>
<p>In the <code>_ready()</code> function we first calculate a (temporary) starting position for our player. We calculate the grid position corresponding to the center of our game window for that. If you paid attention you&rsquo;d have noticed that the <code>player</code> variable currently does not hold anything. So now we create a new entity at the <code>player_start_pos</code> using the <em>player_definition</em>, and store it in <code>player</code>. Then we add the player as a child of <strong>Entities</strong>. Next we spawn another <code>Entity</code>, one cell to the right of the player, using the same definition. We then change its color to orange to differentiate the (temporary) <code>npc</code> from the <code>player</code> visually. And then we also add the <code>npc</code> to <strong>Entities</strong>.</p>
<p>You should now be able to run the project and see two characters at the center of the screen. You won&rsquo;t be able to move the player, as we haven&rsquo;t linked our actions and entities just yet. We&rsquo;ll get to that, but first let&rsquo;s take care of laying the foundations for our dungeon by creating a map class.</p>
<p>Here I want to talk about a difference in approaches again. The original python tutorial is a bit more oriented toward keeping the map as data, and having a render function that creates a visual representation from that data every turn. However, in Godot, similar to how we did with the player, we choose objects that can draw themselves, allowing us to just once tell them how they should look, and occasionally update where they should be, with the engine handling the actual drawing. I could very well create a game map that&rsquo;s a node in the scene tree, and have it have functions to access it&rsquo;s data. However, the map data needs to be accessed and passed around a lot over the course of this tutorial. For that reason I chose to separate concerns by having a map class that just holds the data, and a map node that hold an instance of that map data and use it to create the visual representation, i.e., act as a place to hold the tiles.</p>
<p>Speaking of tiles, I will in fact deviate from the classic Godot approach a bit by not using a <code>TileMap</code> node. The main reason for that is the lighting system we&rsquo;ll be adding in part 4. Each tile will have a lit and an unlit version, which will be differentiated by a different color. With just one sprite sheet asset and using our modulate trick this would be surprisingly difficult using the builtin <code>TileMap</code>. Considering our simple tile set on the other hand we won&rsquo;t need any of the specialized functionality of that node, like autotiling. Therefore, I believe that my approach using Sprites and placing them in code is justified.</p>
<p>Now, after some considerations and explanations let&rsquo;s move on to the map. Or rather its building blocks, i.e., tiles. In this tutorial we will have two different types of tiles. Each tile type will have the same characteristics. This sounds quite a bit like what I explained above with how we&rsquo;ll handle different types if entities, which is why again we will start with a tile definition resource. For that create a new script at <em>res://src/Map/tile_definition.gd</em>. Here&rsquo;s the contents:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name TileDefinition
<span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Resource</span>

<span style="color:#960050;background-color:#1e0010">@</span>export_category(<span style="color:#e6db74">&#34;Visuals&#34;</span>)
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> texture: <span style="color:#a6e22e">AtlasTexture</span>
<span style="color:#960050;background-color:#1e0010">@</span>export_color_no_alpha <span style="color:#66d9ef">var</span> color_lit: <span style="color:#a6e22e">Color</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>WHITE
<span style="color:#960050;background-color:#1e0010">@</span>export_color_no_alpha <span style="color:#66d9ef">var</span> color_dark: <span style="color:#a6e22e">Color</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>WHITE

<span style="color:#960050;background-color:#1e0010">@</span>export_category(<span style="color:#e6db74">&#34;Mechanics&#34;</span>)
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> is_walkable: <span style="color:#a6e22e">bool</span> <span style="color:#f92672">=</span> true
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> is_transparent: <span style="color:#a6e22e">bool</span> <span style="color:#f92672">=</span> true
</code></pre></div><p>Here you can see the export categories in action, with three exported variables being grouped under the <em>visuals</em> category and two under <em>mechanics</em>. We have a <em>texture</em> property, which will define the icon we use for the tile. Skipping a bit ahead from the original tutorial which only defines the dark color we have both a <em>color_dark</em> for when the tile is unlit, and a <em>color_lit</em> for when it&rsquo;s in the field of view. We won&rsquo;t be using the lit color until part 4 though, but it doesn&rsquo;t hurt to define it now. Under the mechanics we have two boolean variables. <em>is_walkable</em> tells us whether entities can walk onto this tile. And <em>is_transparent</em> will come in play for the field of view calculations. In our case we only have tiles that match, i.e., either walkable and transparent (floor) or impassible and opaque (walls). However, by separating them you can easily have tiles like windows that allow you to see through but not walk through.</p>
<p>Let&rsquo;s go right ahead and create our two definitions. Create a <code>TileDefinition</code> resource at <em>res://assets/definitions/tiles/tile_definition_floor.tres</em>. Select a texture from the sprite sheet the same way we did for the player. I used #ff7f00 (orange) for the lit color and #7f3f00 (darker orange/brown) for the dark color. Both <em>is_walkable</em> and <em>is_transparent</em> should be ticked. Next create another <code>TileDefinition</code> at <em>res://assets/definitions/tiles/tile_definition_wall.tres</em>. Select a nice wall texture. For the wall I&rsquo;m using #ffffff (white) for the lit color and #7f7f7f (mid gray) as the dark color. More importantly make sure to uncheck <em>is_walkable</em> as well as <em>is_transparent</em>.</p>
<p>Now for the tile itself. Create a new script at <em>res://src/Map/tile.gd</em>. Here&rsquo;s what we&rsquo;ll write into that:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name Tile
<span style="color:#66d9ef">extends</span> Sprite2D

<span style="color:#66d9ef">var</span> _definition: TileDefinition


<span style="color:#66d9ef">func</span> _init(grid_position: Vector2i, tile_definition: TileDefinition) <span style="color:#f92672">-&gt;</span> void:
	centered <span style="color:#f92672">=</span> false
	position <span style="color:#f92672">=</span> Grid<span style="color:#f92672">.</span>grid_to_world(grid_position)
	set_tile_type(tile_definition)


<span style="color:#66d9ef">func</span> set_tile_type(tile_definition: TileDefinition) <span style="color:#f92672">-&gt;</span> void:
	_definition <span style="color:#f92672">=</span> tile_definition
	texture <span style="color:#f92672">=</span> _definition<span style="color:#f92672">.</span>texture
	modulate <span style="color:#f92672">=</span> _definition<span style="color:#f92672">.</span>color_dark


<span style="color:#66d9ef">func</span> is_walkable() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">return</span> _definition<span style="color:#f92672">.</span>is_walkable


<span style="color:#66d9ef">func</span> is_transparent() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">return</span> _definition<span style="color:#f92672">.</span>is_transparent
</code></pre></div><p>As you can see we will extent <code>Sprite2D</code>. They hold the definition of what tile type they are, so they can access that data. The <code>is_walkable()</code> and <code>is_transparent()</code> functions only forward the data from the definition. That way the tile only needs to hold a reference to the definition it shares with all the other tiles, without needing to copy a lot of variables. In the <code>_init()</code> function we set the tiles position. We don&rsquo;t need fancy setters like with the <code>Entity</code>, because tiles shouldn&rsquo;t change their position once it&rsquo;s set. You also see that we uncenter the sprite, which I already explained for the entity above. Then we have a <code>set_tile_type()</code> function. While the position will be set in stone for the tiles, their type won&rsquo;t be, as you&rsquo;ll see in the next part, when we get to map generation. So this little function does all the things we need to to when the type changes. It set&rsquo;s the _<em>definition</em> variable, so that <code>is_walkable()</code> and <code>is_transparent()</code> access the correct data. It also sets the texture and initializes the <em>modulate</em> to the dark color. We will do more fancy things with the tiles once we get to the field of view. But for now it is usable and we can move on to the map.</p>
<p>As I explained before we will start with the map data. Most of the equivalent code for the map from the original tutorial will go here. Yet another deviation I should mention is that I will not use a two-dimensional array (array of arrays), but rather use a flat array with an indexing function. On the one hand I ultimately find that easier to handle, on the other hand does this approach work better with Godot&rsquo;s typing system. So let us create a new script at <em>res://src/Map/map_data.gd</em>. Let us go through the script step by step. Here&rsquo;s the top of the script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name MapData
<span style="color:#66d9ef">extends</span> RefCounted

<span style="color:#66d9ef">const</span> tile_types <span style="color:#f92672">=</span> {
	<span style="color:#e6db74">&#34;floor&#34;</span>: preload(<span style="color:#e6db74">&#34;res://assets/definitions/tiles/tile_definition_floor.tres&#34;</span>),
	<span style="color:#e6db74">&#34;wall&#34;</span>: preload(<span style="color:#e6db74">&#34;res://assets/definitions/tiles/tile_definition_wall.tres&#34;</span>),
}

<span style="color:#66d9ef">var</span> width: <span style="color:#a6e22e">int</span>
<span style="color:#66d9ef">var</span> height: <span style="color:#a6e22e">int</span>
<span style="color:#66d9ef">var</span> tiles: <span style="color:#a6e22e">Array</span>[Tile]
</code></pre></div><p>We give it a class name and have it extend <code>RefCounted</code>. Whenever I have something that isn&rsquo;t a node or a resource I like to have it inherit from <code>RefCounted</code>. The difference to <code>Object</code> is that you have to delete classes extending <code>Object</code> yourself, while classes extending <code>RefCounted</code> will keep track of how often they are referenced. Once a <code>RefCounted</code> object is no longer stored as a variable anywhere, i.e., there are zero references to it, it will delete itself (which is the behavior we usually want for objects like this).</p>
<p>We then have a constant storing our tile types, so we can easily access the definitions we have created in code. For variables we have a width and a height, that will store the extents of the map, unsurprisingly. And an array of <code>Tile</code>s, that we simply call tiles. Now if you think about it, it might seem odd that we go to the lengths of having a non-node <code>MapData</code> class only to have that store a bunch of nodes. However, this should make sense once we get to the map node, or at the latest in the next part, when we get to map generation. For now, let me show you the <code>_init()</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _init(map_width: <span style="color:#a6e22e">int</span>, map_height: <span style="color:#a6e22e">int</span>) <span style="color:#f92672">-&gt;</span> void:
	width <span style="color:#f92672">=</span> map_width
	height <span style="color:#f92672">=</span> map_height
	_setup_tiles()
</code></pre></div><p>Not very surprising, we give it a width and a height and store these in the variables we just defined. Then we initialize the tiles in a <code>_setup_tiles()</code> function, which looks as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _setup_tiles() <span style="color:#f92672">-&gt;</span> void:
	tiles <span style="color:#f92672">=</span> []
	<span style="color:#66d9ef">for</span> y <span style="color:#f92672">in</span> height:
		<span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> width:
			<span style="color:#66d9ef">var</span> tile_position :<span style="color:#f92672">=</span> Vector2i(x, y)
			<span style="color:#66d9ef">var</span> tile :<span style="color:#f92672">=</span> Tile<span style="color:#f92672">.</span>new(tile_position, tile_types<span style="color:#f92672">.</span>floor)
			tiles<span style="color:#f92672">.</span>append(tile)
	<span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">34</span>):
		<span style="color:#66d9ef">var</span> tile: Tile <span style="color:#f92672">=</span> get_tile(Vector2i(x, <span style="color:#ae81ff">22</span>))
		tile<span style="color:#f92672">.</span>set_tile_type(tile_types<span style="color:#f92672">.</span>wall)
</code></pre></div><p>First we make sure <code>tiles</code> is an empty array. Then we start nested <code>for</code> loops. We want to fill the <code>tiles</code> row by row. That is why the outer loop increments through all the y indices, i.e., rows, from 0 to <code>height - 1</code> and the inner loop goes through each x in that row, from 0 to <code>width - 1</code>. For each tile we first create a vector for its position, then create a floor tile at that position. For now we just initialize the whole dungeon with floor. To play around with just a bit of wall we then iterate over the tiles (30, 22), (31, 22), (32, 22), and (33, 22). We get these tiles with the <code>get_tile()</code> function which we&rsquo;ll implement in a moment. Once we have retrieved those tiles we set it&rsquo;s type to wall. Now for that <code>get_tile()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_tile(grid_position: Vector2i) <span style="color:#f92672">-&gt;</span> Tile:
	<span style="color:#66d9ef">var</span> tile_index: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> grid_to_index(grid_position)
	<span style="color:#66d9ef">if</span> tile_index <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
		<span style="color:#66d9ef">return</span> null
	<span style="color:#66d9ef">return</span> tiles[tile_index]
</code></pre></div><p>As I mentioned, we are not using a 2D array. The original tutorial does that, and it would allow us to access tiles like <code>tiles[x][y]</code>. However, for type safety and simplicity I have decided to go with a flat array instead. To retrieve the correct tile from that we need to get its index (with a function I&rsquo;ll explain shortly). If the tile doesn&rsquo;t exist, that function returns -1, so in that case we will return <code>null</code>. If it does, we simply use that index to return the correct tile. So how do we get that index?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> grid_to_index(grid_position: Vector2i) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">int</span>:
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> is_in_bounds(grid_position):
		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">return</span> grid_position<span style="color:#f92672">.</span>y <span style="color:#f92672">*</span> width <span style="color:#f92672">+</span> grid_position<span style="color:#f92672">.</span>x
</code></pre></div><p><code>grid_to_index()</code>, needs to check if the requested <em>grid_position</em> lies within the bounds of the map (with another function we&rsquo;ll look at below). If it lies outside, and the corresponding tile does not exist, we return <code>-1</code> as described above. If it does exist we can calculate an index. Remember how we made sure to fill the <code>tiles</code> array row by row. We also know that each row has <code>width</code> tiles. So <code>grid_position.y * width</code> jumps the index ahead to the chunk of tiles that represent the row corresponding to the y coordinate of our position. From there we only need to cound the number of columns corresponding to the x coordinate, i.e., add <code>grid_position.x</code>. That way we can calculate any index in our flat array.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> is_in_bounds(coordinate: Vector2i) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
	<span style="color:#66d9ef">return</span> (
		<span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> coordinate<span style="color:#f92672">.</span>x
		<span style="color:#f92672">and</span> coordinate<span style="color:#f92672">.</span>x <span style="color:#f92672">&lt;</span> width
		<span style="color:#f92672">and</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> coordinate<span style="color:#f92672">.</span>y
		<span style="color:#f92672">and</span> coordinate<span style="color:#f92672">.</span>y <span style="color:#f92672">&lt;</span> height
	)
</code></pre></div><p>As promised, the <code>is_in_bounds()</code> function. It is just a bunch of checks to make sure the x coordinate is not lower than 0 or higher than (or equal to) the <em>width</em>, and the same with the y coordinate and <em>height</em> correspondingly. So if the coordinate is in the rectangle described by our map, for which we have valid tiles, we return <code>ture</code>, otherwise we return <code>false</code>.</p>
<p>That&rsquo;s it for the <code>MapData</code> for now, so let&rsquo;s move on to the map node. Create a new <code>Node2D</code> as child of the <strong>Game</strong> node. Add a script to it and save it at <em>res://src/Map/map.gd</em>. This script is relatively simple:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name Map
<span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Node2D</span>

<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> map_width: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">80</span>
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> map_height: <span style="color:#a6e22e">int</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">45</span>

<span style="color:#66d9ef">var</span> map_data: MapData


<span style="color:#66d9ef">func</span> _ready() <span style="color:#f92672">-&gt;</span> void:
	map_data <span style="color:#f92672">=</span> MapData<span style="color:#f92672">.</span>new(map_width, map_height)
	_place_tiles()


<span style="color:#66d9ef">func</span> _place_tiles() <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">for</span> tile <span style="color:#f92672">in</span> map_data<span style="color:#f92672">.</span>tiles:
		add_child(tile)
</code></pre></div><p>We give it a name and we export the desired <em>map_width</em> and <em>map_height</em>. This is an advantage of Godot, that we can have these configuration parameters right at the nodes where they matter, while the original tutorial defines these parameters more centralized.</p>
<p>You see that we hold a reference to a <code>MapData</code> object. In the <code>_ready()</code> function we create that <em>map_data</em> and then call <code>place_tiles()</code>. That function simply loops through all the tiles. The tiles are <code>Sprite2D</code> nodes, but so far they are not part of the scene tree, so here we add each one, meaning they will now be drawn by the engine.</p>
<p>And that&rsquo;s the map. Now we need to connect it to the other parts of our game. First in <em>game.gd</em>. We need a reference to the map, so expand <code>@onready</code> block:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> player: Entity
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> event_handler: EventHandler <span style="color:#f92672">=</span> <span style="color:#f92672">$</span>EventHandler
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> entities: <span style="color:#a6e22e">Node2D</span> <span style="color:#f92672">=</span> <span style="color:#f92672">$</span>Entities
<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> map: Map <span style="color:#f92672">=</span> <span style="color:#f92672">$</span>Map
</code></pre></div><p>We won&rsquo;t do that much with the map node, but we will often need the map data it holds, so for our convenience add the following function to the bottom of the script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> get_map_data() <span style="color:#f92672">-&gt;</span> MapData:
	<span style="color:#66d9ef">return</span> map<span style="color:#f92672">.</span>map_data
</code></pre></div><p>Now we can get the map_data from the <code>Game</code> class. The game still isn&rsquo;t playable, and we could do an intermediate step here, but I want to go right ahead to making our actions more useful. For that we first expand <em>action.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name Action
<span style="color:#66d9ef">extends</span> RefCounted


<span style="color:#66d9ef">func</span> perform(game: Game, entity: Entity) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">pass</span>
</code></pre></div><p>Each subclass of <code>Action</code> will now have the <code>perform()</code> function, which takes in a reference to both our <em>game</em> (allowing it to access all the useful data) and to the <em>entity</em> performing the action. For the base action this <code>perform()</code> does nothing, because we will never instantiate the base class (the original tutorial even has this function create an error, and we could too here, if we wanted). Now let&rsquo;s implement some <code>perform()</code> functions that actually do something. Modify <em>escape_action.gd</em> as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name EscapeAction
<span style="color:#66d9ef">extends</span> Action


<span style="color:#66d9ef">func</span> perform(game: Game, entity: Entity) <span style="color:#f92672">-&gt;</span> void:
	game<span style="color:#f92672">.</span>get_tree()<span style="color:#f92672">.</span>quit()
</code></pre></div><p>For the escape action we get the scene tree from the <em>game</em> and call <code>quit()</code> on it. This essentially moves the code we previously had in <em>game.gd</em> into the action itself. Next the <em>movement_action.gd</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd">class_name MovementAction
<span style="color:#66d9ef">extends</span> Action

<span style="color:#66d9ef">var</span> offset: Vector2i


<span style="color:#66d9ef">func</span> _init(dx: <span style="color:#a6e22e">int</span>, dy: <span style="color:#a6e22e">int</span>) <span style="color:#f92672">-&gt;</span> void:
	offset <span style="color:#f92672">=</span> Vector2i(dx, dy)


<span style="color:#66d9ef">func</span> perform(game: Game, entity: Entity) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> destination: Vector2i <span style="color:#f92672">=</span> entity<span style="color:#f92672">.</span>grid_position <span style="color:#f92672">+</span> offset
	
	<span style="color:#66d9ef">var</span> map_data: MapData <span style="color:#f92672">=</span> game<span style="color:#f92672">.</span>get_map_data()
	<span style="color:#66d9ef">var</span> destination_tile: Tile <span style="color:#f92672">=</span> map_data<span style="color:#f92672">.</span>get_tile(destination)
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> destination_tile <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> destination_tile<span style="color:#f92672">.</span>is_walkable():
		<span style="color:#66d9ef">return</span>
	entity<span style="color:#f92672">.</span>move(offset)
</code></pre></div><p>In the new <code>perform()</code> function we first calculate the <em>destination</em> coordinate. Then we get the <em>map_data</em> from <em>game</em> (I told you that would be useful) and use that to retrieve the <em>destination_tile</em>. The if statement first checks whether or not we even have a tile. If the destination tile lies outside the bounds of the map area it would be <code>null</code>. The other reason we would not want to move is if the tile is not walkable. In both these cases we return from the function. If the code gets to the last statement we know we are allowed to move the entity, so we do so.</p>
<p>To make use of this new action functionality we delete the existing <code>_process()</code> function in <em>game.dg</em> and replace it with the following <code>_physics_process()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-gd" data-lang="gd"><span style="color:#66d9ef">func</span> _physics_process(_delta: <span style="color:#a6e22e">float</span>) <span style="color:#f92672">-&gt;</span> void:
	<span style="color:#66d9ef">var</span> action: Action <span style="color:#f92672">=</span> event_handler<span style="color:#f92672">.</span>get_action()
	<span style="color:#66d9ef">if</span> action:
		action<span style="color:#f92672">.</span>perform(self, player)
</code></pre></div><p>The switch from <code>_process()</code> to <code>_physics_process()</code> seems arbitrary now. The reason to use <code>_physics_process()</code> is that in the next part we will introduce a camera that will move with the player, and using <code>_process()</code> introduced some unwanted flickering. Other then that this function still serves our purpose of obtaining an action from the <em>event_handler</em> and then executing it. But now, rather than checking what type of action it is and reacting appropriately here, we can now just call <code>perform()</code> on the <em>action</em> and have it execute itself. If it&rsquo;s an <code>EscapeAction</code> that action will quit the game, if it&rsquo;s a <code>MovementAction</code> it will move the player if possible.</p>
<p>You can now run the project. You should see the player and an npc surrounded by floor and a short range of wall. The player should move when pressing the arrow keys, and while you will notice that you won&rsquo;t be able to move into the wall, you&rsquo;ll also notice that the player can occupy the same space as the npc and will be drawn behind it. We will remedy that in a short while, once we introduce the actual enemies. For now, I hope you could follow along. Remember that you can find the complete code in the accompanying GitHub repository: <a href="https://github.com/SelinaDev/Godot-Roguelike-Tutorial">https://github.com/SelinaDev/Godot-Roguelike-Tutorial</a></p>




      </main>
  </div>
  </body>
</html>
